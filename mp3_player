import tkinter as tk
import pygame
import os
import json
import gc
import stat
from tkinter import ttk, colorchooser, messagebox, filedialog
import signal

# 自然排序处理
from natsort import natsorted
import re

import threading
import time
import wave
import contextlib
import logging
import numpy as np
import whisper
import pyaudio
import sys
from logging.handlers import RotatingFileHandler, TimedRotatingFileHandler

import hashlib
import random
import requests
import ctypes
import chardet
import queue
import psutil
import atexit

from pydub import AudioSegment
from pydub.playback import play

from text_to_subtitle import WhisperSubtitleGenerator  # 当前使用_ver0012复制版，实际另行查看
# 在文件开头导入主题管理器
from theme_manager import ThemeManager
from file_solve import normalize_filename  # 从 utils 模块导入 normalize_filename
from screen_x import ScreenRecorderApp

# 导入图像转换工具
try:
    from png_to_ico import ImageConverterApp, ThemeManager as IconThemeManager
except ImportError:
    # 如果导入失败，创建一个空的占位类
    class ImageConverterApp:
        def __init__(self, root=None, standalone=True):
            messagebox.showerror("错误", "未能加载图像转换工具模块，请确保png_to_ico.py文件存在")

import shutil
from collections import deque
# 使用系统TTS播放文本
import pyttsx3

import datetime
import traceback
import unicodedata
from pathlib import Path

import wave
import subprocess
import functools

import tempfile

from bisect import bisect_left

import torch
print(torch.__version__)

def safe_call(func):
    """安全调用装饰器，捕获异常并更新状态栏。

    Args:
        func: 被装饰的函数或方法。

    Returns:
        装饰后的函数。
    """

    @functools.wraps(func)  # 保留原始函数的元信息（如函数名、文档字符串等）
    def wrapper(self, *args, **kwargs):
        try:
            # 记录函数调用（调试信息）
            if hasattr(self, 'logger'):
                self.logger.debug(f"调用函数: {func.__name__}")
            return func(self, *args, **kwargs)
        except Exception as e:
            # 使用类中的 logger 记录错误（如果存在），否则使用全局 logging
            logger = getattr(self, 'logger', logging)
            logger.error(f"调用函数 {func.__name__} 失败: {e}", exc_info=True)  # exc_info=True 记录堆栈信息
            # 更新状态栏
            if hasattr(self, 'update_status'):
                self.update_status(f"{func.__name__} 操作失败: {str(e)}", 'error')
            # 根据需要，可以选择重新抛出异常
            # raise  # 如果需要让调用方处理异常，取消注释此行
            return None  # 或者返回一个默认值，避免调用方因无返回值而报错

    return wrapper


def handle_audio_error(func):
    def wrapper(self, *args, **kwargs):
        try:
            return func(self, *args, **kwargs)
        except pygame.error as e:
            messagebox.showerror("音频错误", f"操作失败: {str(e)}")
        except Exception as e:
            messagebox.showerror("错误", f"未知错误: {str(e)}")

    return wrapper

def get_resource_path(relative_path):
    """获取资源文件的绝对路径，兼容开发环境和PyInstaller打包环境"""
    try:
        # PyInstaller创建临时文件夹_MEIxxxx
        base_path = getattr(sys, '_MEIPASS', os.path.dirname(os.path.abspath(__file__)))
        return os.path.join(base_path, relative_path)
    except Exception:
        return os.path.join(os.path.dirname(os.path.abspath(__file__)), relative_path)

class SubtitleGeneratorWindow:
    def __init__(self, parent):
        # 添加主题管理器
        self.theme_manager = ThemeManager()

        self.window = tk.Toplevel(parent)
        self.window.title("字幕生成器")
        self.window.geometry("600x800")

        self.logger = get_logger('SubtitleGenerator')  # 获取模块特定的日志记录器
        self.logger.info("初始化 SubtitleGeneratorWindow")

        # 应用主题到窗口
        self.theme_manager.apply_theme_to_window(self.window)

        # 应用主题到ttk样式
        style = ttk.Style()
        self.theme_manager.apply_theme_to_ttk_styles(style)

        # 绑定主题变更事件
        self.window.bind("<<ThemeChanged>>", self.update_theme)

        # 应用主题到窗口
        self.theme_manager.apply_theme_to_window(self.window)

        # 应用主题到ttk样式
        style = ttk.Style()
        self.theme_manager.apply_theme_to_ttk_styles(style)

        # 绑定主题变更事件
        self.window.bind("<<ThemeChanged>>", self.update_theme)

        self.original_app_id = ''
        self.original_app_key = ''

        # 百度翻译API配置
        self.api_frame = ttk.LabelFrame(self.window, text="百度翻译API配置")
        self.api_frame.pack(fill="x", padx=10, pady=5)

        # APP ID 输入框
        ttk.Label(self.api_frame, text="APP ID:").grid(row=0, column=0, padx=5, pady=5, sticky='e')
        self.app_id_entry = ttk.Entry(self.api_frame)
        self.app_id_entry.grid(row=0, column=1, padx=5, pady=5, sticky='ew')

        self.app_id_entry.bind('<FocusOut>', lambda e: self.update_api_config())

        # API Key 输入框
        ttk.Label(self.api_frame, text="API Key:").grid(row=1, column=0, padx=5, pady=5, sticky='e')
        self.app_key_entry = ttk.Entry(self.api_frame)
        self.app_key_entry.grid(row=1, column=1, padx=5, pady=5, sticky='ew')
        self.app_key_entry.locked = False  # 初始状态未锁定

        self.app_key_entry.bind('<FocusOut>', lambda e: self.update_api_config())

        # 按钮框架（保存和解锁按钮）
        self.api_button_frame = ttk.Frame(self.api_frame)
        self.api_button_frame.grid(row=2, column=0, columnspan=5, pady=5, sticky='e')

        # 保存API配置按钮
        self.save_api_btn = ttk.Button(self.api_button_frame, text="保存API配置", command=self.save_api_config)
        self.save_api_btn.pack(side="right", padx=5)

        # 解锁按钮，绑定到 unlock_entry 方法
        self.unlock_api_btn = ttk.Button(
            self.api_button_frame,
            text="解锁输入框",
            command=lambda: self.unlock_all_entries([self.app_id_entry, self.app_key_entry])
        )
        self.unlock_api_btn.pack(side="right", padx=5)

        # 路径选择
        self.path_frame = ttk.LabelFrame(self.window, text="路径设置")
        self.path_frame.pack(fill="x", padx=10, pady=5)

        ttk.Label(self.path_frame, text="音频文件夹:").grid(row=0, column=0, padx=5, pady=5)
        self.audio_path_var = tk.StringVar()
        self.audio_path_entry = ttk.Entry(self.path_frame, textvariable=self.audio_path_var)
        self.audio_path_entry.grid(row=0, column=1, padx=5, pady=5)
        ttk.Button(self.path_frame, text="选择", command=self.select_audio_path).grid(row=0, column=2, padx=5, pady=5)

        ttk.Label(self.path_frame, text="输出文件夹:").grid(row=1, column=0, padx=5, pady=5)
        self.output_path_var = tk.StringVar()
        self.output_path_entry = ttk.Entry(self.path_frame, textvariable=self.output_path_var)
        self.output_path_entry.grid(row=1, column=1, padx=5, pady=5)
        ttk.Button(self.path_frame, text="选择", command=self.select_output_path).grid(row=1, column=2, padx=5, pady=5)

        # 进度显示
        self.progress_frame = ttk.LabelFrame(self.window, text="生成进度")
        self.progress_frame.pack(fill="both", expand=True, padx=10, pady=5)

        self.progress_text = tk.Text(self.progress_frame, height=10)
        self.progress_text.pack(fill="both", expand=True, padx=5, pady=5)

        self.progress_bar = ttk.Progressbar(self.progress_frame, mode='determinate')
        self.progress_bar.pack(fill="x", padx=5, pady=5)

        # 控制按钮
        self.button_frame = ttk.Frame(self.window)
        self.button_frame.pack(fill="x", padx=10, pady=5)

        self.generate_btn = ttk.Button(self.button_frame, text="开始生成", command=self.start_generate)
        self.generate_btn.pack(side="right", padx=5)

        self.stop_btn = ttk.Button(self.button_frame, text="停止生成", command=self.stop_generate, state='disabled')
        self.stop_btn.pack(side="right", padx=5)

        self.load_api_config()
        self.generator = WhisperSubtitleGenerator()
        # 如果有状态更新回调方法，设置它
        self.generator.set_callbacks(
            progress_callback=self.update_progress_bar,
            status_callback=self.update_progress_text
        )

        self.create_context_menus()
        self.bind_shortcuts()

        self.window.protocol("WM_DELETE_WINDOW", self.on_closing)
        self.is_generating = False

    def update_theme(self, event=None):
        """更新主题"""
        # 重新加载颜色
        self.theme_manager.colors = self.theme_manager.load_colors()

        # 重新应用主题
        self.theme_manager.apply_theme_to_window(self.window)

        # 更新ttk样式
        style = ttk.Style()
        self.theme_manager.apply_theme_to_ttk_styles(style)

    def create_context_menus(self):
        """为所有输入框创建右键菜单"""
        entries = [
            self.app_id_entry,
            self.app_key_entry,
            self.audio_path_entry,  # 使用 entry
            self.output_path_entry  # 使用 entry
        ]

        for entry in entries:
            if isinstance(entry, (tk.Entry, ttk.Entry)):
                menu = tk.Menu(self.window, tearoff=0)
                menu.add_command(label="剪切", command=lambda e=entry: self.cut_text(e))
                menu.add_command(label="复制", command=lambda e=entry: self.copy_text(e))
                menu.add_command(label="粘贴", command=lambda e=entry: self.paste_text(e))
                menu.add_separator()
                menu.add_command(label="全选", command=lambda e=entry: self.select_all(e))

                entry.bind("<Button-3>", lambda e, m=menu: self.show_context_menu(e, m))
            else:
                self.logger.warning(f"尝试创建上下文菜单到非Entry对象: {entry}")

    def bind_shortcuts(self):
        """绑定快捷键"""
        entries = [
            self.app_id_entry,
            self.app_key_entry,
            self.audio_path_entry,
            self.output_path_entry
        ]

        for entry in entries:
            if isinstance(entry, (tk.Entry, ttk.Entry)):
                # 检查焦点
                def focus_check(widget, callback):
                    if widget == widget.winfo_toplevel().focus_get():
                        callback(widget)

                # Windows/Linux 快捷键
                entry.bind('<Control-a>', lambda e: focus_check(e.widget, self.select_all))
                entry.bind('<Control-A>', lambda e: focus_check(e.widget, self.select_all))
                entry.bind('<Control-c>', lambda e: focus_check(e.widget, self.copy_text))
                entry.bind('<Control-C>', lambda e: focus_check(e.widget, self.copy_text))
                entry.bind('<Control-v>', lambda e: focus_check(e.widget, self.paste_text))
                entry.bind('<Control-V>', lambda e: focus_check(e.widget, self.paste_text))
                entry.bind('<Control-x>', lambda e: focus_check(e.widget, self.cut_text))
                entry.bind('<Control-X>', lambda e: focus_check(e.widget, self.cut_text))

                # Mac 快捷键
                entry.bind('<Command-a>', lambda e: focus_check(e.widget, self.select_all))
                entry.bind('<Command-A>', lambda e: focus_check(e.widget, self.select_all))
                entry.bind('<Command-c>', lambda e: focus_check(e.widget, self.copy_text))
                entry.bind('<Command-C>', lambda e: focus_check(e.widget, self.copy_text))
                entry.bind('<Command-v>', lambda e: focus_check(e.widget, self.paste_text))
                entry.bind('<Command-V>', lambda e: focus_check(e.widget, self.paste_text))
                entry.bind('<Command-x>', lambda e: focus_check(e.widget, self.cut_text))
                entry.bind('<Command-X>', lambda e: focus_check(e.widget, self.cut_text))
            else:
                self.logger.warning(f"尝试绑定快捷键到非Entry对象: {entry}")

    def show_context_menu(self, event, menu):
        """显示右键菜单"""
        try:
            menu.tk_popup(event.x_root, event.y_root)
        finally:
            menu.grab_release()

    def cut_text(self, entry):
        """剪切文本"""
        try:
            entry.event_generate("<<Cut>>")
        except Exception as e:
            self.logger.error(f"剪切操作失败: {str(e)}")
            messagebox.showerror("错误", f"剪切操作失败: {str(e)}")

    def copy_text(self, entry):
        """复制文本"""
        try:
            entry.event_generate("<<Copy>>")
        except Exception as e:
            self.logger.error(f"复制操作失败: {str(e)}")
            messagebox.showerror("错误", f"复制操作失败: {str(e)}")

    def paste_text(self, entry):
        """粘贴文本，包含防抖机制和锁定提示"""
        try:
            # 防抖机制：检查最近一次粘贴时间
            current_time = time.time()
            if hasattr(entry, 'last_paste_time'):
                if current_time - entry.last_paste_time < 0.5:  # 0.5秒内禁止重复粘贴
                    self.logger.warning(f"粘贴操作过于频繁，忽略本次操作: {entry.winfo_name()}")
                    self.update_progress_text(f"粘贴操作过于频繁，忽略本次操作: {entry.winfo_name()}")
                    return
            entry.last_paste_time = current_time

            # 清空当前选中的文本
            try:
                start, end = entry.selection_range()
                if start != end:
                    entry.delete(start, end)
            except:
                pass

            # 获取剪贴板内容并清理不可见字符
            clipboard_content = entry.clipboard_get().strip()
            clipboard_content = re.sub(r'[\x00-\x1F\x7F-\x9F]', '', clipboard_content)

            # 打印粘贴前的值进行调试
            self.logger.debug(f"粘贴前的 entry 值: {repr(entry.get())}, 长度: {len(entry.get())}")
            self.logger.debug(f"粘贴的 clipboard 内容: {repr(clipboard_content)}, 长度: {len(clipboard_content)}")

            # 清空输入框内容，确保新内容替换旧内容
            entry.delete(0, 'end')

            # 执行粘贴操作
            entry.insert(0, clipboard_content)

            # 打印粘贴后的值进行调试
            self.logger.debug(f"粘贴后的 entry 值: {repr(entry.get())}, 长度: {len(entry.get())}")

            # 锁定输入框内容，防止意外修改
            entry.config(state='readonly')
            entry.locked = True  # 添加标志位

            # 更新进度文本，记录粘贴操作
            self.update_progress_text(f"已粘贴到输入框: {entry.winfo_name()}")

            # 弹出提示框，告知用户输入框已锁定
            messagebox.showinfo(
                "提示",
                f"输入框 {entry.winfo_name()} 已锁定，防止意外修改。\n点击'解锁'按钮可重新编辑。"
            )

        except tk.TclError as e:
            self.logger.error(f"粘贴操作失败: 剪贴板为空或不可访问 - {str(e)}")
            messagebox.showerror("错误", "粘贴失败: 剪贴板为空或不可访问")
            self.update_progress_text(f"粘贴失败: 剪贴板为空或不可访问 - {str(e)}")
        except Exception as e:
            self.logger.error(f"粘贴操作失败: {str(e)}")
            messagebox.showerror("错误", f"粘贴操作失败: {str(e)}")
            self.update_progress_text(f"粘贴失败: {str(e)}")

    def select_all(self, entry):
        """全选文本"""
        try:
            entry.select_range(0, 'end')
            entry.icursor('end')  # 将光标移到末尾
        except Exception as e:
            self.logger.error(f"全选操作失败: {str(e)}")
            messagebox.showerror("错误", f"全选操作失败: {str(e)}")

    def update_progress_text(self, message):
        """线程安全的更新进度文本"""
        timestamp = time.strftime("%H:%M:%S")

        # 检查多种可能的窗口引用名称
        root_widget = self.get_root_widget()

        if root_widget:
            # 在主线程中更新UI
            root_widget.after(0, lambda msg=message, ts=timestamp: self._do_update_progress_text(ts, msg))
        else:
            # 如果没有找到根窗口引用，只能打印到控制台
            print(f"[{timestamp}] {message}")

    def _do_update_progress_text(self, timestamp, message):
        """实际执行文本更新的方法，在主线程中调用"""
        try:
            self.progress_text.insert('end', f"[{timestamp}] {message}\n")
            self.progress_text.see('end')  # 滚动到底部
        except Exception as e:
            print(f"更新进度文本失败: {e}")

    def get_root_widget(self):
        """获取可用的根窗口引用"""
        for attr in ['master', 'window', 'parent', 'top', 'tk']:
            if hasattr(self, attr):
                return getattr(self, attr)
        return None

    def update_progress_bar(self, current, total):
        """线程安全的更新进度条"""
        root_widget = self.get_root_widget()
        if root_widget:
            root_widget.after(0, lambda c=current, t=total: self._do_update_progress_bar(c, t))

    def _do_update_progress_bar(self, current, total):
        """在主线程中实际执行进度条更新"""
        try:
            self.progress_bar['value'] = current
            percentage = (current / total) * 100 if total > 0 else 0
            self.progress_bar.update()
        except Exception as e:
            print(f"更新进度条失败: {e}")

    def on_closing(self):
        """处理窗口关闭"""
        if self.is_generating:
            if not messagebox.askyesno("确认", "正在生成字幕，确定要退出吗？"):
                return
        self.window.destroy()

    def clear_progress(self):
        """清除进度信息"""
        if messagebox.askyesno("确认", "确定要清除进度信息吗？"):
            self.progress_text.delete(1.0, 'end')
            self.progress_bar['value'] = 0

    def load_api_config(self):
        """加载API配置时添加确认覆盖功能，并清理不可见字符"""
        config_file = os.path.join(os.path.expanduser('~'), '.audio_player', 'baidu_api_config.json')
        try:
            if os.path.exists(config_file):
                with open(config_file, 'r', encoding='utf-8') as f:
                    config = json.load(f)

                # 获取配置中的 app_id 和 app_key，并清理不可见字符
                app_id = config.get('app_id', '').strip()
                app_key = config.get('app_key', '').strip()

                # 清理所有不可见字符，包括换行符、制表符、不可打印字符等
                app_id = re.sub(r'[\x00-\x1F\x7F-\x9F]', '', app_id)
                app_key = re.sub(r'[\x00-\x1F\x7F-\x9F]', '', app_key)

                # 存储原始值
                self.original_app_id = app_id
                self.original_app_key = app_key

                # 打印日志时显示完整值（保持不变）
                print('加载的 app_id:', repr(app_id), f'长度: {len(app_id)}')
                print('加载的 app_key:', repr(app_key), f'长度: {len(app_key)}')

                # 如果输入框中已有内容，询问是否覆盖
                current_app_id = self.app_id_entry.get().strip()
                current_app_key = self.app_key_entry.get().strip()
                if current_app_id or current_app_key:
                    if not messagebox.askyesno("确认覆盖", "输入框中已有API配置，是否用保存的配置覆盖？"):
                        self.update_progress_text("已取消覆盖API配置")
                        return

                # 创建用于前端显示的隐藏版本
                def mask_sensitive(text):
                    if len(text) <= 6:  # 如果长度小于等于6，不隐藏
                        return text
                    return f"{text[:3]}{'*' * (len(text) - 6)}{text[-3:]}"

                display_app_id = mask_sensitive(app_id)
                display_app_key = mask_sensitive(app_key)

                # 清空现有内容
                self.app_id_entry.delete(0, 'end')
                self.app_key_entry.delete(0, 'end')

                # 插入隐藏后的值用于前端显示
                self.app_id_entry.insert(0, display_app_id)
                self.app_key_entry.insert(0, display_app_key)

                # 打印插入后的值（显示实际插入的隐藏值）
                print('插入后的 app_id:', repr(self.app_id_entry.get()), f'长度: {len(self.app_id_entry.get())}')
                print('插入后的 app_key:', repr(self.app_key_entry.get()), f'长度: {len(self.app_key_entry.get())}')

                self.update_progress_text("API配置已加载")
            else:
                # 如果没有配置文件，也初始化原始值为空
                self.original_app_id = ''
                self.original_app_key = ''
                self.update_progress_text("未找到API配置文件，使用空配置")
        except json.JSONDecodeError as e:
            self.original_app_id = ''
            self.original_app_key = ''
            messagebox.showerror("错误", f"API配置文件格式错误: {str(e)}")
            self.update_progress_text(f"加载API配置失败: 配置文件格式错误")
        except Exception as e:
            self.original_app_id = ''
            self.original_app_key = ''
            messagebox.showerror("错误", f"加载API配置失败: {str(e)}")
            self.update_progress_text(f"加载API配置失败: {str(e)}")

    # 添加保存配置的方法
    def save_api_config(self):
        """保存API配置，始终使用原始值"""
        config_file = os.path.join(os.path.expanduser('~'), '.audio_player', 'baidu_api_config.json')
        try:
            # 确保配置目录存在
            os.makedirs(os.path.dirname(config_file), exist_ok=True)

            # 获取输入框中的值，仅用于检查是否需要更新
            display_app_id = self.app_id_entry.get().strip()
            display_app_key = self.app_key_entry.get().strip()

            # 检查输入框中的值是否是隐藏格式（包含***）
            def is_masked(text):
                return '***' in text

            # 如果输入框中的值不是隐藏格式，更新原始值
            if not is_masked(display_app_id):
                self.original_app_id = display_app_id
                self.logger.info(f"保存前更新 APP ID: {repr(self.original_app_id)}")

            if not is_masked(display_app_key):
                self.original_app_key = display_app_key
                self.logger.info(f"保存前更新 API Key: {repr(self.original_app_key)}")

            # 检查原始值是否为空
            if not self.original_app_id or not self.original_app_key:
                self.logger.error("保存API配置失败: APP ID 或 API Key 不能为空")
                messagebox.showerror("错误", "APP ID 和 API Key 不能为空")
                self.update_progress_text("保存API配置失败: APP ID 和 API Key 不能为空")
                return

            # 打印要保存的原始值进行调试
            self.logger.info(f"保存的 app_id: {repr(self.original_app_id)}")
            self.logger.info(f"保存的 app_key: {repr(self.original_app_key)}")
            print(f"保存的 app_id: {repr(self.original_app_id)}")
            print(f"保存的 app_key: {repr(self.original_app_key)}")

            # 保存配置，使用原始值
            config = {
                'app_id': self.original_app_id,
                'app_key': self.original_app_key
            }

            with open(config_file, 'w', encoding='utf-8') as f:
                json.dump(config, f, ensure_ascii=False, indent=2)

            # 更新输入框显示为隐藏格式
            def mask_sensitive(text):
                if len(text) <= 6:
                    return text
                return f"{text[:3]}{'*' * (len(text) - 6)}{text[-3:]}"

            self.app_id_entry.delete(0, 'end')
            self.app_id_entry.insert(0, mask_sensitive(self.original_app_id))
            self.app_key_entry.delete(0, 'end')
            self.app_key_entry.insert(0, mask_sensitive(self.original_app_key))

            self.logger.info("API配置保存成功，输入框已更新为隐藏格式")
            self.update_progress_text("API配置已保存")
        except Exception as e:
            self.logger.error(f"保存API配置失败: {str(e)}")
            messagebox.showerror("错误", f"保存API配置失败: {str(e)}")
            self.update_progress_text(f"保存API配置失败: {str(e)}")

    def unlock_entry(self, entry, show_message=False):  # 默认不显示消息
        """解锁指定的输入框，恢复可编辑状态"""
        try:
            if hasattr(entry, 'locked') and entry.locked:
                entry.config(state='normal')
                entry.locked = False
                self.update_progress_text(f"输入框 {entry.winfo_name()} 已解锁")
                self.logger.info(f"输入框 {entry.winfo_name()} 已解锁")
                if show_message:
                    messagebox.showinfo("提示", f"输入框 {entry.winfo_name()} 已解锁，您现在可以编辑内容。")
            else:
                # 只记录日志，不显示消息框
                self.update_progress_text(f"输入框 {entry.winfo_name()} 未锁定，无需解锁")
                self.logger.info(f"输入框 {entry.winfo_name()} 未锁定，无需解锁")
                # 仅当明确要求显示消息时才显示
                if show_message:
                    messagebox.showinfo("提示", f"输入框 {entry.winfo_name()} 未锁定，无需解锁。")
        except Exception as e:
            self.logger.error(f"解锁输入框失败: {str(e)}")
            self.update_progress_text(f"解锁输入框失败: {str(e)}")
            if show_message:
                messagebox.showerror("错误", f"解锁输入框失败: {str(e)}")

    def unlock_all_entries(self, entries, show_message=False):
        """解锁所有指定的输入框"""
        locked_count = 0
        for entry in entries:
            # 不为单个输入框显示消息
            if hasattr(entry, 'locked') and entry.locked:
                locked_count += 1
            self.unlock_entry(entry, show_message=False)

        # 只在有锁定的输入框且要求显示消息时显示一条总结消息
        if show_message and locked_count > 0:
            messagebox.showinfo("提示", f"{locked_count}个输入框已解锁，您现在可以编辑内容。")

    def select_audio_path(self):
        path = filedialog.askdirectory(title="选择音频文件夹")
        if path:
            if os.access(path, os.R_OK):
                self.audio_path_var.set(path)
                self.update_progress_text(f"已选择音频文件夹: {path}")
            if not self.output_path_var.get():
                # self.output_path_var.set(os.path.join(path, "字幕文件"))
                self.output_path_var.set(path)

    def select_output_path(self):
        path = filedialog.askdirectory(title="选择输出文件夹")
        if path:
            self.output_path_var.set(path)

    def is_filename_normalized(self, filename):
        """检查文件名是否规范（不包含全角字符或非法字符）"""
        # 将文件名规范化后与原文件名比较
        normalized = normalize_filename(filename)  # 使用独立的 normalize_filename 函数
        return filename == normalized

    def check_and_normalize_filenames(self, audio_files):
        """检查音频文件列表中的文件名是否规范，若不规范，询问用户是否一键修改"""
        unnormalized_files = []
        for audio_file in audio_files:
            filename = os.path.basename(audio_file)
            if not self.is_filename_normalized(filename):
                unnormalized_files.append(audio_file)

        if unnormalized_files:
            message = (
                    f"检测到以下 {len(unnormalized_files)} 个文件名的格式不规范（包含全角字符或非法字符）:\n\n"
                    + "\n".join([os.path.basename(f) for f in unnormalized_files[:10]])
                    + ("\n..." if len(unnormalized_files) > 10 else "")
                    + "\n\n是否一键修改文件名（将全角字符规范化为半角字符，并移除非法字符）？"
            )
            if messagebox.askyesno("文件名规范化", message):
                new_audio_files = []
                for audio_file in audio_files:
                    filename = os.path.basename(audio_file)
                    if not self.is_filename_normalized(filename):
                        new_filename = normalize_filename(filename)
                        new_audio_file = os.path.join(os.path.dirname(audio_file), new_filename)
                        try:
                            if audio_file != new_audio_file:  # 只有当文件名发生变化时才重命名
                                os.rename(audio_file, new_audio_file)
                                self.update_progress_text(f"已重命名: {filename} -> {new_filename}")
                                self.logger.info(f"已重命名: {audio_file} -> {new_audio_file}")
                            new_audio_files.append(new_audio_file)
                        except Exception as e:
                            self.update_progress_text(f"重命名失败: {filename} - 错误: {str(e)}")
                            self.logger.error(f"重命名失败: {audio_file} - 错误: {str(e)}")
                            new_audio_files.append(audio_file)  # 如果重命名失败，保留原文件
                    else:
                        new_audio_files.append(audio_file)
                return new_audio_files
        return audio_files

    @safe_call
    def start_generate(self):
        # 验证API配置前先确保已重置状态
        if hasattr(self, 'generator') and self.generator:
            self.generator.reset_stop_flag()

        # 验证API配置
        if not self.validate_api_config():
            self.is_generating = False  # 如果验证失败，恢复状态
            return

        # 验证输入
        audio_path = self.audio_path_entry.get().strip()
        if not audio_path:
            messagebox.showerror("错误", "请选择音频文件夹")
            return

        output_path = self.output_path_entry.get().strip()
        if not output_path:
            messagebox.showerror("错误", "请选择输出文件夹")
            return

        if self.is_generating:
            messagebox.showwarning("警告", "正在处理中，请等待当前任务完成")
            return

        self.is_generating = True
        self.generate_btn.config(state='disabled')
        self.stop_btn.config(state='normal')  # 确保启用停止按钮

        # 自动解锁
        self.unlock_all_entries([self.app_id_entry, self.app_key_entry], show_message=False)

        # 保存API配置_取消，由按钮保存
        # self.save_api_config()

        # 创建输出文件夹
        os.makedirs(output_path, exist_ok=True)

        # 获取所有音频文件
        audio_files = []
        for root, _, files in os.walk(audio_path):
            for file in files:
                if file.lower().endswith(('.mp3', '.wav')):
                    audio_files.append(os.path.join(root, file))

        if not audio_files:
            messagebox.showerror("错误", "未找到音频文件")

        # 检查并规范化文件名
        audio_files = self.check_and_normalize_filenames(audio_files)

        # 更新进度条配置
        self.progress_bar['maximum'] = len(audio_files)
        self.progress_bar['value'] = 0

        def process_files():
            try:
                total_files = len(audio_files)
                success_count = 0

                # 强制恢复应用状态的函数 - 这个函数缺失了
                def restore_app_state():
                    """恢复应用状态到初始状态"""
                    self.is_generating = False
                    root_widget = self.get_root_widget()
                    if root_widget:
                        root_widget.after(0, lambda: self.generate_btn.config(state='normal'))
                        root_widget.after(0, lambda: self.stop_btn.config(state='disabled'))

                # 获取根窗口引用
                root_widget = self.get_root_widget()

                # 初始化进度条
                def init_progress():
                    try:
                        self.progress_bar['maximum'] = total_files
                        self.progress_bar['value'] = 0
                    except Exception as e:
                        print(f"初始化进度条失败: {e}")

                if root_widget:
                    root_widget.after(0, init_progress)

                for i, audio_file in enumerate(audio_files, 1):
                    # 主动检查是否应该停止
                    if not self.is_generating:
                        self.update_progress_text("处理已中断")
                        break
                    try:
                        output_file = os.path.join(
                            output_path,
                            os.path.splitext(os.path.basename(audio_file))[0] + '.srt'
                        )

                        self.update_progress_text(f"处理文件 ({i}/{total_files}): {os.path.basename(audio_file)}")

                        # 打印原始和规范化路径，方便调试
                        original_audio_path = Path(audio_file)
                        normalized_audio_path = normalize_filename(original_audio_path)
                        original_output_path = Path(output_file)
                        normalized_output_path = normalize_filename(original_output_path)

                        print(f"原始音频路径: {original_audio_path}")
                        print(f"规范化音频路径: {normalized_audio_path}")
                        print(f"原始字幕路径: {original_output_path}")
                        print(f"规范化字幕路径: {normalized_output_path}")

                        # 生成字幕（使用规范化后的路径访问文件，使用原始路径保存文件）
                        # 重置停止标志
                        if hasattr(self, 'generator'):
                            self.generator.reset_stop_flag()

                        # 生成字幕
                        result = self.generator.generate_srt(
                            audio_path=audio_file,
                            output_path=output_file
                        )

                        # 检查结果，如果返回False则可能是被取消
                        if not result:
                            if hasattr(self, 'generator') and self.generator.should_stop:
                                self.update_progress_text("处理已被用户取消")
                                restore_app_state()
                                return

                        success_count += 1
                        self.update_progress_bar(i, total_files)
                        self.update_progress_text(f"成功生成字幕: {os.path.basename(output_file)}")

                    except Exception as e:
                        # 如果处理中被取消，则更优雅地处理异常
                        if not self.is_generating or (hasattr(self, 'generator') and self.generator.should_stop):
                            self.update_progress_text("处理已中断")
                            restore_app_state()
                            return
                        self.update_progress_text(f"处理文件失败: {os.path.basename(audio_file)} - 错误: {str(e)}")
                        self.logger.error(f"处理文件 {audio_file} 失败: {str(e)}")
                        continue

                # 更新最终状态
                self.update_progress_text(f"处理完成: 成功 {success_count}/{total_files} 个文件")

                # 在主线程中显示消息框
                if root_widget:
                    root_widget.after(0, lambda: messagebox.showinfo("完成", "字幕生成任务已完成"))

            except Exception as e:
                self.update_progress_text(f"处理过程中发生错误: {str(e)}")
                self.logger.error(f"生成字幕过程中发生错误: {str(e)}")
                messagebox.showerror("错误", "字幕生成失败，请查看日志")
            finally:
                # 恢复状态
                self.is_generating = False

                # 恢复按钮状态到主线程
                def restore_buttons():
                    try:
                        if hasattr(self, 'generate_btn'):
                            self.generate_btn.config(state='normal')
                        if hasattr(self, 'stop_btn'):
                            self.stop_btn.config(state='disabled')
                    except Exception as e:
                        print(f"恢复按钮状态失败: {e}")

                root_widget = self.get_root_widget()
                if root_widget:
                    root_widget.after(0, restore_buttons)
        threading.Thread(target=process_files, daemon=True).start()

    def validate_api_config(self):
        """验证API配置是否有效"""
        # 使用原始值进行验证
        app_id = self.original_app_id
        app_key = self.original_app_key

        # 检查原始值是否为空
        if not app_id or not app_key:
            self.logger.error("API配置验证失败: APP ID 或 API Key 为空")
            messagebox.showerror("错误", "APP ID 和 API Key 不能为空")
            self.update_progress_text("API配置验证失败: APP ID 和 API Key 不能为空")
            return False

        try:
            # 打印用于验证的原始值，方便调试
            self.logger.info(f"开始验证API配置 - app_id: {repr(app_id)}, app_key: {repr(app_key)}")
            print(f"验证时使用的 app_id: {repr(app_id)}")
            print(f"验证时使用的 app_key: {repr(app_key)}")

            # 设置API配置到generator
            self.generator.set_api_config(app_id, app_key)

            # 进行测试翻译
            test_text = "Hello"
            self.logger.info(f"执行测试翻译，测试文本: {test_text}")
            result = self.generator.test_translation(test_text)

            if result:
                self.logger.info("API配置验证成功")
                self.update_progress_text("API配置验证成功")
                return True
            else:
                self.logger.error("API配置验证失败: 测试翻译返回空结果")
                messagebox.showerror("错误", "API配置无效，请检查APP ID和API Key")
                self.update_progress_text("API配置验证失败: 测试翻译返回空结果")
                return False

        except Exception as e:
            # 捕获并记录详细的错误信息
            error_msg = f"API配置验证失败: {str(e)}"
            self.logger.error(error_msg)
            print(error_msg)
            messagebox.showerror("错误", error_msg)
            self.update_progress_text(error_msg)
            return False

    # 如果用户手动修改了输入框，需要更新原始值
    def update_api_config(self):
        """更新API配置，当用户修改输入框内容时"""
        display_app_id = self.app_id_entry.get().strip()
        display_app_key = self.app_key_entry.get().strip()

        # 检查输入框中的值是否是隐藏格式（包含***）
        def is_masked(text):
            return '***' in text

        # 如果两个输入框都是隐藏格式，保持原始值不变
        if is_masked(display_app_id) and is_masked(display_app_key):
            self.logger.info("API配置未更改（输入框值为隐藏格式，保持原始值）")
            self.update_progress_text("API配置未更改（使用原始值）")
            return

        # 检查并更新 APP ID
        if not is_masked(display_app_id):
            self.original_app_id = display_app_id
            self.logger.info(f"更新 APP ID: {repr(self.original_app_id)}")

        # 检查并更新 API Key
        if not is_masked(display_app_key):
            self.original_app_key = display_app_key
            self.logger.info(f"更新 API Key: {repr(self.original_app_key)}")

        self.update_progress_text("API配置已更新")
        self.logger.info(f"当前原始值 - app_id: {repr(self.original_app_id)}, app_key: {repr(self.original_app_key)}")

    def test_translation(self, text):
        """测试翻译API配置是否有效"""
        try:
            # 生成签名
            salt = str(random.randint(32768, 65536))
            sign = self.app_id + text + salt + self.app_key
            sign = hashlib.md5(sign.encode()).hexdigest()

            # 构建请求
            headers = {'Content-Type': 'application/x-www-form-urlencoded'}
            payload = {
                'q': text,
                'from': 'en',
                'to': 'zh',
                'appid': self.app_id,
                'salt': salt,
                'sign': sign
            }

            # 发送请求
            response = requests.post(self.api_url, headers=headers, data=payload)
            result = response.json()

            # 检查响应
            if 'trans_result' in result:
                return True
            else:
                return False

        except Exception as e:
            self.logger.error(f"测试翻译API失败: {e}")
            return False

    @safe_call
    def stop_generate(self):
        """停止生成字幕"""
        self.is_generating = False
        self.generate_btn.config(state='normal')
        self.stop_btn.config(state='disabled')

        # 确保使用正确的变量名
        if hasattr(self, 'generator') and self.generator:
            self.generator.stop_processing()
            self.update_progress_text("正在停止字幕生成...")

            # 不要在这里重置生成器的停止标志
            # 停止标志应该在下一次start_generate调用时重置
        else:
            self.update_progress_text("已停止生成字幕")


class WhisperFollowReading:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = super(WhisperFollowReading, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance

    def __init__(self, model_size="tiny", api_type="whisper"):
        # 初始化日志记录器
        self.logger = get_logger('WhisperFollowReading')
        self.logger.info("初始化 WhisperFollowReading")

        self._lock = threading.Lock()  # 初始化全局锁
        self._file_locks = {}  # 初始化文件锁字典

        # 设置API类型
        self.api_type = api_type  # 可选值: "whisper", "baidu", "tencent"

        # 优先从项目目录加载模型
        if api_type == "whisper":
            self.whisper_model = self.load_whisper_model(model_size)
        else:
            self.whisper_model = None  # 使用API时不需要whisper模型

        # API配置参数
        self.api_config = {
            "baidu": {
                "app_id": "",
                "api_key": "",
                "secret_key": ""
            },
            "tencent": {
                "secret_id": "",
                "secret_key": ""
            }
        }
        self.is_recording = False
        self.recording_thread = None
        self._stop_recognition = False  # 停止标志

        self.frames = []
        self.sample_rate = 44100

        # 创建临时文件目录
        self.temp_dir = os.path.join(os.path.expanduser('~'), '.audio_player', 'temp')
        if not os.path.exists(self.temp_dir):
            os.makedirs(self.temp_dir)

        # 使用临时目录中的固定文件名
        self.playback_file = os.path.join(self.temp_dir, "temp_playback.wav")
        self.transcribe_file = os.path.join(self.temp_dir, "temp_transcribe.wav")

        self.audio_queue = []
        self.last_audio_time = 0
        self.min_wait_time = 5
        self.silence_threshold = 3  # 允许的静音间隔
        self.recognition_queue = []
        self.is_processing = False
        self._initialized = True

    def load_whisper_model(self, model_size):
        """优先从项目目录加载Whisper模型，若不存在则从默认位置下载"""
        try:
            # 使用 get_resource_path 获取模型路径
            model_file = f"{model_size}.pt"
            model_path = get_resource_path(os.path.join("models", model_file))
            self.logger.info(f"尝试加载模型: {model_path}")

            if os.path.exists(model_path):
                self.logger.info(f"从项目目录加载 {model_size} 模型")
                return whisper.load_model(model_size, download_root=os.path.dirname(model_path))
            else:
                # 使用默认位置
                self.logger.info(f"从默认位置加载 {model_size} 模型")
                return whisper.load_model(model_size)
        except Exception as e:
            self.logger.error(f"加载Whisper模型失败: {str(e)}")
            messagebox.showerror("模型加载错误", f"加载语音识别模型失败: {str(e)}\n请确保网络连接正常或模型文件完整。")
            return None

    def check_whisper_model_files(self, models_dir, model_size):
        """检查指定目录中是否存在完整的模型文件"""
        # Whisper模型通常保存为.pt文件
        expected_model_path = os.path.join(models_dir, f"{model_size}.pt")

        # 检查文件是否存在且大小合理
        if os.path.exists(expected_model_path):
            file_size = os.path.getsize(expected_model_path)
            # 基本大小检查 (不同模型大小不同，这里只是一个简单检查)
            min_sizes = {
                "tiny": 10 * 1024 * 1024,  # 至少10MB
                "base": 50 * 1024 * 1024,  # 至少50MB
                "small": 200 * 1024 * 1024,  # 至少200MB
                "medium": 500 * 1024 * 1024,  # 至少500MB
                "large": 1000 * 1024 * 1024  # 至少1GB
            }

            min_size = min_sizes.get(model_size, 1 * 1024 * 1024)  # 默认至少1MB

            if file_size > min_size:
                self.logger.info(f"找到本地{model_size}模型文件: {expected_model_path}, 大小: {file_size / 1024 / 1024:.1f}MB")
                return True
            else:
                self.logger.warning(f"本地模型文件大小异常: {file_size / 1024 / 1024:.1f}MB，将使用默认下载")
                return False
        else:
            self.logger.info(f"本地目录未找到{model_size}模型文件，将使用默认下载")
            return False

    def set_api_config(self, api_type, config):
        """设置API配置"""
        if api_type in self.api_config:
            self.api_config[api_type].update(config)
            self.api_type = api_type
            return True
        return False

    def _recognize_with_whisper(self, audio_file):
        """使用Whisper本地模型进行识别"""
        try:
            # 使用 Whisper 进行识别
            result = self.whisper_model.transcribe(
                audio_file,
                task="translate",
                language="en",
                beam_size=1,
                word_timestamps=False
            )

            return {
                'en_text': result.get("text", "").strip(),
                'cn_text': result.get("translation", "").strip() if "translation" in result else "",
                'segments': result.get("segments", []),
                'confidence': result.get("confidence", 0)
            }
        except Exception as e:
            self.logger.error(f"Whisper识别错误: {e}")
            return None

    def _recognize_with_baidu(self, audio_file):
        """使用百度语音识别API"""
        try:
            from aip import AipSpeech  # pip install baidu-aip

            # 检查配置
            config = self.api_config["baidu"]
            if not all([config["app_id"], config["api_key"], config["secret_key"]]):
                self.logger.error("百度API配置不完整")
                return None

            # 初始化AipSpeech
            client = AipSpeech(config["app_id"], config["api_key"], config["secret_key"])

            # 读取音频文件
            with open(audio_file, 'rb') as fp:
                audio_data = fp.read()

            # 调用百度API识别英文
            result = client.asr(audio_data, 'wav', 16000, {'dev_pid': 1737})  # 1737是英文

            if result["err_no"] == 0:
                en_text = result["result"][0]

                # 调用百度翻译API (如果需要)
                cn_text = ""  # 这里可以添加翻译逻辑

                return {
                    'en_text': en_text,
                    'cn_text': cn_text,
                    'segments': [],
                    'confidence': 0.8  # 百度API没有返回置信度，使用默认值
                }
            else:
                self.logger.error(f"百度语音识别失败: {result['err_msg']}")
                return None

        except Exception as e:
            self.logger.error(f"百度API调用错误: {e}")
            return None

    def _recognize_with_tencent(self, audio_file):
        """使用腾讯语音识别API"""
        try:
            import base64
            import hmac
            from urllib.parse import urlencode
            from datetime import datetime

            # 检查配置
            config = self.api_config["tencent"]
            if not all([config["secret_id"], config["secret_key"]]):
                self.logger.error("腾讯API配置不完整")
                return None

            # 读取音频文件并转为base64
            with open(audio_file, 'rb') as fp:
                audio_data = base64.b64encode(fp.read()).decode('utf-8')

            # 准备请求参数
            host = "asr.tencentcloudapi.com"
            algorithm = "TC3-HMAC-SHA256"
            timestamp = int(datetime.utcnow().timestamp())
            date = datetime.utcnow().strftime('%Y-%m-%d')

            # 构建请求体
            request_data = {
                "ProjectId": 0,
                "SubServiceType": 2,  # 英文识别
                "EngSerViceType": "16k_en",
                "SourceType": 1,
                "Data": audio_data,
                "DataLen": len(audio_data),
            }

            # 签名逻辑
            http_request_method = "POST"
            canonical_uri = "/"
            canonical_querystring = ""
            ct = "application/json; charset=utf-8"
            payload = json.dumps(request_data)

            # 省略复杂的签名逻辑...
            # 实际实现中需要按照腾讯云API签名规则生成签名

            headers = {
                "Authorization": "签名结果",
                "Content-Type": ct,
                "Host": host,
                "X-TC-Action": "SentenceRecognition",
                "X-TC-Timestamp": str(timestamp),
                "X-TC-Version": "2019-06-14",
                "X-TC-Region": "ap-guangzhou",
            }

            # 发送请求
            url = f"https://{host}"
            response = requests.post(url, headers=headers, data=payload)
            result = response.json()

            if "Response" in result and "Result" in result["Response"]:
                en_text = result["Response"]["Result"]

                # 可以调用腾讯翻译API获取中文翻译
                cn_text = ""

                return {
                    'en_text': en_text,
                    'cn_text': cn_text,
                    'segments': [],
                    'confidence': 0.8  # 使用默认值
                }
            else:
                self.logger.error(f"腾讯语音识别失败: {result}")
                return None

        except Exception as e:
            self.logger.error(f"腾讯API调用错误: {e}")
            return None

    def recognize_speech(self, audio_file, callback=None, beam_size=10):
        """改进的语音识别功能"""
        print('准备识别录音0', audio_file)
        file_lock = None
        try:
            audio_file = os.path.normpath(audio_file)
            audio_file = str(Path(audio_file).resolve())

            with self._lock:
                if audio_file not in self._file_locks:
                    self._file_locks[audio_file] = threading.Lock()
                file_lock = self._file_locks[audio_file]

            with file_lock:
                if self._stop_recognition:
                    self.logger.info("语音识别已停止，不执行")
                    if callback:
                        callback('error', error="语音识别已停止")
                    return None

                if not os.path.exists(audio_file):
                    self.logger.error(f"音频文件不存在: {audio_file}")
                    if callback:
                        callback('error', error=f"音频文件不存在: {audio_file}")
                    return None

                try:
                    with open(audio_file, 'rb') as f:
                        pass
                except Exception as e:
                    self.logger.error(f"无法读取音频文件: {e}")
                    if callback:
                        callback('error', error=f"无法读取音频文件: {str(e)}")
                    return None

                file_size = os.path.getsize(audio_file)
                if file_size < 1024:
                    self.logger.warning(f"音频文件过小 ({file_size} 字节)，可能无效")
                    if callback:
                        callback('error', error=f"音频文件过小 ({file_size} 字节)")
                    return None

                self.logger.info(f"开始识别音频文件: {audio_file} (大小: {file_size} 字节)")

                import time
                start_time = time.time()
                result = self.whisper_model.transcribe(
                    audio_file,
                    task="transcribe",
                    language="en",
                    beam_size=beam_size,
                    word_timestamps=False,
                    fp16=False,
                    temperature=0.0,
                    condition_on_previous_text=False
                )
                end_time = time.time()
                self.logger.info(f"识别耗时: {end_time - start_time:.2f} 秒")

                if not result or not result.get("text"):
                    self.logger.error("语音识别返回空结果")
                    if callback:
                        callback('error', error="语音识别返回空结果")
                    return None

                recognition = {
                    'en_text': result.get("text", "").strip(),
                    'cn_text': result.get("translation", "").strip() if "translation" in result else "",
                    'segments': result.get("segments", []),
                    'confidence': result.get("confidence", 0)
                }
                self.logger.info(f"识别结果: {recognition}")
                if callback:
                    callback('success', recognition=recognition)
                return recognition

        except Exception as e:
            self.logger.error(f"语音识别错误: {e}", exc_info=True)
            if callback:
                callback('error', error=f"语音识别错误: {str(e)}")
            return None
        finally:
            if file_lock is not None:
                with self._lock:
                    if audio_file in self._file_locks:
                        del self._file_locks[audio_file]

    def _save_wave_file(self, file_path, frames):
        """改进的 WAV 文件保存功能"""
        wave_file = None
        try:
            wave_file = wave.open(file_path, "wb")
            wave_file.setnchannels(1)
            wave_file.setsampwidth(2)
            wave_file.setframerate(self.sample_rate)
            wave_file.writeframes(b''.join(frames))
        except Exception as e:
            self.logger.error(f"保存WAV文件失败: {e}")
            if os.path.exists(file_path):
                try:
                    os.remove(file_path)
                except:
                    pass
            raise
        finally:
            if wave_file is not None:
                try:
                    wave_file.close()
                except AttributeError:
                    # 若由于内部原因导致close出现AttributeError，则忽略该错误
                    pass
                except Exception as e:
                    self.logger.warning(f"关闭WAV文件时出现警告: {e}")

    def validate_audio_file(self, audio_file, min_duration=0.5):
        try:
            with wave.open(audio_file, 'rb') as wf:
                duration = wf.getnframes() / wf.getframerate()
                self.logger.info(f"音频文件时长: {duration} 秒")
                if duration < min_duration:
                    self.logger.warning(f"音频时长 {duration} 秒，低于最低要求 {min_duration} 秒")
                    return False
                return True
        except Exception as e:
            self.logger.error(f"音频文件验证失败: {e}")
            return False

    def save_audio_files(self):
        try:
            # 确保临时目录存在
            if not os.path.exists(self.temp_dir):
                os.makedirs(self.temp_dir, exist_ok=True)

            # 释放音频资源
            try:
                pygame.mixer.music.stop()
                pygame.mixer.music.unload()
                gc.collect()  # 强制垃圾回收
            except Exception as e:
                self.logger.warning(f"无法卸载音频: {e}")

            # 删除可能存在的旧文件
            for file in [self.playback_file, self.transcribe_file]:
                if os.path.exists(file):
                    self.logger.info(f"尝试删除旧文件: {file}")
                    is_in_use, proc_name = self.check_file_in_use(file)
                    if is_in_use:
                        self.logger.warning(f"文件被占用: {file}，占用进程: {proc_name}")
                        time.sleep(2)  # 等待更长时间
                        continue

                    for attempt in range(5):
                        try:
                            with open(file, 'a'):
                                pass  # 检查文件是否可写
                            os.remove(file)
                            self.logger.info(f"已删除旧文件: {file}")
                            break
                        except (IOError, OSError) as e:
                            self.logger.warning(f"删除旧文件失败 (尝试 {attempt + 1}/5): {e}")
                            time.sleep(2)  # 增加重试间隔
                        else:
                            self.logger.error(f"无法删除旧文件: {file}")
                            # 使用临时文件名
                            temp_dir = tempfile.gettempdir()
                            temp_file = os.path.join(temp_dir, os.path.basename(file))
                            self.logger.info(f"使用临时文件名: {temp_file}")
                            if file == self.playback_file:
                                self.playback_file = temp_file
                            else:
                                self.transcribe_file = temp_file

            if not self.frames:
                self.logger.warning("没有录音数据")
                return None, None

            # 检查录音数据是否有效（例如是否全是静音）
            frame_data = b''.join(self.frames)
            if not any(frame_data):
                self.logger.warning("录音数据全是静音，可能未正确录音")
                return None, None

            # 检查采样率是否符合要求（例如 Whisper 要求 16kHz）
            required_sample_rate = 16000
            if self.sample_rate != required_sample_rate:
                self.logger.warning(f"当前采样率 {self.sample_rate} Hz 不符合要求 {required_sample_rate} Hz，将进行转换")

            # 保存用于播放的音频
            try:
                self._save_wave_file(self.playback_file, self.frames)
                if not os.path.exists(self.playback_file):
                    self.logger.error(f"播放文件保存失败: {self.playback_file}")
                    return None, None
            except Exception as e:
                self.logger.error(f"保存播放音频失败: {e}")
                return None, None

            # 保存用于转写的音频
            try:
                self._save_wave_file(self.transcribe_file, self.frames)
                if not os.path.exists(self.transcribe_file):
                    self.logger.error(f"转写文件保存失败: {self.transcribe_file}")
                    if os.path.exists(self.playback_file):
                        try:
                            os.remove(self.playback_file)
                        except:
                            pass
                    return None, None
            except Exception as e:
                self.logger.error(f"保存转写音频失败: {e}")
                if os.path.exists(self.playback_file):
                    try:
                        os.remove(self.playback_file)
                    except:
                        pass
                return None, None

            # 验证文件是否可读
            for file in [self.playback_file, self.transcribe_file]:
                try:
                    with open(file, 'rb') as f:
                        pass
                    file_size = os.path.getsize(file)
                    if file_size < 1024:
                        self.logger.warning(f"文件过小 ({file_size} 字节): {file}")
                        return None, None
                except Exception as e:
                    self.logger.error(f"无法读取文件: {e}")
                    return None, None

            # 验证音频时长
            for file in [self.playback_file, self.transcribe_file]:
                if not self.validate_audio_file(file, min_duration=0.5):
                    self.logger.error(f"音频文件验证失败: {file}")
                    return None, None

            # 如果采样率不符合要求，转换音频格式
            if self.sample_rate != required_sample_rate:
                from pydub import AudioSegment  # 确保已安装 pydub
                try:
                    for file in [self.playback_file, self.transcribe_file]:
                        audio = AudioSegment.from_file(file)
                        audio = audio.set_frame_rate(required_sample_rate).set_channels(1)  # 转换为 16kHz 单声道
                        converted_file = file.replace(".wav", "_converted.wav")
                        audio.export(converted_file, format="wav")
                        os.remove(file)  # 删除原始文件
                        os.rename(converted_file, file)  # 重命名为原始文件名
                        self.logger.info(f"音频格式转换成功: {file}")
                except Exception as e:
                    self.logger.error(f"音频格式转换失败: {e}")
                    return None, None

            self.logger.info(f"已成功保存文件: {self.playback_file}, {self.transcribe_file}")
            return self.playback_file, self.transcribe_file

        except Exception as e:
            self.logger.error(f"保存音频文件失败: {e}")
            self.cleanup_temp_files()
            return None, None

    def check_file_in_use(self, file_path):
        """检查文件是否被其他进程占用"""
        for proc in psutil.process_iter(['pid', 'name']):
            try:
                for item in proc.open_files():
                    if item.path == file_path:
                        return True, proc.name()
            except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                pass
        return False, None

    def ensure_file_writable(self, file_path):
        """确保文件可写"""
        try:
            if os.path.exists(file_path):
                os.chmod(file_path, stat.S_IWRITE)
        except Exception as e:
            self.logger.warning(f"无法修改文件权限: {file_path}, 错误: {e}")

    def cleanup_temp_files(self):
        """清理临时文件的方法"""
        try:
            # 停止所有可能使用临时文件的活动
            if hasattr(self, 'audio') and self.audio:
                try:
                    self.audio.stop()
                    self.audio = None
                    self.logger.info("已停止音频播放")
                except Exception as e:
                    self.logger.error(f"停止音频时出错: {str(e)}")

            # 释放 pygame.mixer 资源（如果使用）
            try:
                if pygame.mixer.music.get_busy():
                    pygame.mixer.music.stop()
                    self.logger.info("已停止 pygame 音频播放")
                pygame.mixer.music.unload()
                self.logger.info("已卸载 pygame 音频资源")
            except Exception as e:
                self.logger.warning(f"无法卸载 pygame 音频: {e}")

            # 确保系统资源被正确释放
            gc.collect()
            self.logger.info("已执行垃圾回收")

            # 等待一小段时间，确保文件不再被占用
            time.sleep(0.1)

            # 使用类的属性来引用临时文件
            for file in [self.playback_file, self.transcribe_file]:
                if file and os.path.exists(file):
                    self.logger.info(f"尝试删除临时文件: {file}")

                    # 确保文件可写
                    self.ensure_file_writable(file)

                    # 检查文件是否被占用
                    is_in_use, proc_name = self.check_file_in_use(file)
                    if is_in_use:
                        self.logger.warning(f"文件被占用: {file}，占用进程: {proc_name}")
                        time.sleep(2)  # 等待更长时间
                        continue

                    # 强制垃圾回收
                    gc.collect()

                    # 尝试多次删除文件
                    for attempt in range(5):
                        try:
                            with open(file, 'a'):
                                pass  # 检查文件是否可写
                            os.remove(file)
                            self.logger.info(f"已删除临时文件: {file}")
                            break
                        except PermissionError as e:
                            self.logger.error(f"权限错误，无法删除文件: {file}, 错误: {e}")
                            time.sleep(2)  # 增加重试间隔
                        except (IOError, OSError) as e:
                            self.logger.warning(f"删除临时文件失败 (尝试 {attempt + 1}/5): {e}")
                            time.sleep(2)  # 增加重试间隔
                            gc.collect()
                    else:
                        self.logger.error(f"无法删除临时文件: {file}")

        except Exception as e:
            self.logger.error(f"清理临时文件失败: {e}", exc_info=True)

    def check_recording_device(self):
        try:
            p = pyaudio.PyAudio()
            device_count = p.get_device_count()
            for i in range(device_count):
                device_info = p.get_device_info_by_index(i)
                if device_info['maxInputChannels'] > 0:
                    self.logger.info(f"找到录音设备: {device_info['name']}")
                    p.terminate()
                    return True
            self.logger.error("未找到可用录音设备")
            messagebox.showerror("录音错误", "未找到可用录音设备")
            p.terminate()
            return False
        except Exception as e:
            self.logger.error(f"检查录音设备失败: {e}")
            return False

    def start_recording(self, callback=None):
        """开始录音，callback 用于通知 AudioPlayer 类"""
        if not self.check_recording_device():
            if callback:
                callback('error', "未找到可用录音设备")
            return

        self.is_recording = True
        self.frames = []
        self.last_audio_time = time.time()
        self.recording_event = threading.Event()
        self.audio_queue = queue.Queue()

        def record_audio():
            p = None
            stream = None
            try:
                p = pyaudio.PyAudio()
                stream = p.open(
                    format=pyaudio.paInt16,
                    channels=1,
                    rate=self.sample_rate,
                    input=True,
                    frames_per_buffer=8192
                )
                self.logger.info(f"录音设备已打开: 采样率={self.sample_rate} Hz, 声道数=1")

                while self.is_recording and not self.recording_event.is_set():
                    try:
                        data = stream.read(1024, exception_on_overflow=False)
                        # 改进静音检测逻辑，降低阈值并增加调试信息
                        max_amplitude = max(abs(int.from_bytes(data[i:i + 2], 'little', signed=True))
                                            for i in range(0, len(data), 2))
                        if max_amplitude > 300:  # 降低阈值以提高灵敏度
                            self.last_audio_time = time.time()
                            self.logger.debug(f"检测到有效音频数据，最大振幅: {max_amplitude}")
                        else:
                            self.logger.debug(f"检测到静音数据，最大振幅: {max_amplitude}")
                        self.frames.append(data)

                        if time.time() - self.last_audio_time > self.silence_threshold:
                            self.is_recording = False
                            self.logger.info('已停止录音（静音超时）')
                            self.audio_queue.put(('stopped', None))
                            break
                    except IOError as e:
                        self.logger.warning(f"音频输入溢出: {e}")
                        continue

            except Exception as e:
                self.logger.error(f"录音错误: {e}", exc_info=True)
                self.audio_queue.put(('error', f"录音失败: {str(e)}"))
            finally:
                if stream is not None:
                    try:
                        if stream.is_active():
                            stream.stop_stream()
                        stream.close()
                        self.logger.info("录音流已关闭")
                    except Exception as e:
                        self.logger.error(f"停止音频流失败: {e}")
                if p is not None:
                    try:
                        p.terminate()
                        self.logger.info("PyAudio 已关闭")
                    except Exception as e:
                        self.logger.error(f"关闭PyAudio失败: {e}")

        self.recording_thread = threading.Thread(target=record_audio, daemon=True)
        self.recording_thread.start()
        self.logger.info("已启动录音线程")
        if callback:
            callback('started', None)

    def check_audio_queue(self, callback=None):
        """检查音频队列，callback 用于通知 AudioPlayer 类"""
        try:
            while not self.audio_queue.empty():
                status, message = self.audio_queue.get_nowait()
                if status == 'stopped':
                    self.stop_recording()
                    if callback:
                        callback('stopped', None)
                elif status == 'error':
                    if callback:
                        callback('error', message)
        except queue.Empty:
            pass

    def stop_recording(self, callback=None):
        """停止录音，仅管理录音相关的状态，callback 用于通知 AudioPlayer 类"""
        try:
            if not self.is_recording:
                self.logger.info("录音未启动，直接返回已有数据")
                if callback:
                    callback('stopped', self.frames)
                return self.frames

            self.is_recording = False
            self.recording_event.set()
            if self.recording_thread:
                self.recording_thread.join(timeout=2.0)
                if self.recording_thread.is_alive():
                    self.logger.warning("录音线程未正常结束，可能由于音频流未正确关闭")
                self.recording_thread = None

            if not self.frames:
                self.logger.warning("没有录音数据")
                self.frames = []
                if callback:
                    callback('stopped', self.frames)
                return self.frames

            # 检查录音数据是否有效（例如是否全是静音）
            frame_data = b''.join(self.frames)
            if not any(frame_data):
                self.logger.warning("录音数据全是静音，可能未正确录音")
                self.frames = []
                if callback:
                    callback('stopped', self.frames)
                return self.frames

            # 记录录音数据的统计信息，便于调试
            frame_count = len(self.frames)
            total_bytes = len(frame_data)
            self.logger.info(f"录音数据统计: 帧数={frame_count}, 总字节数={total_bytes}")

            if callback:
                callback('stopped', self.frames)
            return self.frames

        except Exception as e:
            self.logger.error(f"停止录音失败: {e}", exc_info=True)
            if callback:
                callback('error', f"停止录音失败: {str(e)}")
            return []
        finally:
            self.is_recording = False
            if not self.frames:
                self.frames = []

    def __del__(self):
        """析构函数中确保清理临时文件"""
        self.cleanup_temp_files()


class AudioPlayer:
    def __init__(self, root):
        """初始化 AudioPlayer 类"""
        self.root = root
        self.root.title("24小时自选外教")
        self.root.geometry("1200x1000")
        self.logger = get_logger('AudioPlayer')
        self.logger.info("初始化 AudioPlayer")

        self.playback_queue = queue.Queue()  # 重命名 audio_queue 为 playback_queue

        # 初始化基本变量
        self.subtitle_offset = 0
        self._focus_debounce_timer = None
        self.settings_file = 'settings.json'
        self.temp_dir = os.path.join(os.path.expanduser('~'), '.audio_player_temp')
        self.current_position = 0
        self.audio_play_count = 0
        self._recognition_thread = None
        self._last_switch_time = time.time()
        self._fs_check_timer = None
        self.last_check_time = time.time()

        # 初始化播放器配置
        self.player_config = {
            'auto_save_interval': 300,
            'speed_presets': [0.75, 1.0, 1.25, 1.5, 2.0],
            'subtitle_offset': 0,
            'log_level': logging.INFO,
            'default_volume': 50,
            'max_recent_files': 10,
            'cleanup_interval': 86400,
            'default_loop_count': 1,
            'follow_pause_duration': 8000,
            'silence_threshold': 3
        }

        # 初始化音频引擎
        try:
            pygame.mixer.pre_init(44100, -16, 2, 4096)
            pygame.init()
            pygame.mixer.init()

            # 设置窗口关闭事件
            self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
            pygame.mixer.set_num_channels(8)
            self._volume = self.player_config.get('default_volume', 50)
            pygame.mixer.music.set_volume(self._volume / 100.0)
            self.logger.info(f"音频引擎初始化完成，音量: {self._volume}%")
        except Exception as e:
            self.logger.error(f"初始化音频引擎失败: {e}")
            messagebox.showerror("错误", "音频引擎初始化失败，请检查系统音频设置")
            self.root.destroy()
            sys.exit(1)

        # 注册程序退出时的清理函数
        atexit.register(self.cleanup_on_exit)
        self.logger.info("已注册程序退出清理函数")

        signal.signal(signal.SIGTERM, self.handle_signal)
        signal.signal(signal.SIGINT, self.handle_signal)

        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)

        # 初始化变量
        self.initialize_variables()

        # 创建界面
        self.create_widgets()

        # 创建菜单（假设已定义）
        self.create_menu()

        # 添加主题管理器（假设已定义 ThemeManager）
        self.theme_manager = ThemeManager()
        self.theme_manager.apply_theme_to_window(self.root)
        self.root.bind("<<ThemeChanged>>", self.update_theme)

        # 加载和初始化设置
        self.load_settings()
        self.initialize_settings()

        # 配置文件和目录
        self.setup_config_directories()

        # 绑定事件和加载状态
        self.bind_shortcuts()
        self.load_player_state()
        self.restore_folder_tree()

        # 设置关闭处理
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)

        # 启动自动保存和文件系统监控
        self.auto_save_state()
        self.start_fs_monitoring()

        self.follow_reader = WhisperFollowReading(api_type=self.speech_api_type)

        # 设置API配置
        for api_type, config in self.speech_api_config.items():
            self.follow_reader.set_api_config(api_type, config)

        # 初始化额外的mixer通道
        pygame.mixer.set_num_channels(8)  # 设置更多的音频通道

        # 新增文本编辑相关变量
        self.temp_text_file = os.path.join(self.temp_dir, 'temp_text.txt')
        self.create_text_editor()

    def initialize_variables(self):
        """初始化变量"""
        try:
            # 播放控制相关
            self._playback = {
                'speed': 1.0,
                'volume_fade': None,
                'time_offset': 0,
                'last_position': 0,
                'fade_timer': None
            }
            self.current_position = 0
            self.current_audio_length = 0
            self.is_seeking = False
            self.seek_target = None

            # 播放状态相关
            self.folders = {}
            self.current_playlist = []
            self.current_index = 0
            self.play_mode = "sequential"
            self.is_playing = False
            self.is_muted = False
            self.is_paused_for_delay = False

            # 跟读功能相关
            self.is_following = False
            self.is_following_active = False
            self.segment_duration = 5
            self.current_segment = 0
            self.total_segments = 0
            self.current_loop = 0
            self.max_follow_loops = 1
            self.follow_pause_duration = 8000
            self.is_editing_recovery = False
            self.is_editing = False
            self.current_segment_repeat_count = 0
            self.max_segment_repeats = 3
            self.is_manual_switch = False

            # 语音识别相关
            self.speech_api_type = "whisper"
            self.speech_api_config = {
                "baidu": {"app_id": "", "api_key": "", "secret_key": ""},
                "tencent": {"secret_id": "", "secret_key": ""}
            }
            self.is_manual_recording = False
            self.manually_recording = False

            # 字幕管理相关
            self.subtitles = []
            self.current_subtitle_index = 0
            self._subtitle_cache = {
                'last_time': 0,
                'last_index': 0,
                'last_subtitle': None
            }

            # 状态跟踪和计时器
            self._state = {
                'seeking': False,
                'updating': False,
                'last_error': None,
                'last_action': None,
                'startup_time': time.time()
            }
            self._timer = {
                'start_time': 0,
                'pause_time': 0,
                'offset': 0,
                'last_update': 0
            }
            self.STATUS_TYPES = {
                'info': {'fg': 'black', 'timeout': 3000},
                'success': {'fg': 'green', 'timeout': 2000},
                'warning': {'fg': 'orange', 'timeout': 5000},
                'error': {'fg': 'red', 'timeout': 0}
            }
            self.update_timer = None
            self._status_timer = None
            self._auto_save_timer = None
            self._progress_timer = None
            self._playback_delay_timer = None

            # 播放历史和统计
            self.play_history = []
            self.favorites = set()
            self.history_limit = 100
            self.recent_files = []
            self.stats = {
                'total_play_time': 0,
                'played_files': set(),
                'last_played': None,
                'favorite_count': 0,
                'folder_count': 0,
                'file_count': 0,
                'session_start': time.time()
            }

            # 音频处理相关
            self.wave_canvas = None
            self._audio_cache = {}
            self._waveform_cache = {}

            # 段落切换和状态标志
            self._segment_switch_queue = deque()
            self._segment_switch_lock = False
            self._target_segment = None
            self.is_playing_or_recording = False
            self.has_moved = False
            self.last_sentence_read = False
            self.selected_file = None
            self.paused_position = None

            self.logger.info("变量初始化完成")
        except Exception as e:
            self.logger.error(f"初始化变量失败: {e}")
            self.update_status(f"初始化变量失败: {str(e)}", 'error')
            raise

    def create_widgets(self):
        """创建界面组件"""
        try:
            style = ttk.Style()

            # 主背景色使用温暖的浅米色
            main_bg = '#FFF5E6'
            secondary_bg = '#FFF8F0'
            text_color = '#2C3E50'

            # 配置 ttk 主题
            style.theme_use('clam')

            # 基础样式配置
            style.configure('TFrame', background=main_bg)
            style.configure('TLabelframe', background=main_bg)
            style.configure('TLabelframe.Label',
                            background=main_bg,
                            foreground=text_color,
                            font=('Microsoft YaHei UI', 10))

            # 修改按钮颜色为更淡的橙红色
            accent_color = '#FF9966'  # 更淡的橙红色
            hover_color = '#FFB088'  # 鼠标悬停时的颜色
            pressed_color = '#FF7744'  # 按下时的颜色

            # 按钮样式配置
            style.configure('TButton',
                            font=('Microsoft YaHei UI', 9),
                            background=accent_color,
                            foreground=text_color,
                            borderwidth=1,
                            padding=5)
            style.map('TButton',
                      background=[('active', hover_color),
                                  ('pressed', pressed_color)],
                      foreground=[('active', text_color),
                                  ('pressed', '#FFFFFF')])

            # 菜单样式
            self.root.option_add('*Menu.background', secondary_bg)
            self.root.option_add('*Menu.foreground', text_color)
            self.root.option_add('*Menu.activeBackground', accent_color)
            self.root.option_add('*Menu.activeForeground', '#FFFFFF')
            self.root.option_add('*Menu.font', ('Microsoft YaHei UI', 9))

            # 标签样式
            style.configure('TLabel',
                            background=main_bg,
                            foreground=text_color,
                            font=('Microsoft YaHei UI', 10))

            # 进度条样式
            style.configure('Horizontal.TScale',
                            background=main_bg,
                            troughcolor='#FFE0B2',
                            slidercolor=accent_color)

            # 树形视图样式
            style.configure('Treeview',
                            background=secondary_bg,
                            fieldbackground=secondary_bg,
                            foreground=text_color,
                            font=('Microsoft YaHei UI', 9))
            style.map('Treeview',
                      background=[('selected', accent_color)],
                      foreground=[('selected', '#FFFFFF')])
            style.configure('Treeview.Heading',
                            background='#FFE0B2',
                            foreground=text_color,
                            font=('Microsoft YaHei UI', 9, 'bold'))

            # 文本框样式
            self.root.option_add('*Text.background', secondary_bg)
            self.root.option_add('*Text.foreground', text_color)
            self.root.option_add('*Text.selectBackground', accent_color)
            self.root.option_add('*Text.selectForeground', '#FFFFFF')
            self.root.option_add('*Text.font', ('Microsoft YaHei UI', 10))

            # 添加状态栏
            self.status_bar = ttk.Label(self.root, relief=tk.SUNKEN, anchor=tk.W)
            self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)

            # 创建主框架
            main_frame = ttk.Frame(self.root)
            main_frame.pack(fill="both", expand=True, padx=10, pady=5)

            # 左侧文件夹树形结构
            folder_frame = ttk.LabelFrame(main_frame, text="文件夹")
            folder_frame.pack(side="left", fill="both", expand=True, padx=5)

            # 创建树形视图
            self.folder_tree = ttk.Treeview(folder_frame, selectmode="browse")
            self.folder_tree.pack(side="left", fill="both", expand=True)

            # 添加滚动条
            tree_scroll = ttk.Scrollbar(folder_frame, orient="vertical",
                                        command=self.folder_tree.yview)
            tree_scroll.pack(side="right", fill="y")
            self.folder_tree.configure(yscrollcommand=tree_scroll.set)

            # 设置树形列头
            self.folder_tree["columns"] = ("duration",)
            self.folder_tree.column("#0", width=300, minwidth=200)
            self.folder_tree.column("duration", width=100, minwidth=50)
            self.folder_tree.heading("#0", text="名称")
            self.folder_tree.heading("duration", text="时长")

            # 绑定树形视图事件
            self.folder_tree.bind("<Double-1>", self.on_tree_double_click)
            self.folder_tree.bind("<Button-1>", self.on_tree_single_click)

            # 右侧控制面板
            self.control_frame = ttk.Frame(main_frame)
            self.control_frame.pack(side="right", fill="both", padx=5)

            # 文件操作按钮
            file_frame = ttk.LabelFrame(self.control_frame, text="文件操作")
            file_frame.pack(fill="x", pady=5)

            ttk.Button(file_frame, text="添加文件夹",
                       command=self.add_folder).pack(side="left", padx=5)
            ttk.Button(file_frame, text="移除选中文件夹",
                       command=self.remove_selected_folder).pack(side="left", padx=5)
            ttk.Button(file_frame, text="播放选中文件夹",
                       command=self.play_selected_folder).pack(side="left", padx=5)

            # 播放模式选择
            mode_frame = ttk.LabelFrame(self.control_frame, text="播放模式")
            mode_frame.pack(fill="x", pady=5)

            # 新增循环次数输入框
            loop_frame = ttk.Frame(mode_frame)
            loop_frame.pack(side="left", padx=5)
            ttk.Label(loop_frame, text="循环次数:").pack(side="left")
            self.loop_count = tk.IntVar(value=1)
            self.loop_spin = ttk.Spinbox(loop_frame, from_=1, to=999, width=3,
                                         textvariable=self.loop_count)
            self.loop_spin.pack(side="left", padx=2)

            # 添加播放模式选择
            self.mode_var = tk.StringVar(value=self.play_mode)
            ttk.Radiobutton(mode_frame, text="顺序播放", variable=self.mode_var,
                            value="sequential").pack(side="left")
            ttk.Radiobutton(mode_frame, text="单曲循环", variable=self.mode_var,
                            value="loop_one").pack(side="left")
            ttk.Radiobutton(mode_frame, text="列表循环", variable=self.mode_var,
                            value="loop_all").pack(side="left")

            # 播放控制按钮（假设已定义）
            self.create_control_buttons()

            # 音量控制
            volume_frame = ttk.LabelFrame(self.control_frame, text="音量控制")
            volume_frame.pack(fill="x", pady=5)
            self.volume_scale = ttk.Scale(
                volume_frame,
                from_=0,
                to=100,
                orient="horizontal",
                command=lambda v: self.set_volume(v)
            )
            self.volume_scale.set(self._volume)
            self.volume_scale.pack(fill="x", padx=5)

            # 当前播放信息
            self.info_label = ttk.Label(self.control_frame, text="未播放")
            self.info_label.pack(pady=5)

            # 添加跟读控制区域
            self.follow_frame = ttk.LabelFrame(self.control_frame, text="跟读控制")
            self.follow_frame.pack(fill="x", pady=5)

            # 在 follow_frame 中创建一个横向按钮框架
            button_frame = ttk.Frame(self.follow_frame)
            button_frame.pack(fill="x", pady=5)

            # 字幕编辑按钮和跟读按钮
            self.edit_subtitle_btn = ttk.Button(
                button_frame,
                text="预览/修改字幕",
                command=self.edit_current_subtitles
            )
            self.edit_subtitle_btn.pack(side="left", padx=5)

            self.follow_button = ttk.Button(
                button_frame,
                text="开始跟读",
                command=self.toggle_follow_reading
            )
            self.follow_button.pack(side="left", padx=5)


            # 跟读文本显示区域
            text_frame = ttk.LabelFrame(self.control_frame, text="跟读结果")
            text_frame.pack(fill="both", expand=True, pady=5)

            self.follow_text = tk.Text(text_frame, height=9, width=40)
            self.follow_text.pack(pady=5, padx=5, fill="both", expand=True)

            # 字幕样式配置
            self.follow_text.tag_configure('en', foreground='#2980B9', font=('Microsoft YaHei UI', 11))
            self.follow_text.tag_configure('cn', foreground='#16A085', font=('Microsoft YaHei UI', 10))
            self.follow_text.tag_configure('time', foreground='#7F8C8D', font=('Microsoft YaHei UI', 9))
            self.follow_text.tag_configure('prompt', foreground='#8E44AD', font=('Microsoft YaHei UI', 10))
            self.follow_text.tag_configure('recognized', foreground='#2980B9', font=('Microsoft YaHei UI', 11))
            self.follow_text.tag_configure('title', foreground=accent_color,
                                           font=('Microsoft YaHei UI', 11, 'bold'))
            self.follow_text.tag_configure('error', foreground='#C0392B', font=('Microsoft YaHei UI', 10))

            # 播放进度控制
            progress_frame = ttk.LabelFrame(self.control_frame, text="播放进度")
            progress_frame.pack(fill="x", pady=5)

            # 快进快退按钮和进度条框架
            progress_control_frame = ttk.Frame(progress_frame)
            progress_control_frame.pack(fill="x", padx=5)

            self.create_follow_control_buttons()

            # 后退2秒
            ttk.Button(progress_control_frame, text="◀◀", width=3,
                       command=lambda: self.seek_relative(-2)).pack(side="left", padx=2)

            # 进度条
            self.progress_scale = ttk.Scale(progress_control_frame, from_=0, to=100,
                                            orient="horizontal")
            self.progress_scale.pack(side="left", fill="x", expand=True, padx=5)

            # 进度条事件绑定
            self.progress_scale.bind("<Button-1>", self.on_progress_press)
            self.progress_scale.bind("<ButtonRelease-1>", self.on_progress_release)

            # 前进2秒
            ttk.Button(progress_control_frame, text="▶▶", width=3,
                       command=lambda: self.seek_relative(2)).pack(side="left", padx=2)

            # 时间显示框架
            time_frame = ttk.Frame(progress_frame)
            time_frame.pack(fill="x", padx=5)

            # 当前时间/总时间
            self.time_label = ttk.Label(time_frame, text="00:00 / 00:00")
            self.time_label.pack(side="right", padx=5)

            # 添加波形显示
            wave_frame = ttk.LabelFrame(self.control_frame, text="音频波形")
            wave_frame.pack(fill="x", pady=5)
            self.wave_canvas = tk.Canvas(wave_frame, height=60, bg=secondary_bg)
            self.wave_canvas.pack(fill="x", padx=5)

            # 添加播放列表功能按钮
            playlist_frame = ttk.Frame(self.control_frame)
            playlist_frame.pack(fill="x", pady=5)
            ttk.Button(playlist_frame, text="导出列表",
                       command=self.export_playlist).pack(side="left", padx=2)
            ttk.Button(playlist_frame, text="导入列表",
                       command=self.import_playlist).pack(side="left", padx=2)
            ttk.Button(playlist_frame, text="收藏",
                       command=self.toggle_favorite).pack(side="left", padx=2)

            # 修改状态栏样式
            self.status_bar.configure(
                background=main_bg,
                foreground=text_color,
                font=('Microsoft YaHei UI', 9)
            )

            self.logger.info("界面组件创建完成")
        except Exception as e:
            self.logger.error(f"创建界面组件失败: {e}")
            messagebox.showerror("错误", "界面组件创建失败，请检查系统设置")
            self.root.destroy()
            sys.exit(1)

    def volume(self):
        """音量属性getter"""
        return self._volume

    def volume(self, value):
        """音量属性setter"""
        # 确保音量在0-100范围内
        self._volume = max(0, min(100, float(value)))
        # 更新pygame音量(0-1范围)
        pygame.mixer.music.set_volume(self._volume / 100)
        # 如果滑块已创建，同步更新
        if hasattr(self, 'volume_scale'):
            self.volume_scale.set(self._volume)

    def recording_callback(self, status, message=None):
        if status == 'started':
            self.is_playing_or_recording = True
            self.has_moved = False
            self.logger.info("录音已开始")
        elif status == 'stopped':
            self.is_playing_or_recording = False
            self.has_moved = False
            self.is_playing = False
            if self.is_following:
                self.update_follow_mode(True)
            else:
                self.update_follow_mode(False)
            self.logger.info("录音已停止")
        elif status == 'error':
            self.logger.error(message)
            messagebox.showerror("录音错误", message)
            self.update_status(message, 'error')

    def setup_config_directories(self):
        """改进的配置目录设置功能"""
        try:
            # 使用统一的应用名称
            app_name = '24h自选外教'

            # 添加配置目录
            self.config_dir = os.path.join(os.path.expanduser('~'), f'.{app_name}')
            self.logs_dir = os.path.join(self.config_dir, 'logs')
            self.cache_dir = os.path.join(self.config_dir, 'cache')
            self.temp_dir = os.path.join(self.config_dir, 'temp')
            self.data_dir = os.path.join(self.config_dir, 'data')

            # 创建必要目录
            for directory in [self.config_dir, self.logs_dir, self.cache_dir, self.temp_dir, self.data_dir]:
                if not os.path.exists(directory):
                    os.makedirs(directory)

            # 配置文件路径
            self.state_file = os.path.join(self.config_dir, 'player_state.json')
            self.settings_file = os.path.join(self.config_dir, 'settings.json')
            self.history_file = os.path.join(self.config_dir, 'history.json')
            self.favorites_file = os.path.join(self.config_dir, 'favorites.json')

            # 临时文件路径
            self.temp_audio_file = os.path.join(self.temp_dir, 'temp_audio.wav')
            self.temp_text_file = os.path.join(self.temp_dir, 'temp_text.txt')

            # 配置日志文件
            self.setup_logging()

        except Exception as e:
            print(f"设置配置目录失败: {e}")
            messagebox.showerror("错误", f"初始化配置目录失败: {str(e)}", icon='error')

    def setup_logging(self):
        """设置日志系统"""
        try:
            # 确保日志目录存在
            os.makedirs(self.logs_dir, exist_ok=True)

            # 使用全局日志配置
            log_dir = self.logs_dir
            log_level = self.player_config['log_level']
            setup_global_logging(log_dir, log_level)

            # 获取模块特定的日志记录器
            self.logger = get_logger('AudioPlayer')
            self.logger.info("日志系统初始化完成")

        except Exception as e:
            print(f"设置日志系统失败: {e}")
            # 确保即使日志设置失败也有日志记录器可用
            self.logger = logging.getLogger('AudioPlayer')

    def start_fs_monitoring(self):
        """启动文件系统监视"""

        def check_files():
            try:
                current_time = time.time()
                if current_time - self.last_check_time >= 60:  # 每分钟检查一次
                    self.validate_folders()
                    self.last_check_time = current_time

                self._fs_check_timer = self.root.after(10000, check_files)  # 每10秒调用一次
            except Exception as e:
                self.logger.error(f"文件系统监视错误: {e}")

        check_files()

    def validate_folders(self):
        """验证文件夹和文件的有效性"""
        try:
            for folder_id in list(self.folders.keys()):
                folder_info = self.folders[folder_id]
                folder_path = folder_info['path']

                if not os.path.exists(folder_path):
                    continue

                # 验证文件列表
                valid_files = [f for f in folder_info['files'] if os.path.exists(f)]

                # 更新文件列表
                self.folders[folder_id]['files'] = valid_files

        except Exception as e:
            self.logger.error(f"验证文件夹失败: {e}")


    @handle_audio_error
    def set_playback_position(self, new_pos):
        """设置播放位置，并更新时间显示 (来自 10th version)"""
        if not self.current_playlist:
            return
        try:
            current_file = self.current_playlist[self.current_index]
            # 异步加载和播放音频
            threading.Thread(target=self._load_and_play_audio, args=(current_file, new_pos), daemon=True).start()
            self.current_position = new_pos  # 记录新的播放位置
            total_length = self.get_current_audio_length()
            self.time_label.config(text=f"{self.format_time(new_pos)} / {self.format_time(total_length)}")
        except Exception as e:
            self.update_status(f"定位失败: {str(e)}", 'error')

    def create_menu(self):
        """改进的菜单创建功能"""
        try:
            menubar = tk.Menu(self.root)
            self.root.config(menu=menubar)

            # 文件菜单
            self.file_menu = tk.Menu(menubar, tearoff=0)
            menubar.add_cascade(label="文件", menu=self.file_menu)
            self.file_menu.add_command(label="添加文件夹", command=self.add_folder)
            self.file_menu.add_command(label="导入播放列表", command=self.import_playlist)
            self.file_menu.add_command(label="导出播放列表", command=self.export_playlist)
            self.file_menu.add_separator()
            self.file_menu.add_command(label="退出", command=self.on_closing)  # 使用 on_closing

            # 播放菜单
            play_menu = tk.Menu(menubar, tearoff=0)
            menubar.add_cascade(label="播放", menu=play_menu)
            play_menu.add_command(label="播放/暂停", command=self.play_pause)
            play_menu.add_command(label="停止", command=self.stop)
            play_menu.add_separator()
            play_menu.add_command(label="上一曲", command=self.previous_track)
            play_menu.add_command(label="下一曲", command=self.next_track)

            # 工具菜单
            tools_menu = tk.Menu(menubar, tearoff=0)
            menubar.add_cascade(label="工具", menu=tools_menu)
            tools_menu.add_command(label="字幕生成", command=self.show_subtitle_generator)  # 新增
            tools_menu.add_command(label="录音录屏截屏", command=self.show_screen_recorder)  # 新增屏幕录制工具
            tools_menu.add_command(label="图像格式转换", command=self.open_image_converter)# 添加图像转换工具菜单项
            tools_menu.add_command(label="主题设置", command=self.show_theme_settings)  # 添加主题设置
            tools_menu.add_command(label="跟读模式", command=self.toggle_follow_reading)
            tools_menu.add_command(label="学习记录", command=self.show_text_editor)  # 新增文本编辑器入口
            tools_menu.add_command(label="清理缓存", command=self.clean_cache)
            tools_menu.add_command(label="查看统计", command=self.show_stats)

            # 帮助菜单
            help_menu = tk.Menu(menubar, tearoff=0)
            menubar.add_cascade(label="帮助", menu=help_menu)
            help_menu.add_command(label="快捷键", command=self.show_shortcuts)
            help_menu.add_command(label="关于", command=self.show_about)

        except Exception as e:
            self.update_status(f"创建菜单失败: {str(e)}", 'error')

    def show_subtitle_generator(self):
        """显示字幕生成窗口"""
        SubtitleGeneratorWindow(self.root)

    # 添加图像转换工具打开函数
    def open_image_converter(self):
        """打开图像格式转换工具"""
        try:
            # 使用主应用程序的主题管理器
            ImageConverterApp(self.root, standalone=False, theme_manager=IconThemeManager())
        except Exception as e:
            import traceback
            messagebox.showerror("错误", f"无法打开图像转换工具: {str(e)}")
            print(f"错误详情: {traceback.format_exc()}")

    def show_theme_settings(self):
        """显示主题设置对话框"""
        self.theme_manager.show_color_settings(self.root)

    def update_theme(self, event=None):
        """更新主题"""
        # 重新加载颜色
        self.theme_manager.colors = self.theme_manager.load_colors()

        # 重新应用主题
        self.theme_manager.apply_theme_to_window(self.root)

        # 更新ttk样式
        style = ttk.Style()
        self.theme_manager.apply_theme_to_ttk_styles(style)

    def show_text_editor(self):
        """显示文本编辑窗口"""
        print("Entering show_text_editor")
        if not hasattr(self,
                       'text_editor_window') or self.text_editor_window is None or not self.text_editor_window.window.winfo_exists():
            print("Creating new TextEditorWindow")
            self.text_editor_window = TextEditorWindow(self.root, self)
            # 加载最新的 temp_text_file 内容
            self.text_editor_window.load_text()
        else:
            print("Existing window found, focusing")
            self.text_editor_window.window.lift()
            self.text_editor_window.window.focus_force()
            # 重新加载 temp_text_file 内容
            self.text_editor_window.load_text()

    def show_screen_recorder(self):
        """显示屏幕录制工具"""
        try:
            screen_window = tk.Toplevel(self.root)
            app = ScreenRecorderApp(screen_window)
            self.update_status("屏幕录制工具已启动", 'success')
        except Exception as e:
            self.update_status(f"启动屏幕录制工具失败: {str(e)}", 'error')
            self.logger.error(f"启动屏幕录制工具失败: {e}")

    def show_stats(self):
        """改进的统计信息显示功能"""
        try:
            stats_window = tk.Toplevel(self.root)
            stats_window.title("播放统计")
            stats_window.geometry("400x500")

            # 计算会话时长
            session_duration = time.time() - self.stats['session_start']
            total_hours = self.stats['total_play_time'] / 3600

            # 创建统计信息文本
            stats_text = tk.Text(stats_window, wrap=tk.WORD, padx=10, pady=10)
            stats_text.pack(fill=tk.BOTH, expand=True)

            stats_info = [
                ("播放统计", "-" * 40),
                ("总播放时长", f"{total_hours:.2f}小时"),
                ("本次会话时长", f"{session_duration / 3600:.2f}小时"),
                ("播放文件数", len(self.stats['played_files'])),
                ("收藏文件数", len(self.favorites)),
                ("文件夹数量", len(self.folders)),
                ("", "-" * 40),
                ("最近播放", "最后播放时间" if self.stats['last_played'] else "无"),
                ("", time.strftime("%Y-%m-%d %H:%M:%S",
                                   time.localtime(self.stats['last_played'])) if self.stats['last_played'] else "")
            ]

            for title, value in stats_info:
                stats_text.insert(tk.END, f"{title}: {value}\n")

            stats_text.config(state=tk.DISABLED)

        except Exception as e:
            self.update_status(f"显示统计信息失败: {str(e)}", 'error')

    def check_follow_status(self, original_wait_time):
        """检查跟读状态"""
        if not self.is_following:
            self.logger.info("已退出跟读模式，停止检查")
            return

        current_time = time.time()
        if (current_time - self.follow_reader.last_audio_time >= self.follow_reader.silence_threshold or
                current_time - self.follow_reader.last_audio_time >= original_wait_time / 1000):
            self.logger.info("录音检查完成，继续播放")
            # 如果没有检测到语音输入且已经过了最短等待时间
            if not self.follow_reader.frames and current_time - self.follow_reader.last_audio_time >= self.follow_reader.min_wait_time:
                self.follow_text.insert('end', "\n未检测到语音输入，继续下一段\n", 'warning')
                self.continue_after_playback()
                return

            # 处理录音
            self.process_follow_reading()

        else:
            # 继续等待
            self.root.after(100, lambda: self.check_follow_status(original_wait_time))


    def show_shortcuts(self):
        """显示快捷键列表"""
        try:
            shortcuts_window = tk.Toplevel(self.root)
            shortcuts_window.title("快捷键")
            shortcuts_window.geometry("300x400")

            shortcuts_text = tk.Text(shortcuts_window, wrap=tk.WORD, padx=10, pady=10)
            shortcuts_text.pack(fill=tk.BOTH, expand=True)

            shortcuts_info = [
                ("播放/暂停", "Space 或 Ctrl+P"),
                ("停止", "Esc"),
                ("上一曲", "无"),
                ("下一曲", "无"),
                ("快退", "Left"),
                ("快进", "Right"),
                ("长距离快退", "Ctrl+Left"),
                ("长距离快进", "Ctrl+Right"),
                ("音量增大", "Up"),
                ("音量减小", "Down"),
                ("语速加快", "Ctrl+Up"),
                ("语速减慢", "Ctrl+Down"),
                ("跟读模式", "Ctrl+F"),
                ("保存状态", "Ctrl+S")
            ]

            for action, keys in shortcuts_info:
                shortcuts_text.insert(tk.END, f"{action}: {keys}\n")

            shortcuts_text.config(state=tk.DISABLED)

        except Exception as e:
            self.update_status(f"显示快捷键帮助失败: {str(e)}", 'error')

    def continue_after_follow(self):
        """语音识别完成后继续播放下一个段落"""
        try:
            self.logger.info("继续播放下一个段落")
            self.is_playing = True
            self.is_following_active = False
            self.is_playing_or_recording = True
            self.toggle_play_button(enable=True)
            self.toggle_navigation_buttons(enable=True)
            self.current_segment += 1  # 移动到下一个段落
            if self.current_segment < len(self.subtitles):
                self.play_segment()  # 播放下一个段落
            else:
                self.logger.info("已播放所有段落，停止跟读模式")
                self.stop_follow_reading()
        except Exception as e:
            self.logger.error(f"继续播放失败: {e}", exc_info=True)
            self.update_status(f"继续播放失败: {str(e)}", 'error')

    def process_follow_reading(self):
        """完整的录音处理流程"""
        playback_file = None
        transcribe_file = None
        try:
            frames = self.follow_reader.stop_recording(callback=self.recording_callback)
            if not frames:
                self.logger.warning("没有录音数据")
                self.continue_after_playback()
                return

            frame_data = b''.join(frames)
            if not any(frame_data):
                self.logger.warning("录音数据全是静音，可能未正确录音")
                self.continue_after_playback()
                return

            playback_file, transcribe_file = self.follow_reader.save_audio_files()
            if not playback_file or not transcribe_file:
                self.logger.error("保存音频文件失败")
                self.cleanup_and_continue(playback_file, transcribe_file)
                return

            current_subtitle = self.subtitles[self.current_segment]
            reference_text = current_subtitle.get('en_text', '')
            self.follow_text.delete('1.0', 'end')

            if not self.no_playback_mode and os.path.exists(playback_file):
                try:
                    pygame.mixer.music.load(playback_file)
                    pygame.mixer.music.play()
                    self.logger.info(f"开始播放录音文件: {playback_file}")
                except Exception as e:
                    self.logger.error(f"播放录音失败: {e}", exc_info=True)
                    self.cleanup_and_continue(playback_file, transcribe_file)
                    return

            def recognition_callback(status, recognition=None, error=None):
                try:
                    if status == 'success' and recognition:
                        # 简化日志输出，只记录必要信息
                        en_text = recognition.get('en_text', '')
                        confidence = recognition.get('confidence', 0)
                        self.logger.info(f"语音识别成功: en_text={en_text}, confidence={confidence}")
                        self._update_recognition_result(
                            recognition, reference_text, playback_file, transcribe_file)
                        self.logger.info("语音识别完成，继续播放下一段")
                        self.continue_after_playback()
                    elif status == 'error':
                        self.logger.error(f"语音识别失败: {error}")
                        self.cleanup_and_continue(playback_file, transcribe_file)
                except Exception as e:
                    self.logger.error(f"处理语音识别回调失败: {e}", exc_info=True)
                    self.cleanup_and_continue(playback_file, transcribe_file)

            def handle_recognition():
                try:
                    if not os.path.exists(transcribe_file):
                        self.logger.error(f"转写文件不存在: {transcribe_file}")
                        recognition_callback('error', error=f"转写文件不存在: {transcribe_file}")
                        return
                    self.logger.info(f"开始语音识别: {transcribe_file}")
                    self.follow_reader.recognize_speech(transcribe_file, callback=recognition_callback)
                except Exception as e:
                    self.logger.error(f"处理语音识别失败: {e}", exc_info=True)
                    recognition_callback('error', error=f"处理语音识别失败: {str(e)}")
                finally:
                    with threading.Lock():
                        if hasattr(self, 'recognition_thread') and self.recognition_thread:
                            self.logger.info("语音识别线程已结束")
                            self.recognition_thread = None

            self.recognition_thread = threading.Thread(target=handle_recognition, daemon=True)
            self.recognition_thread.start()
            self.logger.info("已启动语音识别线程")

        except Exception as e:
            self.logger.error(f"处理录音失败: {e}", exc_info=True)
            self.cleanup_and_continue(playback_file, transcribe_file)
        finally:
            self.toggle_navigation_buttons(True)
            self.toggle_play_button(enable=True)

    def _update_recognition_result(self, recognition, reference_text, playback_file, transcribe_file):
        """更新识别结果到界面"""
        try:
            self.follow_text.insert('end', "\n=== 跟读结果 ===\n", 'title')
            recognized_text = recognition.get('en_text', '')
            self.follow_text.insert('end', f"您说的是: {recognized_text}\n", 'recognized')

            if recognition.get('cn_text'):
                self.follow_text.insert('end', f"翻译: {recognition['cn_text']}\n", 'cn')

            similarity = self.calculate_improved_similarity(reference_text, recognized_text)
            feedback = self.get_feedback(similarity)

            self.follow_text.insert('end', f"\n准确度评分: {similarity:.1f}%\n", 'score')
            self.follow_text.insert('end', f"{feedback}\n", 'feedback')
            self.follow_text.see('end')

            # 确保音频播放完成后继续
            def delayed_cleanup():
                if pygame.mixer.music.get_busy():
                    self.root.after(100, delayed_cleanup)  # 如果仍在播放，延迟检查
                else:
                    self.cleanup_and_continue(playback_file, transcribe_file)

            self.root.after(100, delayed_cleanup)  # 初始延迟检查

        except Exception as e:
            self.logger.error(f"更新识别结果失败: {e}", exc_info=True)
            self.cleanup_and_continue(playback_file, transcribe_file)

    def cleanup_and_continue(self, playback_file, transcribe_file):
        """清理资源并继续"""
        try:
            if hasattr(self, 'recognition_thread') and self.recognition_thread:
                if self.recognition_thread != threading.current_thread():
                    self.logger.info("尝试结束语音识别线程")
                    self.recognition_thread.join(timeout=40.0)  # 延长超时时间
                    if self.recognition_thread.is_alive():
                        self.logger.warning("语音识别线程未正常结束，强制结束")
                    else:
                        self.logger.info("语音识别线程已正常结束")
                self.recognition_thread = None

            if hasattr(self.follow_reader, 'cleanup_temp_files'):
                self.follow_reader.cleanup_temp_files()
                self.logger.info("已清理临时文件")
            else:
                self.logger.warning("follow_reader 未实现 cleanup_temp_files 方法，尝试手动清理")

            for file in [playback_file, transcribe_file]:
                if file and os.path.exists(file):
                    try:
                        self.ensure_file_writable(file)
                        is_in_use, proc_name = self.check_file_in_use(file)
                        if is_in_use:
                            self.logger.warning(f"文件被占用: {file}，占用进程: {proc_name}")
                            time.sleep(2)  # 等待文件释放
                            if os.path.exists(file):  # 再次检查文件是否存在
                                os.remove(file)
                                self.logger.info(f"已删除临时文件: {file}")
                        else:
                            os.remove(file)
                            self.logger.info(f"已删除临时文件: {file}")
                    except Exception as e:
                        self.logger.warning(f"删除临时文件失败: {file}, 错误: {e}")

            # 清理 pygame mixer 资源
            pygame.mixer.music.stop()
            pygame.mixer.music.unload()
            self.logger.info("已停止并卸载 pygame mixer 资源")

        except Exception as e:
            self.logger.error(f"清理资源失败: {e}", exc_info=True)
        finally:
            self.toggle_navigation_buttons(True)
            self.toggle_play_button(enable=True)
            self.logger.info("清理完成，继续播放下一段")
            self.continue_after_playback()

    def continue_after_playback(self):
        """改进的回放结束后继续播放逻辑，优化与进度条拖动的配合"""
        try:
            self.logger.info(f"继续播放 - 当前状态: is_following={self.is_following}, "
                             f"current_segment={self.current_segment}, "
                             f"total_segments={self.total_segments}, "
                             f"repeat_count={self.current_segment_repeat_count}, "
                             f"loop_count={self.current_loop}, "
                             f"is_manual_switch={self.is_manual_switch}, "
                             f"current_index={self.current_index}, "
                             f"playlist_length={len(self.current_playlist)}")

            if hasattr(self, '_segment_switch_queue') and self._segment_switch_queue:
                self.logger.info("处理段落切换队列")
                self._process_switch_queue()
                return

            if not self.is_following:
                self.logger.info("非跟读模式，处理播放结束")
                self.handle_playback_ended()
                return

            if not hasattr(self, 'total_segments') or self.total_segments <= 0:
                self.logger.error("total_segments 未正确初始化或无效")
                self.stop_follow_reading()
                return

            if not self.is_manual_switch:
                self.current_segment_repeat_count += 1
                if self.current_segment_repeat_count < self.max_segment_repeats:
                    self.logger.info(f"重复播放当前段落: {self.current_segment + 1}, "
                                     f"重复次数: {self.current_segment_repeat_count + 1}/{self.max_segment_repeats}")
                    self.follow_text.insert('end', f"\n重复播放第 {self.current_segment + 1} 句 "
                                                   f"(第 {self.current_segment_repeat_count + 1}/{self.max_segment_repeats} 次)\n",
                                            'prompt')
                    self.play_segment()
                    return
                else:
                    self.logger.info(f"当前段落重复次数已达上限，重置重复次数: {self.current_segment_repeat_count}")
                    self.current_segment_repeat_count = 0
            else:
                self.logger.info("手动切换，重置手动切换标记和重复次数")
                self.is_manual_switch = False
                self.current_segment_repeat_count = 0

            next_segment = self.current_segment + 1
            if next_segment < self.total_segments:
                self.logger.info(f"准备播放下一段: {next_segment + 1}/{self.total_segments}")
                self.follow_text.insert('end', "\n=== 准备下一段 ===\n", 'prompt')
                self.current_segment = next_segment
                self.current_segment_repeat_count = 0
                self.play_segment()
                return

            self.current_loop += 1
            if self.current_loop < self.max_follow_loops:
                self.logger.info(f"开始第 {self.current_loop + 1} 轮跟读")
                self.current_segment = 0
                self.current_segment_repeat_count = 0
                self.follow_text.insert('end', f"\n开始第 {self.current_loop + 1} 轮跟读\n", 'title')
                self.play_segment()
                return

            play_mode = self.mode_var.get()
            if play_mode == "loop_one":
                self.logger.info("单曲循环，重新开始跟读当前音频")
                self.current_loop = 0
                self.current_segment = 0
                self.current_segment_repeat_count = 0
                self.follow_text.insert('end', "\n重新开始跟读当前音频\n", 'title')
                self.play_segment()
            elif play_mode == "loop_all" and len(self.current_playlist) > 1:
                self.logger.info("播放列表循环，切换到播放列表中的下一个音频文件")
                self.current_index = (self.current_index + 1) % len(self.current_playlist)
                self.current_loop = 0
                self.current_segment = 0
                self.current_segment_repeat_count = 0
                self.follow_text.insert('end', f"\n开始跟读下一个音频文件 (索引: {self.current_index})\n", 'title')
                self.start_follow_reading()
            elif self.current_index < len(self.current_playlist) - 1:
                self.logger.info("播放列表模式，开始跟读下一个音频文件")
                self.current_index += 1
                self.current_loop = 0
                self.current_segment = 0
                self.current_segment_repeat_count = 0
                self.follow_text.insert('end', f"\n开始跟读下一个音频文件 (索引: {self.current_index})\n", 'title')
                self.start_follow_reading()
            else:
                self.logger.info("跟读模式结束，停止播放")
                self.stop_follow_reading()
                self.follow_text.insert('end', "\n跟读模式结束\n", 'title')

        except Exception as e:
            self.logger.error(f"继续播放失败: {e}", exc_info=True)
            self.update_status(f"继续播放失败: {str(e)}", 'error')
            self.stop_follow_reading()

    def load_settings(self):
        """改进的设置加载功能，确保文件夹正确恢复"""
        try:
            if os.path.exists(self.settings_file):
                with open(self.settings_file, 'r', encoding='utf-8') as f:
                    settings = json.load(f)

                # 加载文件夹信息
                loaded_folders = settings.get('folders', {})
                for folder_path, folder_data in loaded_folders.items():
                    if os.path.exists(folder_path):
                        folder_name = os.path.basename(folder_path)
                        tree_id = self.folder_tree.insert(
                            "", "end",
                            text=folder_name,
                            values=(f"{len(folder_data['files'])}个文件",)
                        )
                        self.folders[tree_id] = {
                            'path': folder_path,
                            'files': folder_data['files'],
                            'expanded': folder_data['expanded']
                        }
                        if folder_data['expanded']:
                            self.expand_folder(tree_id)

                # 恢复其他设置
                self._volume = settings.get('volume', 50)
                self._playback['time_offset'] = settings.get('subtitle_offset', 0)
                self.loop_count.set(settings.get('loop_count', 1))
                self.mode_var.set(settings.get('play_mode', 'sequential'))

                self.update_status("设置已加载", 'success')
                return True

        except Exception as e:
            self.logger.error(f"加载设置失败: {e}")
            self.update_status(f"加载设置失败: {str(e)}", 'error')
            return False

    def initialize_settings(self):
        """初始化设置，包括最大重复次数"""
        try:
            # 使用从 load_settings 加载的 max_segment_repeats
            if not hasattr(self, 'max_segment_repeats'):
                self.max_segment_repeats = 3  # 如果未加载成功，使用默认值 3
            if self.max_segment_repeats < 1 or self.max_segment_repeats > 10:
                self.max_segment_repeats = 3


        except Exception as e:
            self.logger.error(f"初始化次数失败: {e}")

    def stop_follow_reading(self, resume_normal_playback=False):
        """改进的停止跟读功能，停止跟读模式并清理相关状态"""
        try:
            if not self.is_following:
                self.logger.info("当前不在跟读模式，无需停止")
                return

            self.is_following = False
            self.follow_button.config(text="开始跟读")

            self.toggle_play_button(enable=True)
            self.toggle_navigation_buttons(enable=True)

            # 停止音频播放并卸载资源
            pygame.mixer.music.stop()
            pygame.mixer.music.unload()
            self.logger.info("已停止音频播放并卸载资源")

            # 清理语音识别线程
            if hasattr(self, 'recognition_thread') and self.recognition_thread:
                self.recognition_thread.join(timeout=5.0)
                if self.recognition_thread.is_alive():
                    self.logger.warning("语音识别线程未正常结束")
                self.recognition_thread = None

            # 清理临时文件
            if hasattr(self.follow_reader, 'cleanup_temp_files'):
                self.follow_reader.cleanup_temp_files()
                self.logger.info("已清理临时文件")

            self.root.after(200, lambda: self._cleanup_after_stop(resume_normal_playback))
            self.update_status("已停止跟读", 'info')

        except Exception as e:
            self.logger.error(f"停止跟读失败: {e}")
            self.update_status(f"停止跟读失败: {str(e)}", 'error')
            self._reset_playback_state()

    def cleanup_on_exit(self):
        """程序退出时的清理操作"""
        try:
            self.logger.info("程序退出，执行清理操作")
            self.stop_follow_reading()
            pygame.mixer.quit()
            self.logger.info("已退出 pygame mixer")
            if hasattr(self.follow_reader, 'cleanup_temp_files'):
                self.follow_reader.cleanup_temp_files()
                self.logger.info("已清理临时文件")
            if hasattr(self, 'recognition_thread') and self.recognition_thread:
                self.recognition_thread.join(timeout=40.0)
                if self.recognition_thread.is_alive():
                    self.logger.warning("语音识别线程未正常结束")
                else:
                    self.logger.info("语音识别线程已正常结束")
                self.recognition_thread = None
            self.logger.info("程序退出清理完成")
        except Exception as e:
            self.logger.error(f"程序退出清理失败: {e}", exc_info=True)

    def handle_signal(self, signum, frame):
        self.logger.error(f"收到信号 {signum}，执行清理操作")
        self.cleanup_on_exit()
        sys.exit(1)

    def _cleanup_after_stop(self, resume_normal_playback):
        """停止跟读后的清理逻辑，清理资源并重置状态"""
        try:
            # 清理音频相关资源
            self._cleanup_audio_resources()

            # 重置播放和跟读相关状态
            self.is_playing = False
            self.is_following_active = False
            self.is_playing_or_recording = False
            self.has_moved = False
            self._retry_count = 0
            self.current_segment = 0
            self.paused_segment = None
            self.paused_position = None
            self.current_position = 0
            self.paused_file = None

            # 重置界面元素
            self.play_button.config(text="播放")
            self.progress_scale.set(0)
            self.time_label.config(text="00:00 / 00:00")
            self.follow_text.insert('end', "跟读已停止\n")
            self.follow_text.see('end')

            # 取消进度更新定时器
            if hasattr(self, 'update_timer') and self.update_timer:
                self.root.after_cancel(self.update_timer)
                self.update_timer = None

            # 取消跟读暂停定时器（如果存在）
            if hasattr(self, '_follow_pause_timer') and self._follow_pause_timer:
                self.root.after_cancel(self._follow_pause_timer)
                self._follow_pause_timer = None

            # 日志记录清理完成
            self.logger.info("停止跟读，清理所有状态")

            # 如果需要恢复普通播放模式
            if resume_normal_playback and self.current_playlist:
                self.logger.info("停止跟读后，恢复普通播放模式")
                self.current_position = 0  # 从头开始播放
                self.paused_file = None
                self.paused_position = None
                self.play_current_track()  # 调用播放当前曲目的方法
            else:
                self.logger.info("停止跟读，不恢复普通播放模式")

            # 更新状态信息
            self.update_status("跟读已停止", 'info')

        except Exception as e:
            self.logger.error(f"停止跟读清理失败: {e}")
            self.update_status(f"停止跟读清理失败: {str(e)}", 'error')
            self._reset_playback_state()  # 发生异常时重置状态

    def _resume_normal_playback(self):
        """改进的恢复普通播放功能"""
        try:
            if not self.current_playlist:
                return

            # 完全清理资源
            self._cleanup_audio_resources()

            # 重新加载并播放
            current_file = self.current_playlist[self.current_index]
            try:
                # 设置音量
                pygame.mixer.music.set_volume(self._volume / 100.0)
                # 异步加载和播放音频
                threading.Thread(target=self._load_and_play_audio, args=(current_file, self.current_position), daemon=True).start()

                self.is_playing = True
                self.play_button.config(text="暂停")
                self.logger.info(f"恢复播放，当前进度: {self.format_time(self.current_position)}")  # 添加日志

                # 立即更新字幕（将秒转换为毫秒）
                if self.subtitles:
                    current_pos_ms = self.current_position * 1000  # 转换为毫秒
                    subtitle = self._find_subtitle_optimized(current_pos_ms)
                    if subtitle:
                        self._update_subtitle_display(subtitle)

                # 更新显示
                self.update_info_label()
                total_length = self.get_current_audio_length()
                self.logger.info(f"音频总长度: {self.format_time(total_length)}")  # 添加日志
                if total_length > 0:
                    progress = (self.current_position / total_length) * 100
                    self.progress_scale.set(progress)
                self.time_label.config(
                    text=f"{self.format_time(self.current_position)} / {self.format_time(total_length)}")

                # 启动进度更新
                if not self.is_seeking:
                    self.update_timer = self.root.after(600, self.update_progress)

            except Exception as e:
                self.logger.error(f"加载音频失败: {e}")
                self.update_status("加载音频失败", 'error')
                self.is_playing = False  # 重置播放状态
                self.is_following_active = False  # 跟读流程需取消
                self.play_button.config(text="播放")  # 更新按钮状态

        except Exception as e:
            self.logger.error(f"恢复普通播放失败: {e}")
            self.update_status("恢复普通播放失败", 'error')
            self.is_playing = False  # 重置播放状态
            self.is_following_active = False  # 跟读流程需取消
            self.play_button.config(text="播放")  # 更新按钮状态

    def calculate_improved_similarity(self, text1, text2):
        """改进的文本相似度计算"""
        try:
            # 文本预处理
            def preprocess(text):
                # 转小写，去除标点
                text = re.sub(r'[^\w\s]', '', text.lower())
                # 分词
                return text.split()

            words1 = preprocess(text1)
            words2 = preprocess(text2)

            if not words1 or not words2:
                return 0

            # 计算词级别匹配
            matches = 0
            total_words = len(words1)

            for w1 in words1:
                if w1 in words2:
                    matches += 1

            # 考虑词序
            order_bonus = 0
            for i in range(len(words1) - 1):
                if i < len(words2) - 1:
                    if words1[i] == words2[i] and words1[i + 1] == words2[i + 1]:
                        order_bonus += 0.5

            # 计算最终得分
            base_score = (matches / total_words) * 100
            final_score = min(100, base_score + order_bonus)

            return final_score

        except Exception as e:
            self.logger.error(f"计算相似度失败: {e}")
            return 0

    def get_feedback(self, similarity):
        """根据相似度生成更详细的反馈"""
        if (similarity >= 90):
            return "★★★★★ 太棒了！发音非常准确！"
        elif (similarity >= 80):
            return "★★★★☆ 非常好！继续保持！"
        elif (similarity >= 70):
            return "★★★☆☆ 不错！还可以更好！"
        elif (similarity >= 60):
            return "★★☆☆☆ 基本正确，需要多练习"
        elif (similarity >= 50):
            return "★☆☆☆☆ 继续努力，重点注意发音"
        else:
            return "☆☆☆☆☆ 加油，建议多听多练"

    def show_about(self):
        """显示关于信息"""
        try:
            about_window = tk.Toplevel(self.root)
            about_window.title("关于")
            about_window.geometry("300x200")

            about_label = ttk.Label(about_window,
                                    text="""英语语感听说助手\n版本: 1.0\n作者: 林溪木\n日期: 2025-02-01\n每天早晚各半小时，努力争取3个月开口说\n内含录音、录屏、截屏、录音识别检测发音等功能""",
                                    padding=10)
            about_label.pack(expand=True, fill=tk.BOTH)

        except Exception as e:
            self.update_status(f"显示关于信息失败: {str(e)}", 'error')

    def export_playlist(self):
        """导出播放列表"""
        try:
            if not self.current_playlist:
                self.update_status("当前没有播放列表", 'warning')
                return

            file_path = filedialog.asksaveasfilename(
                defaultextension=".m3u",
                filetypes=[("M3U Playlist", "*.m3u"), ("All files", "*.*")]
            )

            if file_path:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write("#EXTM3U\n")  # M3U 文件头
                    for file in self.current_playlist:
                        f.write(file + '\n')

                self.update_status("播放列表导出成功", 'success')

        except Exception as e:
            self.update_status(f"导出播放列表失败: {str(e)}", 'error')

    def import_playlist(self):
        """导入播放列表"""
        try:
            file_path = filedialog.askopenfilename(
                defaultextension=".m3u",
                filetypes=[("M3U Playlist", "*.m3u"), ("All files", "*.*")]
            )

            if file_path:
                files = []
                with open(file_path, 'r', encoding='utf-8') as f:
                    for line in f:
                        line = line.strip()
                        if line and not line.startswith('#'):
                            if os.path.exists(line):  # 检查文件是否存在
                                files.append(line)
                            else:
                                self.logger.warning(f"播放列表中的文件不存在: {line}")

                # 过滤掉不存在的文件
                files = [f for f in files if os.path.exists(f)]

                # 只有当成功导入至少一个文件时才更新播放列表
                if files:
                    self.current_playlist = files
                    self.current_index = 0
                    self.play_current_track()
                    self.update_status("播放列表导入成功", 'success')

        except Exception as e:
            self.update_status(f"导入播放列表失败: {str(e)}", 'error')

    def toggle_favorite(self):
        """切换收藏状态"""
        try:
            if not self.current_playlist or self.current_index >= len(self.current_playlist):
                self.update_status("没有可收藏的音频", 'warning')
                return

            current_file = self.current_playlist[self.current_index]

            if current_file in self.favorites:
                self.favorites.remove(current_file)
                self.update_status("已取消收藏", 'info')
            else:
                self.favorites.add(current_file)
                self.update_status("已添加到收藏", 'success')

            # 保存收藏列表
            self.save_favorites()

        except Exception as e:
            self.update_status(f"收藏操作失败: {str(e)}", 'error')

    def save_favorites(self):
        """保存收藏列表"""
        try:
            favorites_file = os.path.join(self.config_dir, 'favorites.json')
            with open(favorites_file, 'w', encoding='utf-8') as f:
                json.dump(list(self.favorites), f, ensure_ascii=False, indent=2)
        except Exception as e:
            self.logger.error(f"保存收藏失败: {e}")

    # 暂时未使用
    def update_wave_display(self):
        """改进的波形显示更新功能"""
        try:
            if not self.is_playing or not self.current_playlist:
                return

            current_file = self.current_playlist[self.current_index]

            # 检查缓存
            if current_file not in self._audio_cache:
                # 读取音频数据
                with wave.open(current_file, 'rb') as wf:
                    signal = wf.readframes(-1)
                    signal = np.frombuffer(signal, dtype=np.int16)

                    # 计算波形数据
                    chunks = np.array_split(signal, self.wave_canvas.winfo_width())
                    peaks = [abs(chunk).max() for chunk in chunks]

                    # 缓存波形数据
                    self._audio_cache[current_file] = peaks

            # 绘制波形
            self.wave_canvas.delete('all')
            peaks = self._audio_cache[current_file]

            # 获取当前播放位置
            position = pygame.mixer.music.get_pos() / 1000.0
            total_length = self.get_current_audio_length()
            position_ratio = position / total_length

            # 绘制波形和播放位置指示器
            height = self.wave_canvas.winfo_height()
            for i, peak in enumerate(peaks):
                x = i
                y = height // 2
                amplitude = (peak / 32768.0) * (height // 2)

                # 区分已播放和未播放部分
                if i < len(peaks) * position_ratio:
                    color = '#4CAF50'  # 已播放部分为绿色
                else:
                    color = '#9E9E9E'  # 未播放部分为灰色

                self.wave_canvas.create_line(x, y - amplitude, x, y + amplitude, fill=color)

            # 绘制播放位置指示线
            pos_x = int(len(peaks) * position_ratio)
            self.wave_canvas.create_line(pos_x, 0, pos_x, height, fill='red', width=2)

        except Exception as e:
            print(f"更新波形显示失败: {e}")

    def update_stats(self):
        """更新播放统计"""
        try:
            if self.is_playing:
                current_file = self.current_playlist[self.current_index]
                self.stats['played_files'].add(current_file)
                self.stats['last_played'] = current_file
                self.stats['total_play_time'] += 0.1  # 每100ms更新一次

            # 每分钟保存一次统计数据
            self.root.after(60000, self.save_stats)

        except Exception as e:
            self.logger.error(f"更新统计失败: {e}")

    def save_stats(self):
        """保存播放统计"""
        try:
            stats_file = os.path.join(self.config_dir, 'stats.json')
            stats_data = {
                'total_play_time': self.stats['total_play_time'],
                'played_files': list(self.stats['played_files']),
                'last_played': self.stats['last_played'],
                'last_update': time.strftime('%Y-%m-%d %H:%M:%S')
            }

            with open(stats_file, 'w', encoding='utf-8') as f:
                json.dump(stats_data, f, ensure_ascii=False, indent=2)

        except Exception as e:
            self.logger.error(f"保存统计失败: {e}")

    def create_context_menu(self):
        """改进的右键菜单创建功能"""
        try:
            self.context_menu = tk.Menu(self.root, tearoff=0)

            # 文件夹树的右键菜单
            self.folder_menu = tk.Menu(self.root, tearoff=0)
            self.folder_menu.add_command(label="播放", command=self.play_selected_item)
            self.folder_menu.add_command(label="添加到收藏", command=self.add_to_favorites)
            self.folder_menu.add_separator()
            self.folder_menu.add_command(label="重命名", command=self.rename_item)
            self.folder_menu.add_command(label="删除", command=self.remove_selected_item)

            # 绑定右键菜单
            self.folder_tree.bind("<Button-3>", self.show_context_menu)

        except Exception as e:
            self.update_status(f"创建右键菜单失败: {str(e)}", 'error')

    def show_context_menu(self, event):
        """改进的右键菜单显示功能"""
        try:
            # 获取点击的项目
            item = self.folder_tree.identify('item', event.x, event.y)
            if item:
                # 选中被点击的项目
                self.folder_tree.selection_set(item)
                # 显示菜单
                self.folder_menu.post(event.x_root, event.y_root)
        except Exception as e:
            self.update_status(f"显示右键菜单失败: {str(e)}", 'error')

    def rename_item(self):
        """改进的重命名功能"""
        try:
            selected = self.folder_tree.selection()
            if not selected:
                return

            item = selected[0]
            old_name = self.folder_tree.item(item)['text']

            # 创建重命名对话框
            dialog = tk.Toplevel(self.root)
            dialog.title("重命名")
            dialog.geometry("300x100")

            ttk.Label(dialog, text="新名称:").pack(pady=5)
            entry = ttk.Entry(dialog)
            entry.insert(0, old_name)
            entry.pack(pady=5)
            entry.select_range(0, tk.END)

            def do_rename():
                new_name = entry.get()
                if new_name and new_name != old_name:
                    try:
                        # 更新树形视图
                        self.folder_tree.item(item, text=new_name)

                        # 如果是文件夹，更新文件夹字典
                        if item in self.folders:
                            folder_info = self.folders[item]
                            new_path = os.path.join(os.path.dirname(folder_info['path']), new_name)
                            os.rename(folder_info['path'], new_path)
                            folder_info['path'] = new_path

                        self.save_settings()
                        self.update_status(f"重命名成功: {new_name}", 'success')
                    except Exception as e:
                        self.update_status(f"重命名失败: {str(e)}", 'error')

                dialog.destroy()

            ttk.Button(dialog, text="确定", command=do_rename).pack(side=tk.LEFT, padx=20)
            ttk.Button(dialog, text="取消", command=dialog.destroy).pack(side=tk.RIGHT, padx=20)

            # 设置焦点并绑定回车键
            entry.focus_set()
            entry.bind('<Return>', lambda e: do_rename())

        except Exception as e:
            self.update_status(f"重命名操作失败: {str(e)}", 'error')

    def _serialize_folder_data(self):
        """序列化文件夹数据，处理不可序列化的内容"""
        serializable_folders = {}
        for folder_id, folder_info in self.folders.items():
            serializable_folders[str(folder_id)] = {
                'path': folder_info['path'],
                'files': list(folder_info['files']),  # 确保是列表
                'expanded': bool(folder_info['expanded'])  # 确保是布尔值
            }
        return serializable_folders

    def _deserialize_folder_data(self, data):
        """反序列化文件夹数据"""
        folders = {}
        for folder_id, folder_info in data.items():
            folders[folder_id] = {
                'path': str(folder_info['path']),
                'files': list(folder_info['files']),
                'expanded': bool(folder_info['expanded'])
            }
        return folders

    def _encode_json_safe(self, obj):
        """安全的JSON编码处理"""
        if isinstance(obj, set):
            return list(obj)
        if isinstance(obj, bytes):
            return obj.decode('utf-8')
        return str(obj)

    def save_settings(self):
        """改进的设置保存功能，确保文件夹持久化"""
        try:
            settings = {
                'folders': {},  # 用于存储处理后的文件夹数据
                'volume': self._volume,
                # 'speed': self.speed_scale.get(),
                'subtitle_offset': self._playback.get('time_offset', 0),
                'loop_count': self.loop_count.get(),
                'play_mode': self.mode_var.get(),
                'max_segment_repeats': self.max_segment_repeats  # 添加跟读次数
            }

            # 遍历 self.folders，将每个文件夹的信息序列化
            for tree_id, folder_info in self.folders.items():
                folder_path = folder_info['path']
                settings['folders'][folder_path] = {  # 使用文件夹路径作为键
                    'path': folder_path,
                    'files': folder_info['files'],
                    'expanded': folder_info['expanded']
                }

            # 保存到文件
            with open(self.settings_file, 'w', encoding='utf-8') as f:
                json.dump(settings, f, ensure_ascii=False, indent=2)

            self.logger.info(f"设置已保存到 {self.settings_file}, 跟读次数: {self.max_segment_repeats}")
            self.update_status("设置已保存", 'success')
            return True

        except Exception as e:
            self.logger.error(f"保存设置失败: {e}")
            self.update_status(f"保存设置失败: {str(e)}", 'error')
            return False

    def delete_settings(self):
        """删除设置文件"""
        try:
            if messagebox.askyesno("确认", "确定要删除所有设置文件吗？"):
                files_to_delete = [
                    self.settings_file,
                    self.state_file,
                    self.history_file,
                    self.favorites_file
                ]

                for file in files_to_delete:
                    if os.path.exists(file):
                        os.remove(file)

                self.update_status("所有设置文件已删除", 'success')
                messagebox.showinfo("成功", "设置已删除，程序将重新启动")
                self.root.after(1000, self.restart_application)
        except Exception as e:
            self.update_status(f"删除设置失败: {str(e)}", 'error')

    def restart_application(self):
        """重启应用程序"""
        python = sys.executable
        os.execl(python, python, *sys.argv)

    def clean_settings(self):
        """清理设置文件"""
        try:
            if os.path.exists(self.settings_file):
                os.remove(self.settings_file)
                self.update_status("设置文件已删除", 'success')
            if os.path.exists(self.state_file):
                os.remove(self.state_file)
                self.update_status("状态文件已删除", 'success')
            return True
        except Exception as e:
            self.update_status(f"清理设置失败: {str(e)}", 'error')
            return False

    def add_to_favorites(self):
        """改进的添加收藏功能"""
        try:
            selected = self.folder_tree.selection()
            if not selected:
                return

            item = selected[0]

            # 如果是文件夹，添加所有音频文件
            if item in self.folders:
                for file_path in self.folders[item]['files']:
                    self.favorites.add(file_path)
                self.update_status(f"文件夹已添加到收藏", 'success')
            else:
                # 如果是单个文件
                parent = self.folder_tree.parent(item)
                if parent in self.folders:
                    file_name = self.folder_tree.item(item)['text']
                    for file_path in self.folders[parent]['files']:
                        if os.path.basename(file_path) == file_name:
                            self.favorites.add(file_path)
                            self.update_status(f"文件已添加到收藏", 'success')
                            break

            # 保存收藏状态
            self.save_player_state()

        except Exception as e:
            self.update_status(f"添加收藏失败: {str(e)}", 'error')

    def get_audio_info(self, file_path):
        """改进的音频信息获取功能"""
        try:
            info = {
                'duration': 0,
                'channels': 0,
                'sample_rate': 0,
                'bit_rate': 0,
                'format': None
            }

            # 尝试使用wave模块获取信息
            try:
                with wave.open(file_path, 'rb') as wf:
                    info['channels'] = wf.getnchannels()
                    info['sample_rate'] = wf.getframerate()
                    frames = wf.getnframes()
                    info['duration'] = frames / float(info['sample_rate'])
                    info['format'] = 'wav'
            except:
                # 如果不是wav文件，使用pygame获取时长
                audio = pygame.mixer.Sound(file_path)
                info['duration'] = audio.get_length()
                info['format'] = os.path.splitext(file_path)[1][1:]

            return info

        except Exception as e:
            print(f"获取音频信息失败: {e}")
            return None

    def show_current_subtitle(self, subtitle):
        """改进的字幕显示功能"""
        try:
            # 清空之前的文本
            self.follow_text.delete('1.0', 'end')

            # 显示段落信息
            self.follow_text.insert('end',
                                    f"当前段落: {self.current_segment + 1}/{len(self.subtitles)}\n", 'title')

            # 显示时间信息，使用新的 format_time_ms 方法
            self.follow_text.insert('end',
                                    f"时间: {self.format_time_ms(subtitle['start_time'])} -> "
                                    f"{self.format_time_ms(subtitle['end_time'])}\n\n",
                                    'time')

            # 显示英文
            if subtitle.get('en_text'):
                # 确保英文文本末尾有换行符
                en_text = subtitle['en_text'].rstrip() + '\n\n'  # 移除末尾多余空格并添加换行
                self.follow_text.insert('end', en_text, 'en')

            # 显示中文
            if subtitle.get('cn_text'):
                # 确保中文文本末尾有换行符
                cn_text = subtitle['cn_text'].rstrip() + '\n\n'  # 移除末尾多余空格并添加换行
                self.follow_text.insert('end', cn_text, 'cn')

            # 确保显示最新内容
            self.follow_text.see('end')
        except Exception as e:
            self.logger.error(f"显示字幕失败: {e}")

    def expand_folder(self, folder_id):
        """展开文件夹"""
        try:
            if folder_id not in self.folders:
                self.logger.warning(f"无效的文件夹ID: {folder_id}")
                return

            folder_info = self.folders[folder_id]
            folder_info['expanded'] = True

            # 清空现有子节点
            for child in self.folder_tree.get_children(folder_id):
                self.folder_tree.delete(child)

            # 添加文件节点
            for file_path in folder_info['files']:
                file_name = os.path.basename(file_path)
                duration = self.get_audio_duration(file_path)
                self.folder_tree.insert(folder_id, "end", text=file_name, values=(file_path, duration))
                self.logger.debug(f"添加文件节点: {file_name}, 路径: {file_path}, 时长: {duration}")

            self.save_settings()
            self.logger.info(f"已展开文件夹: {self.folder_tree.item(folder_id)['text']}")
        except Exception as e:
            self.logger.error(f"展开文件夹失败: {e}", exc_info=True)

    def collapse_folder(self, folder_id):
        """收起文件夹"""
        try:
            if folder_id not in self.folders:
                self.logger.warning(f"无效的文件夹ID: {folder_id}")
                return

            folder_info = self.folders[folder_id]
            folder_info['expanded'] = False

            # 清空子节点
            for child in self.folder_tree.get_children(folder_id):
                self.folder_tree.delete(child)

            self.save_settings()
            self.logger.info(f"已收起文件夹: {self.folder_tree.item(folder_id)['text']}")
        except Exception as e:
            self.logger.error(f"收起文件夹失败: {e}", exc_info=True)

    def get_audio_duration(self, file_path):
        """获取音频文件时长"""
        try:
            pygame.mixer.music.load(file_path)
            audio = pygame.mixer.Sound(file_path)
            duration = audio.get_length()
            minutes = int(duration // 60)
            seconds = int(duration % 60)
            return f"{minutes}:{seconds:02d}"
        except:
            return "未知"

    def play_audio_file(self, item):
        """播放选中的音频文件"""
        try:
            self.logger.info(f"双击播放音频文件: {item}")
            parent = self.folder_tree.parent(item)
            if parent and parent in self.folders:
                file_name = self.folder_tree.item(item)['text']
                values = self.folder_tree.item(item).get('values', [])
                self.logger.debug(f"文件节点值: {values}")

                if values and len(values) > 0:
                    file_path = values[0]
                    # 规范化文件路径
                    file_path = os.path.normpath(os.path.abspath(file_path))
                    self.logger.debug(f"规范化文件路径: {file_path}")

                    if not os.path.exists(file_path):
                        self.logger.warning(f"文件路径不存在: {file_path}")
                        self.update_status(f"文件不存在: {file_name}", 'warning')
                        return

                    folder_files = self.folders[parent]['files']
                    # 规范化文件夹中的文件路径
                    normalized_folder_files = [os.path.normpath(os.path.abspath(f)) for f in folder_files]
                    self.logger.debug(f"文件夹文件列表: {normalized_folder_files}")

                    if file_path in normalized_folder_files:
                        self.logger.info(f"找到音频文件路径: {file_path}")
                        # 检查是否是当前正在播放的文件
                        if (self.current_playlist and
                                self.current_index < len(self.current_playlist) and
                                self.current_playlist[self.current_index] == file_path and
                                pygame.mixer.music.get_busy()):
                            self.logger.info(f"当前文件已在播放，忽略重复请求: {file_path}")
                            self.update_status(f"文件已在播放: {file_name}", 'info')
                            return

                        # 停止当前播放（如果有）
                        if pygame.mixer.music.get_busy():
                            pygame.mixer.music.stop()
                            pygame.mixer.music.unload()
                            self.logger.info("已停止当前播放")

                        # 播放新文件
                        self.current_playlist = normalized_folder_files
                        self.current_index = normalized_folder_files.index(file_path)
                        self.current_loop = 0
                        self.current_position = 0  # 只有在新播放时才重置位置
                        self.paused_file = None  # 清理暂停状态
                        self.paused_position = None
                        self.selected_file = file_path  # 更新选中文件
                        self.play_current_track()
                        self.update_status(f"开始播放: {file_name}", 'success')
                    else:
                        self.logger.warning(f"文件路径不在文件夹中: {file_path}")
                        self.update_status("选中的文件不在文件夹中", 'warning')
                else:
                    self.logger.warning(f"文件节点缺少路径信息: {item}, 文件名: {file_name}")
                    self.update_status(f"文件路径不可用: {file_name}", 'warning')
            else:
                self.logger.warning(f"无效的文件节点或父文件夹: {item}")
                self.update_status("无法找到文件所属文件夹", 'warning')

        except Exception as e:
            self.logger.error(f"播放音频文件失败: {e}", exc_info=True)
            self.update_status(f"播放失败: {str(e)}", 'error')

    def get_current_audio_length(self):
        """获取当前音频文件的总长度"""
        if not self.current_playlist:
            return 0
        try:
            audio = pygame.mixer.Sound(self.current_playlist[self.current_index])
            return audio.get_length()
        except:
            return 0

    def format_time(self, time_value, is_milliseconds=False):
        """
        格式化时间为 HH:MM:SS.mmm 或 MM:SS.mmm，支持秒或毫秒输入。

        参数:
            time_value (float or int): 时间值，单位为秒或毫秒。
            is_milliseconds (bool): 如果为 True，time_value 单位为毫秒；否则为秒。

        返回:
            str: 格式化后的时间字符串，例如 "01:23:45.678" 或 "23:45.678"。
        """
        try:
            if time_value is None or time_value < 0:
                self.logger.error("无效的时间值")
                return "00:00.000"

            # 如果输入是秒，转换为毫秒
            if not is_milliseconds:
                time_value = time_value * 1000

            # 确保时间值为整数（毫秒）
            time_value = int(time_value)

            # 计算小时、分钟、秒和毫秒
            hours = int(time_value // (3600 * 1000))
            minutes = int((time_value % (3600 * 1000)) // (60 * 1000))
            seconds = int((time_value % (60 * 1000)) // 1000)
            milliseconds = int(time_value % 1000)

            # 格式化时间字符串
            if hours > 0:
                return f"{hours:02d}:{minutes:02d}:{seconds:02d}.{milliseconds:03d}"
            else:
                return f"{minutes:02d}:{seconds:02d}.{milliseconds:03d}"

        except Exception as e:
            self.logger.error(f"格式化时间失败: {e}, 输入值: {time_value}, 单位: {'ms' if is_milliseconds else 's'}")
            return "00:00.000"

    def format_time_ms(self, time_value, is_milliseconds=False):
        """
        将时间戳格式化为 HH:MM:SS.mmm，支持毫秒级显示。

        参数:
            time_value (float or int): 时间值，单位为秒或毫秒。
            is_milliseconds (bool): 如果为 True，time_value 单位为毫秒；否则为秒。

        返回:
            str: 格式化后的时间字符串，例如 "01:23:45.678" 或 "23:45.678"。
        """
        try:
            if time_value is None or time_value < 0:
                self.logger.error("无效的时间值")
                return "00:00.000"

            # 如果输入是秒，转换为毫秒
            if not is_milliseconds:
                time_value = time_value * 1000

            # 确保时间值为整数（毫秒）
            time_value = int(time_value)

            # 计算小时、分钟、秒和毫秒
            hours = int(time_value // (3600 * 1000))
            minutes = int((time_value % (3600 * 1000)) // (60 * 1000))
            seconds = int((time_value % (60 * 1000)) // 1000)
            milliseconds = int(time_value % 1000)

            # 格式化时间字符串
            if hours > 0:
                return f"{hours:02d}:{minutes:02d}:{seconds:02d}.{milliseconds:03d}"
            else:
                return f"{minutes:02d}:{seconds:02d}.{milliseconds:03d}"

        except Exception as e:
            self.logger.error(f"格式化时间失败: {e}, 输入值: {time_value}, 单位: {'ms' if is_milliseconds else 's'}")
            return "00:00.000"

    def load_subtitles(self, audio_file):
        """改进的字幕加载功能，支持时间戳索引和中英分离"""
        try:
            srt_path = os.path.splitext(audio_file)[0] + '.srt'
            if not os.path.exists(srt_path):
                self.subtitles = []
                self.logger.warning(f"字幕文件不存在: {srt_path}")
                self.update_status(f"字幕文件不存在: {srt_path}", 'warning')
                return False

            # 读取文件内容并检测编码
            with open(srt_path, 'rb') as f:
                raw_data = f.read()
                encoding = chardet.detect(raw_data)['encoding'] or 'utf-8'
            with open(srt_path, 'r', encoding=encoding) as f:
                content = f.read().strip()

            # 按空行分割字幕块
            subtitle_blocks = re.split(r'\n\n+', content)
            self.subtitles = []

            for block in subtitle_blocks:
                lines = block.strip().split('\n')
                if len(lines) >= 3:
                    # 解析序号
                    index = int(lines[0])

                    # 解析时间轴
                    time_match = re.match(r'(\d{2}:\d{2}:\d{2},\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2},\d{3})', lines[1])
                    if not time_match:
                        continue

                    start_time = self.parse_srt_time(time_match.group(1))  # 返回秒
                    end_time = self.parse_srt_time(time_match.group(2))  # 返回秒

                    # 应用字幕偏移（单位：秒）
                    offset = self.subtitle_offset or 0
                    start_time += offset
                    end_time += offset

                    # 分离中英文
                    remaining_lines = lines[2:]
                    en_text = []
                    cn_text = []

                    for line in remaining_lines:
                        # 移除所有可能的提示词
                        if line.startswith('英文字幕：'):
                            en_text.append(line.replace('英文字幕：', '').strip())
                        elif line.startswith('中文字幕：'):
                            cn_text.append(line.replace('中文字幕：', '').strip())
                        elif line.startswith('英文：'):
                            en_text.append(line.replace('英文：', '').strip())
                        elif line.startswith('中文：'):
                            cn_text.append(line.replace('中文：', '').strip())
                        elif re.search(r'[\u4e00-\u9fff]', line):
                            cn_text.append(line.strip())
                        else:
                            en_text.append(line.strip())

                    self.subtitles.append({
                        'index': index,
                        'start_time': start_time,  # 秒
                        'end_time': end_time,  # 秒
                        'en_text': ' '.join(en_text),
                        'cn_text': ' '.join(cn_text)
                    })

            if not self.subtitles:
                self.logger.warning("字幕数据为空")
                self.update_status("字幕数据为空", 'warning')
                return False

            # 确保字幕按 start_time 排序
            self.subtitles = sorted(self.subtitles, key=lambda x: float(x['start_time']))
            self._subtitles_sorted = True

            # 构建时间戳索引（单位：毫秒）
            self._subtitle_index = {}
            for i, subtitle in enumerate(self.subtitles):
                start_time_ms = int(float(subtitle['start_time']) * 1000)  # 转换为毫秒
                end_time_ms = int(float(subtitle['end_time']) * 1000)  # 转换为毫秒
                for t in range(start_time_ms, end_time_ms + 1, 100):  # 每 100 毫秒一个索引
                    self._subtitle_index[t] = i

            self.logger.info(f"字幕加载成功，条目数: {len(self.subtitles)}")
            self.update_status(f"字幕加载成功: {srt_path}", 'info')
            return True

        except Exception as e:
            self.logger.error(f"加载字幕失败: {e}")
            self.update_status(f"加载字幕失败: {str(e)}", 'error')
            return False

    def _parse_srt_file(self, srt_file):
        """解析 SRT 文件并返回字幕数据"""
        subtitles = []
        try:
            with open(srt_file, 'r', encoding='utf-8') as f:
                content = f.read().strip().split('\n\n')
                for block in content:
                    if not block.strip():
                        continue
                    lines = block.strip().split('\n')
                    if len(lines) < 3:
                        continue
                    index = lines[0].strip()
                    if not index.isdigit():
                        continue
                    time_line = lines[1].strip()
                    time_match = re.match(r'(\d{2}:\d{2}:\d{2},\d{3}) --> (\d{2}:\d{2}:\d{2},\d{3})', time_line)
                    if not time_match:
                        continue
                    start_time_str, end_time_str = time_match.groups()
                    start_time_ms = self._parse_srt_time_to_ms(start_time_str)
                    end_time_ms = self._parse_srt_time_to_ms(end_time_str)
                    text = '\n'.join(lines[2:]).strip()
                    subtitles.append({
                        'index': int(index),
                        'start_time': start_time_ms,
                        'end_time': end_time_ms,
                        'text': text
                    })
            return subtitles
        except Exception as e:
            self.logger.error(f"解析 SRT 文件失败: {e}")
            return []

    def parse_srt_time(self, time_string):
        """解析 SRT 时间格式"""
        try:
            hours, mins, rest = time_string.split(':')
            seconds, milliseconds = rest.split(',')

            total_ms = (int(hours) * 3600 * 1000 +
                        int(mins) * 60 * 1000 +
                        int(seconds) * 1000 +
                        int(milliseconds))
            return total_ms

        except Exception as e:
            print(f"解析时间失败: {e}")
            return 0

    def _parse_srt_time_to_ms(self, time_str):
        """将 SRT 时间格式转换为毫秒"""
        try:
            hours, minutes, seconds, milliseconds = map(int, re.split('[:,]', time_str))
            total_ms = (hours * 3600 + minutes * 60 + seconds) * 1000 + milliseconds
            return total_ms
        except Exception as e:
            self.logger.error(f"解析 SRT 时间失败: {e}")
            return 0

    def handle_playback_ended(self):
        """改进的播放结束处理"""
        try:
            self.logger.info("进入 handle_playback_ended")

            # 取消现有的定时器
            for timer in ['update_timer', '_check_timer', '_playback_delay_timer']:
                if hasattr(self, timer) and getattr(self, timer):
                    self.root.after_cancel(getattr(self, timer))
                    setattr(self, timer, None)

            # 重置播放状态
            self.is_playing = False  # 确保播放状态被标记为停止
            self._cleanup_audio_resources()  # 清理音频资源，避免资源泄漏

            # 如果是从编辑模式恢复，禁用自动下一曲逻辑，继续播放当前曲目
            if getattr(self, 'is_editing_recovery', False):
                self.logger.info("编辑模式恢复，禁用自动下一曲逻辑，继续播放当前曲目")
                self.current_position = max(0, self.current_position)
                total_length = self.get_current_audio_length()
                if total_length > 0:
                    self.current_position = min(self.current_position, total_length)
                self.logger.info(f"编辑模式恢复，当前曲目继续播放，位置: {self.current_position}秒")
                self.play_current_track()
                return

            # 如果正在跟读模式
            if self.is_following:
                self.logger.info(f"跟读模式下，当前段落: {self.current_segment + 1}/{len(self.subtitles)}")

                # 确保重复次数被正确初始化
                if not hasattr(self, 'current_segment_repeat_count') or self.current_segment_repeat_count is None:
                    self.current_segment_repeat_count = 0

                # 检查是否需要重复当前段落
                if not self.is_manual_switch:
                    self.current_segment_repeat_count += 1
                    if self.current_segment_repeat_count < self.max_segment_repeats:
                        self.follow_text.insert('end', f"\n重复播放第 {self.current_segment + 1} 句 "
                                                       f"(第 {self.current_segment_repeat_count + 1}/{self.max_segment_repeats} 次)\n",
                                                'prompt')
                        self.play_segment()
                        return
                    else:
                        self.current_segment_repeat_count = 0  # 重置重复次数

                # 检查是否到达最后一个段落
                if self.current_segment >= len(self.subtitles) - 1:
                    self.current_loop += 1
                    if self.current_loop < self.loop_count.get():
                        self.current_segment = 0
                        self.current_segment_repeat_count = 0  # 重置重复次数
                        self.follow_text.insert('end', f"\n重新跟读第 {self.current_loop + 1} 次\n", 'title')
                        self.play_segment()
                    else:
                        # 当前曲目跟读完成，检查播放列表
                        if self.current_index < len(self.current_playlist) - 1:
                            self.current_index += 1
                            self.current_loop = 0
                            self.current_segment = 0
                            self.current_segment_repeat_count = 0  # 重置重复次数
                            self.current_position = 0
                            self.follow_text.insert('end', f"\n开始跟读下一个音频文件\n", 'title')
                            self.start_follow_reading()
                        else:
                            # 播放列表结束，停止跟读模式
                            self.stop_follow_reading()
                            self.current_index = 0
                            self.current_loop = 0
                            self.current_segment = 0
                            self.current_segment_repeat_count = 0  # 重置重复次数
                            self.current_position = 0
                            self.follow_text.insert('end', f"\n跟读模式结束，切换到普通播放模式\n", 'title')
                            self.play_current_track()
                else:
                    # 当前段落未结束，继续播放下一段
                    self.current_segment += 1
                    self.current_segment_repeat_count = 0  # 重置重复次数
                    self.follow_text.insert('end', f"\n=== 准备第 {self.current_segment + 1} 段 ===\n", 'prompt')
                    self.play_segment()
                return

            # 普通模式处理
            total_length = self.get_current_audio_length()
            max_loops = self.loop_count.get()
            self.logger.info(f"普通模式单次播放完成: 当前循环={self.current_loop}, 最大循环={max_loops}")

            current_file = os.path.basename(self.current_playlist[self.current_index])
            if self.current_loop < max_loops - 1:
                # 循环播放当前曲目
                self.current_loop += 1
                self.current_position = 0
                self.last_seek_position = 0  # 重置跳转位置
                self.last_update_time = time.time()
                pygame.mixer.music.load(self.current_playlist[self.current_index])
                pygame.mixer.music.play()
                self.is_playing = True
                self.info_label.config(text=f"当前播放: {current_file} ({self.current_loop + 1}/{max_loops})")
                self.progress_scale.set(0)  # 重置进度条
                self.time_label.config(text=f"{self.format_time(0)} / {self.format_time(total_length)}")
                self.logger.info(f"普通模式下，继续循环播放当前曲目，下一循环={self.current_loop + 1}")

                # 启动定时器
                self.update_timer = self.root.after(600, self.update_progress)
                self._check_timer = self.root.after(1000, self._start_playback_check)
                return

            # 当前曲目已循环完毕，重置循环计数
            self.current_loop = 0
            play_mode = self.mode_var.get()
            self.logger.info(f"播放模式: {play_mode}")

            # 增加播放计数
            self.audio_play_count += 1

            # 重置进度条和时间显示
            self.progress_scale.set(0)
            self.time_label.config(text=f"{self.format_time(0)} / {self.format_time(total_length)}")

            if play_mode == "sequential":
                if self.current_index < len(self.current_playlist) - 1:
                    self.current_index += 1
                    self.current_position = 0
                    self.logger.info("普通模式下，顺序播放，播放下一曲")
                    self.play_current_track()
                else:
                    self.stop()
                    self.logger.info("普通模式下，播放列表结束，停止播放")
            elif play_mode == "loop_one":
                self.current_position = 0
                self.logger.info("普通模式下，单曲无限循环，重新播放当前曲目")
                self.play_current_track()
            elif play_mode == "loop_all":
                if self.current_index < len(self.current_playlist) - 1:
                    self.current_index += 1
                else:
                    self.current_index = 0
                self.current_position = 0
                self.logger.info("普通模式下，列表循环，播放下一曲或重新开始")
                self.play_current_track()

        except Exception as e:
            self.logger.error(f"处理播放结束失败: {e}", exc_info=True)
            self.update_status(f"处理播放结束失败: {str(e)}", 'error')
            self.progress_scale.set(0)  # 确保异常时进度条重置
            self.time_label.config(text=f"{self.format_time(0)} / {self.format_time(total_length)}")

    def start_playback_delay(self):
        """启动播放延迟"""
        if not self.is_paused_for_delay:  # 避免重复启动
            self.is_paused_for_delay = True
            self.update_status("播放完毕，暂停10..", 'info')
            self.playback_delay_timer = self.root.after(10000, self.continue_playback_after_delay)  # 10秒延迟

    def continue_playback_after_delay(self):
        """延迟后继续播放"""
        self.is_paused_for_delay = False
        play_mode = self.mode_var.get()
        if play_mode in ["sequential", "loop_all"]:
            self.next_track()

    def _schedule_next_track(self):
        """调度下一曲播放"""
        if not self.is_paused_for_delay:
            self.is_paused_for_delay = True
            self.update_status("播放完毕，等待3秒...", 'info')
            self._playback_delay_timer = self.root.after(3000, self._play_next_after_delay)

    def _play_next_after_delay(self):
        """延迟后播放下一曲"""
        self.is_paused_for_delay = False
        self.current_index += 1
        if self.current_index >= len(self.current_playlist):
            if self.mode_var.get() == "loop_all":
                self.current_index = 0
            else:
                self.stop()
                return
        self.play_current_track()

    def update_subtitle(self):
        """改进的字幕更新功能"""
        if not self.is_playing or not self.subtitles:
            return

        try:
            current_pos = self.get_accurate_position()

            # 使用缓存优化查找
            subtitle = self._find_subtitle_optimized(current_pos, tolerance=200)
            if subtitle:
                self._update_subtitle_display(subtitle)

            # 继续更新
            if self.is_playing:
                self.root.after(20, self.update_subtitle)

        except Exception as e:
            self.logger.error(f"更新字幕失败: {e}")

    def _find_subtitle_optimized(self, current_pos_ms, tolerance=200):
        """优化字幕查找，结合缓存、二分查找、时间戳索引和动态偏移"""
        if not self.subtitles:
            self.logger.warning("字幕数据为空")
            return None

        # 应用动态偏移
        adjusted_pos_ms = current_pos_ms + getattr(self, 'subtitle_offset', 0)

        # 检查缓存
        if hasattr(self, '_last_subtitle') and self._last_subtitle:
            last_subtitle = self._last_subtitle
            start_time_ms = float(last_subtitle['start_time'])
            end_time_ms = float(last_subtitle['end_time'])
            if start_time_ms - tolerance <= adjusted_pos_ms <= end_time_ms + tolerance:
                self.logger.debug(f"使用缓存字幕，时间范围: {start_time_ms - tolerance}ms - {end_time_ms + tolerance}ms")
                return last_subtitle

        # 确保字幕按 start_time 排序，并在排序后重建时间戳索引
        if not hasattr(self, '_subtitles_sorted') or not self._subtitles_sorted:
            self.subtitles = sorted(self.subtitles, key=lambda x: float(x['start_time']))
            self._subtitles_sorted = True
            self.logger.info("字幕已按开始时间排序")
            # 重建时间戳索引
            self._subtitle_index = {}
            for i, subtitle in enumerate(self.subtitles):
                start_time_ms = int(float(subtitle['start_time']) // 100 * 100)  # 按 100ms 粒度索引
                self._subtitle_index[start_time_ms] = i
            self._last_subtitle = None  # 清空缓存

        # 使用时间戳索引查找
        if hasattr(self, '_subtitle_index'):
            index_key = int(adjusted_pos_ms // 100 * 100)
            index = self._subtitle_index.get(index_key)
            if index is not None:
                subtitle = self.subtitles[index]
                start_time_ms = float(subtitle['start_time'])
                end_time_ms = float(subtitle['end_time'])
                if start_time_ms - tolerance <= adjusted_pos_ms <= end_time_ms + tolerance:
                    self._last_subtitle = subtitle
                    self.logger.debug(f"通过索引找到字幕，时间范围: {start_time_ms - tolerance}ms - {end_time_ms + tolerance}ms")
                    return subtitle

        # 使用二分查找，查找可能的最早匹配位置
        start_times = [float(subtitle['start_time']) for subtitle in self.subtitles]
        index = bisect_left(start_times, adjusted_pos_ms - tolerance)

        # 从找到的索引开始，向后查找匹配的字幕
        closest_subtitle = None
        min_distance = float('inf')
        closest_index = -1
        for i in range(max(0, index - 1), len(self.subtitles)):
            subtitle = self.subtitles[i]
            start_time_ms = float(subtitle['start_time'])
            end_time_ms = float(subtitle['end_time'])
            if start_time_ms - tolerance <= adjusted_pos_ms <= end_time_ms + tolerance:
                self._last_subtitle = subtitle  # 更新缓存
                self.logger.debug(f"找到字幕，时间范围: {start_time_ms - tolerance}ms - {end_time_ms + tolerance}ms")
                return subtitle
            # 计算与当前时间的最小距离，用于边界情况
            distance = min(abs(start_time_ms - adjusted_pos_ms), abs(end_time_ms - adjusted_pos_ms))
            if distance < min_distance:
                min_distance = distance
                closest_subtitle = subtitle
                closest_index = i
            # 如果当前字幕的开始时间已经超过查找时间（考虑容差），则无需继续查找
            if start_time_ms > adjusted_pos_ms + tolerance:
                break

        # 如果未找到字幕，但存在最近的字幕，且距离在容差范围内，则返回最近的字幕
        if closest_subtitle and min_distance < tolerance * 2:
            self._last_subtitle = closest_subtitle
            self.logger.debug(f"未找到精确匹配字幕，返回最近的字幕，距离: {min_distance}ms，索引: {closest_index}")
            return closest_subtitle

        # 未找到字幕，清空缓存
        self._last_subtitle = None
        self.logger.debug(f"未找到字幕，当前时间: {adjusted_pos_ms}ms")
        return None

    def _update_subtitle_display(self, subtitle):
        """优化的字幕显示，防止重复显示和格式混乱"""
        if not subtitle:
            self.logger.warning("字幕数据为空，跳过显示")
            return

        try:
            # 清空当前字幕显示
            self.follow_text.delete('1.0', 'end')

            # 添加时间戳
            self.follow_text.insert('end',
                                    f"►{self.format_time(subtitle['start_time'], is_milliseconds=True)} - "
                                    f"{self.format_time(subtitle['end_time'], is_milliseconds=True)}◄\n\n")

            # 显示英文（蓝色）
            if subtitle.get('en_text'):
                self.follow_text.insert('end', subtitle['en_text'] + '\n', 'en')

            # 显示中文（绿色）
            if subtitle.get('cn_text'):
                self.follow_text.insert('end', subtitle['cn_text'] + '\n', 'cn')

            # 自动滚动到最新内容
            self.follow_text.see('end')

        except Exception as e:
            self.logger.error(f"显示字幕错误: {e}", exc_info=True)
            self.update_status(f"显示字幕失败: {str(e)}", 'error')

    def _update_cache(self, time_ms, subtitle):
        """更新字幕缓存"""
        self._subtitle_cache.update({
            'last_time': time_ms,
            'last_subtitle': subtitle,
            'last_index': subtitle['index']
        })

    def update_status(self, message, status_type='info'):
        """更新状态栏信息"""
        if not hasattr(self, '_status_timer'):
            self._status_timer = None

        # 取消之前的定时器
        if self._status_timer:
            self.root.after_cancel(self._status_timer)

        # 设置状态栏样式和消息
        style = self.STATUS_TYPES.get(status_type, self.STATUS_TYPES['info'])
        self.status_bar.config(text=message, foreground=style['fg'])

        # 设置自动清除定时器
        if style['timeout'] > 0:
            self._status_timer = self.root.after(
                style['timeout'],
                lambda: self.status_bar.config(text='', foreground='black')
            )

    def set_subtitle_offset(self, offset_ms, adjust=False, save=False):
        """设置或调整字幕偏移（单位：毫秒），并可选保存到文件"""
        try:
            if adjust:
                # 调整模式：累加偏移值
                self.subtitle_offset = (self.subtitle_offset or 0) + offset_ms / 1000.0  # 转换为秒并累加
                action = "调整"
            else:
                # 设置模式：直接设置偏移值
                self.subtitle_offset = offset_ms / 1000.0  # 转换为秒
                action = "设置"

            self.logger.info(f"{action}字幕偏移: {self.subtitle_offset:.3f}秒")
            self.update_status(f"字幕偏移已{action}为 {self.subtitle_offset:.3f}秒", 'info')

            # 重新加载字幕以应用偏移
            if self.current_playlist and self.current_index is not None:
                self.load_subtitles(self.current_playlist[self.current_index])
            else:
                self.update_status("未加载音频文件，无法应用字幕偏移", 'warning')
                return

            # 如果需要保存，则调用保存方法
            if save:
                self.save_subtitle_offset()

        except Exception as e:
            self.logger.error(f"{action}字幕偏移失败: {e}")
            self.update_status(f"{action}字幕偏移失败: {str(e)}", 'error')

    def save_subtitle_offset(self):
        """保存字幕偏移到字幕文件，并可选保存到配置文件"""
        try:
            if not self.current_playlist or self.current_index is None:
                self.update_status("未加载音频文件，无法保存字幕偏移", 'warning')
                return

            current_file = self.current_playlist[self.current_index]
            srt_path = os.path.splitext(current_file)[0] + '.srt'

            if not os.path.exists(srt_path):
                self.update_status(f"字幕文件不存在: {srt_path}", 'warning')
                return

            if not hasattr(self, 'subtitles') or not self.subtitles:
                self.update_status("未加载字幕数据，无法保存偏移", 'warning')
                return

            # 确保偏移量单位为秒
            offset = self.subtitle_offset or 0
            if abs(offset) > 3600:  # 检查偏移量是否合理（例如，限制在1小时内）
                self.update_status(f"偏移量 {offset:.3f}秒超出合理范围", 'error')
                return

            # 应用偏移到字幕数据
            updated_subtitles = []
            for subtitle in self.subtitles:
                updated_subtitle = subtitle.copy()
                # 确保时间单位一致（假设 subtitle['start_time'] 和 ['end_time'] 是秒）
                updated_subtitle['start_time'] = subtitle['start_time'] + offset
                updated_subtitle['end_time'] = subtitle['end_time'] + offset
                # 验证时间范围
                if updated_subtitle['start_time'] < 0 or updated_subtitle['end_time'] < 0:
                    self.update_status("偏移后时间小于0，无效调整", 'error')
                    return
                updated_subtitles.append(updated_subtitle)

            # 保存到字幕文件
            if self.save_subtitles_to_file(srt_path, updated_subtitles):
                self.logger.info(f"字幕偏移已保存到文件: {srt_path}, 偏移量: {offset:.3f}秒")
                self.update_status(f"字幕偏移已保存到文件: {srt_path} (偏移: {offset:.3f}秒)", 'info')
                # 更新字幕数据
                self.subtitles = updated_subtitles
                # 重建时间戳索引（如果需要）
                if hasattr(self, '_rebuild_subtitle_index'):
                    self._rebuild_subtitle_index()
                else:
                    self.logger.warning("_rebuild_subtitle_index 方法未定义，跳过索引重建")
                # 更新播放位置和时间戳
                self._sync_playback_position(offset)
                # 更新字幕预览窗口（如果打开）
                self.update_subtitle_preview_if_open()
            else:
                self.update_status("保存字幕偏移失败", 'error')
                return

            # 可选：保存偏移到配置文件
            if hasattr(self, 'player_config'):
                self.player_config['subtitle_offset'] = self.subtitle_offset
                self.logger.info(f"字幕偏移已保存到配置文件: {self.subtitle_offset:.3f}秒")

        except Exception as e:
            self.logger.error(f"保存字幕偏移失败: {e}")
            self.update_status(f"保存字幕偏移失败: {str(e)}", 'error')

    def _rebuild_subtitle_index(self):
        """重建字幕时间戳索引，用于快速查找"""
        try:
            if not self.subtitles:
                self.logger.warning("字幕数据为空，跳过索引重建")
                return

            # 假设 subtitle_index 是时间戳到段落的映射
            if not hasattr(self, 'subtitle_index'):
                self.subtitle_index = {}

            self.subtitle_index.clear()
            for i, subtitle in enumerate(self.subtitles):
                start_time = subtitle['start_time']
                end_time = subtitle['end_time']
                # 使用时间范围作为键，存储段落索引
                self.subtitle_index[(start_time, end_time)] = i
            self.logger.info("字幕时间戳索引已重建")

        except Exception as e:
            self.logger.error(f"重建字幕索引失败: {e}")
            self.update_status("重建字幕索引失败", 'warning')

    def _sync_playback_position(self, offset):
        """同步播放位置和时间戳，处理字幕偏移后的时间差"""
        try:
            if hasattr(self, 'last_position') and hasattr(self, 'last_update_time'):
                # 更新 last_position，应用偏移
                self.last_position = (self.last_position or 0) + offset
                self.last_update_time = time.time()
                self.logger.info(f"播放位置已同步，偏移: {offset:.3f}秒，当前时间: {self.last_position:.3f}秒")
            else:
                self.logger.warning("last_position 或 last_update_time 未定义，跳过同步")

            # 更新当前播放位置
            if hasattr(self, 'current_position'):
                self.current_position = (self.current_position or 0) + offset
                self.logger.info(f"当前播放位置已更新: {self.current_position:.3f}秒")

            # 更新进度条和时间标签
            total_length = self.get_current_audio_length()
            if total_length > 0:
                progress = (self.current_position / total_length * 100)
                self.progress_scale.set(progress)
                self.time_label.config(
                    text=f"{self.format_time(self.current_position)} / {self.format_time(total_length)}")

        except Exception as e:
            self.logger.error(f"同步播放位置失败: {e}")
            self.update_status("同步播放位置失败", 'warning')

    def _format_srt_time(self, time_value):
        """将时间戳（秒）格式化为 SRT 时间格式 HH:MM:SS,mmm"""
        try:
            total_seconds = float(time_value)
            hours = int(total_seconds // 3600)
            minutes = int((total_seconds % 3600) // 60)
            seconds = int(total_seconds % 60)
            milliseconds = int((total_seconds * 1000) % 1000)
            return f"{hours:02d}:{minutes:02d}:{seconds:02d},{milliseconds:03d}"
        except Exception as e:
            self.logger.error(f"格式化 SRT 时间失败: {e}")
            return "00:00:00,000"

    def export_subtitles(self):
        """改进的字幕导出功能"""
        try:
            if not self.subtitles:
                self.update_status("没有可导出的字幕", 'warning')
                return

            file_path = filedialog.asksaveasfilename(
                defaultextension=".srt",
                filetypes=[("SubRip Subtitle", "*.srt"), ("All files", "*.*")]
            )

            if file_path:
                with open(file_path, 'w', encoding='utf-8') as f:
                    for i, subtitle in enumerate(self.subtitles, 1):
                        # 写入序号
                        f.write(f"{i}\n")

                        # 写入时间轴
                        start_time = self.format_time(subtitle['start_time'], True)
                        end_time = self.format_time(subtitle['end_time'], True)
                        f.write(f"{start_time} --> {end_time}\n")

                        # 写入文本
                        if subtitle['en_text']:
                            f.write(subtitle['en_text'] + '\n')
                        if subtitle['cn_text']:
                            f.write(subtitle['cn_text'] + '\n')

                        f.write('\n')

                self.update_status("字幕导出成功", 'success')

        except Exception as e:
            self.update_status(f"导出字幕失败: {str(e)}", 'error')

    # def adjust_speed(self, delta):
    #     """微调播放速度"""
    #     # current_speed = self.speed_scale.get()
    #     new_speed = max(0.5, min(2.0, current_speed + delta))
    #     # self.speed_scale.set(new_speed)
    #     self.set_playback_speed(new_speed)
    #     self.update_status(f"播放速度: {new_speed:.1f}x", 'info')
    #
    # # 修改 set_playback_speed 方法
    # def set_playback_speed(self, speed):
    #     """真正设置播放速度"""
    #     try:
    #         # 获取当前播放位置
    #         current_pos = self.get_accurate_position()
    #         old_speed = self._playback.get('speed', 1.0)
    #         self._playback['speed'] = float(speed)
    #
    #         # 如果正在播放，重新加载调整速度后的音频
    #         if self.is_playing and self.current_playlist:
    #             current_file = self.current_playlist[self.current_index]
    #
    #
    #             speed_adjusted_file = self.change_audio_speed(current_file, speed)
    #
    #             # 播放调整后的文件
    #             pygame.mixer.music.load(speed_adjusted_file)
    #             pygame.mixer.music.play(start=current_pos)
    #             self.current_position = current_pos
    #
    #             self.update_status(f"播放速度: {speed:.1f}x", 'info')
    #
    #             # 更新进度显示
    #             total_length = self.get_current_audio_length()
    #             self.time_label.config(text=f"{self.format_time(current_pos)} / {self.format_time(total_length)}")
    #
    #             if not self.is_seeking:
    #                 self.update_timer = self.root.after(600, self.update_progress)
    #
    #     except Exception as e:
    #         self.logger.error(f"设置播放速度失败: {e}")
    #         self.update_status(f"设置播放速度失败: {str(e)}", 'error')
    #
    # def change_audio_speed(self, audio_path, speed_factor, output_path=None):
    #     """
    #     改变音频播放速度
    #
    #     参数:
    #         audio_path: 源音频文件路径
    #         speed_factor: 速度因子，1.0表示原速，>1加速，<1减速
    #         output_path: 输出文件路径，为None时使用临时文件
    #
    #     返回:
    #         处理后的音频文件路径
    #     """
    #     if speed_factor == 1.0 and output_path is None:
    #         return audio_path  # 原速直接返回原文件
    #
    #     # 加载音频
    #     sound = AudioSegment.from_file(audio_path)
    #
    #     # 计算新音频的参数
    #     new_frame_rate = int(sound.frame_rate * speed_factor)
    #
    #     # 导出处理后的音频
    #     if output_path is None:
    #         # 创建临时文件
    #         temp_dir = tempfile.gettempdir()
    #         file_name = f"speed_{speed_factor}_{os.path.basename(audio_path)}"
    #         output_path = os.path.join(temp_dir, file_name)
    #
    #     # 使用frame_rate参数改变速度
    #     sound.export(
    #         output_path,
    #         format="mp3",
    #         parameters=["-ar", str(new_frame_rate)]
    #     )
    #
    #     return output_path

    def get_accurate_position(self):
        """改进的精确播放位置获取功能"""
        try:
            current_file = self.current_playlist[self.current_index]

            # 如果未在播放，返回当前进度（秒）
            if not self.is_playing:
                last_position = self.current_position  # 单位：秒
                self.logger.info(f"未播放，返回当前进度: {self.format_time(last_position)} (文件: {current_file})")
                return last_position

            # 获取当前播放位置（毫秒）
            pos_ms = pygame.mixer.music.get_pos()
            if pos_ms < 0:
                last_position = self.current_position  # 单位：秒
                self.logger.info(f"播放位置无效，返回当前进度: {self.format_time(last_position)} (文件: {current_file})")
                return last_position

            # 将播放位置（毫秒）转换为秒
            current_pos = pos_ms / 1000.0  # 单位：秒
            adjusted_pos = current_pos * self._playback['speed']  # 调整速度
            self.current_position = adjusted_pos  # 更新当前进度（秒）
            self.logger.info(f"获取播放位置: {self.format_time(adjusted_pos)} (文件: {current_file})")
            return adjusted_pos

        except Exception as e:
            self.logger.error(f"获取播放位置失败: {e} (文件: {current_file})")
            last_position = self.current_position  # 单位：秒
            self.logger.info(f"获取失败，返回当前进度: {self.format_time(last_position)} (文件: {current_file})")
            return last_position

    def update_info_label(self, item=None):
        """更新信息标签"""
        if item:
            if item in self.folders:
                folder_name = self.folder_tree.item(item)['text']
                file_count = len(self.folders[item]['files'])
                self.info_label.config(text=f"文件夹: {folder_name} ({file_count}个文件)")
            else:
                file_name = self.folder_tree.item(item)['text']
                self.info_label.config(text=f"当前播放: {file_name}")
        elif self.current_playlist and 0 <= self.current_index < len(self.current_playlist):
            current_file = os.path.basename(self.current_playlist[self.current_index])
            self.info_label.config(text=f"当前播放: {current_file}")
        else:
            self.info_label.config(text="未播放")

    def save_player_state(self):
        """改进的播放器状态保存功能"""
        try:
            state = {
                'volume': self.volume_scale.get(),
                # 'speed': self.speed_scale.get(),
                'subtitle_offset': self._playback.get('time_offset', 0),
                'last_playlist': self.current_playlist,
                'last_index': self.current_index,
                'last_position': self._playback.get('last_position', 0),
                'loop_count': self.loop_count.get(),
                'play_mode': self.mode_var.get(),
                'favorites': list(self.favorites),
                'stats': {
                    'total_play_time': self.stats['total_play_time'],
                    'played_files': list(self.stats['played_files']),
                    'last_played': self.stats['last_played']
                }
            }

            with open(self.state_file, 'w', encoding='utf-8') as f:
                json.dump(state, f, ensure_ascii=False, indent=2)

        except Exception as e:
            self.update_status(f"保存状态失败: {str(e)}", 'error')

    def load_player_state(self):
        """改进的播放器状态加载功能"""
        try:
            if os.path.exists(self.state_file):
                with open(self.state_file, 'r', encoding='utf-8') as f:
                    state = json.load(f)

                    # 恢复音量
                    self.volume_scale.set(state.get('volume', 0.5))

                    # 恢复播放速度
                    # self.speed_scale.set(state.get('speed', 1.0))

                    # 恢复字幕偏移
                    self._playback['time_offset'] = state.get('subtitle_offset', 0)

                    # 恢复循环设置
                    self.loop_count.set(state.get('loop_count', 1))

                    # 恢复播放模式
                    self.mode_var.set(state.get('play_mode', 'sequential'))

                    # 恢复收藏夹
                    self.favorites = set(state.get('favorites', []))

                    # 恢复统计数据
                    self.stats = state.get('stats', {
                        'total_play_time': 0,
                        'played_files': set(),
                        'last_played': None
                    })

                    # 恢复上次播放列表和索引
                    last_playlist = state.get('last_playlist', [])
                    last_index = state.get('last_index', 0)
                    if last_playlist and 0 <= last_index < len(last_playlist):
                        self.current_playlist = last_playlist
                        self.current_index = last_index


                    return True
        except Exception as e:
            self.update_status(f"加载状态失败: {str(e)}", 'error')
        return False

    def on_closing(self):
        """改进的关闭处理,确保清理临时文件"""
        try:
            self.logger.info("主窗口关闭，执行清理操作")
            self.stop_follow_reading()
            if hasattr(self.follow_reader, 'cleanup_temp_files'):
                self.follow_reader.cleanup_temp_files()

            # 停止所有播放
            if hasattr(self, 'is_playing') and self.is_playing:
                pygame.mixer.music.stop()
                pygame.mixer.music.unload()

            # 取消所有定时器
            if self.update_timer:
                self.root.after_cancel(self.update_timer)
            if self._status_timer:
                self.root.after_cancel(self._status_timer)
            if self._auto_save_timer:
                self.root.after_cancel(self._auto_save_timer)
            if self._playback_delay_timer:
                self.root.after_cancel(self._playback_delay_timer)

            # 清理临时文件
            if hasattr(self, 'follow_reader'):
                self.follow_reader.cleanup_temp_files()

            # 保存最终状态
            self.save_player_state()
            self.save_settings()

            # 记录关闭事件
            self.logger.info("播放器正常关闭")

        except Exception as e:
            self.logger.error(f"关闭时发生错误: {e}")
        finally:
            pygame.mixer.quit()
            self.cleanup_on_exit()
            self.root.destroy()

    def start(self):
        """启动播放器"""
        # 恢复文件夹树形结构
        # self.restore_folder_tree() #  移动到 load_settings 之后
        # 开始主循环
        self.root.mainloop()

    def restore_folder_tree(self):
        try:
            # # 清空现有树
            # for item in self.folder_tree.get_children():
            #     self.folder_tree.delete(item)
            #
            # # 重新创建树节点，更新每个文件夹的 node_id
            # for folder_key, folder_info in self.folders.items():
            #     folder_path = folder_info['path']
            #     folder_name = os.path.basename(folder_path)
            #     tree_id = self.folder_tree.insert("", "end",
            #                                       text=folder_name,
            #                                       values=(f"{len(folder_info['files'])}个文件",))
            #     folder_info['node_id'] = tree_id
            #
            #     # 如果之前是展开状态，则重新展开
            #     if folder_info.get('expanded', False):
            #         self.expand_folder(tree_id)

            self.update_status("文件夹结构已恢复", 'info')
        except Exception as e:
            self.update_status(f"恢复文件夹结构失败: {str(e)}", 'error')

    def bind_shortcuts(self):
        """改进的快捷键绑定功能"""
        try:
            # 播放控制
            self.root.bind('<space>', lambda e: self.play_pause())
            self.root.bind('<Control-p>', lambda e: self.play_pause())

            # 导航控制 - 调整快进快退步长为2秒
            self.root.bind('<Left>', lambda e: self.seek_relative(-2))
            self.root.bind('<Right>', lambda e: self.seek_relative(2))

            # 长距离快进快退(Ctrl+方向键) - 调整为6秒
            self.root.bind('<Control-Left>', lambda e: self.seek_relative(-6))
            self.root.bind('<Control-Right>', lambda e: self.seek_relative(6))

            # 音量控制(5%步进)
            self.root.bind('<Up>', lambda e: self.adjust_volume(0.05))
            self.root.bind('<Down>', lambda e: self.adjust_volume(-0.05))

            # 速度控制
            self.root.bind('<Control-Up>', lambda e: self.adjust_speed(0.1))
            self.root.bind('<Control-Down>', lambda e: self.adjust_speed(-0.1))

            # 其他功能
            self.root.bind('<Control-s>', lambda e: self.save_player_state())
            self.root.bind('<Control-f>', lambda e: self.toggle_follow_reading())
            self.root.bind('<Escape>', lambda e: self.stop())

        except Exception as e:
            self.update_status(f"绑定快捷键失败: {str(e)}", 'error')

    def auto_save_state(self):
        """改进的自动保存状态功能"""
        try:
            self.save_player_state()
            self.clean_cache()  # 定期清理缓存

            # 设置下一次自动保存
            self._auto_save_timer = self.root.after(
                self.player_config['auto_save_interval'] * 1000,
                self.auto_save_state
            )
        except Exception as e:
            print(f"自动保存状态失败: {e}")

    def set_volume(self, value):
        """直接设置音量，避免使用属性访问"""
        try:
            volume = max(0, min(100, float(value)))
            self._volume = volume
            pygame.mixer.music.set_volume(volume / 100.0)
            if hasattr(self, 'volume_scale'):
                current = self.volume_scale.get()
                if abs(current - volume) > 0.1:  # 避免循环更新
                    self.volume_scale.set(volume)
            self.update_status(f"音量: {int(volume)}%", 'info')
        except Exception as e:
            self.update_status(f"设置音量失败: {str(e)}", 'error')

    def adjust_volume(self, delta):
        """音量调节函数"""
        try:
            self.volume = self.volume + (delta * 100)
        except Exception as e:
            self.update_status(f"调节音量失败: {str(e)}", 'error')

    def clean_cache(self):
        """清理缓存文件"""
        try:
            # 清理音频缓存
            for key in list(self._audio_cache.keys()):
                if not os.path.exists(key):
                    del self._audio_cache[key]

            # 清理日志文件
            current_time = time.time()
            log_retention_days = 7

            for file in os.listdir(self.logs_dir):
                file_path = os.path.join(self.logs_dir, file)
                if os.path.getmtime(file_path) < current_time - (log_retention_days * 86400):
                    os.remove(file_path)

            # 清理临时文件
            for file in os.listdir(self.cache_dir):
                file_path = os.path.join(self.cache_dir, file)
                if os.path.getmtime(file_path) < current_time - 86400:  # 1天
                    os.remove(file_path)

        except Exception as e:
            self.logger.error(f"清理缓存失败: {e}")

    def toggle_follow_reading(self):
        """切换跟读模式"""

        if not self.is_following:
            self.is_following = True
            self.is_following_active = True  # 开始跟读流程
            self.follow_button.config(text="停止跟读")
            self.update_status("开始跟读模式", 'info')
            self.current_segment_repeat_count = 0  # 重置重复次数
            self.is_manual_switch = False  # 重置手动切换标志
            self.start_follow_reading()
        else:
            self.stop_follow_reading()
            self.is_following_active = False  # 停止跟读流程
            self.follow_button.config(text="开始跟读")
            self.update_status("停止跟读模式", 'info')

    def start_follow_reading(self):
        """改进的跟读开始功能"""
        try:
            self.is_following = True
            self.follow_button.config(text="停止跟读")

            # 重置状态
            self.current_loop = 0
            self.max_follow_loops = self.loop_count.get()

            # 准备音频段落
            self.prepare_audio_segments()
            self.current_segment = 0

            # 更新字幕预览窗口（如果已打开）
            self.update_subtitle_preview_if_open()  # 新增调用

            # 更新界面
            if self.current_segment == 1:
                self.progress_scale.set(0)
            self.time_label.config(text="00:00 / 00:00")
            self.follow_text.delete('1.0', 'end')
            self.follow_text.insert('end',
                                    f"开始跟读第 {self.current_index + 1} 个音频文件 (1/{self.max_follow_loops})\n")

            # 开始播放
            self.play_segment()
            self.update_status("跟读模式已启动", 'info')
        except Exception as e:
            self.update_status(f"启动跟读失败: {str(e)}", 'error')
            self.stop_follow_reading()

        """恢复普通播放模式"""
        try:
            if not self.is_following and self.current_playlist:
                self.play_current_track()
        except Exception as e:
            self.logger.error(f"恢复普通播放失败: {e}")

    def prepare_audio_segments(self):
        """改进的音频分段准备功能"""
        try:
            current_file = self.current_playlist[self.current_index]

            # 获取音频时长
            self.duration = None
            try:
                with contextlib.closing(wave.open(current_file, 'r')) as f:
                    frames = f.getnframes()
                    rate = f.getframerate()
                    self.duration = frames / float(rate)
            except:
                try:
                    audio = pygame.mixer.Sound(current_file)
                    self.duration = audio.get_length()
                except Exception as e:
                    self.update_status(f"无法获取音频时长: {str(e)}", 'error')
                    return

            if self.duration is None:
                self.update_status("音频时长获取失败", 'error')
                return

            # 加载字幕
            has_subtitles = self.load_subtitles(current_file)

            if has_subtitles and self.subtitles:
                self.total_segments = len(self.subtitles)
                segment_type = "字幕"
            else:
                # 无字幕时使用固定时长分段
                self.segment_duration = 5
                self.total_segments = int(self.duration // self.segment_duration) + 1
                segment_type = "时长"

            # 重置状态
            self.current_segment = 0

            # 更新显示
            self.follow_text.delete('1.0', 'end')
            self.follow_text.insert('end',
                                    f"{segment_type}分段：音频总长{self.duration:.1f}秒，共{self.total_segments}段\n")
            self.follow_text.see('end')

        except Exception as e:
            self.update_status(f"准备音频分段失败: {str(e)}", 'error')

    def pause_for_follow(self):
        """改进的跟读暂停功能——正常跟读模式下的自动暂停"""
        if self.is_following:
            try:
                pygame.mixer.music.pause()
                self.is_playing = False
                self.is_following_active = True
                self.is_playing_or_recording = False
                self.has_moved = False

                if hasattr(self, 'update_timer') and self.update_timer:
                    self.root.after_cancel(self.update_timer)
                    self.update_timer = None

                self.update_status("已暂停，准备跟读", 'info')
                self.play_button.config(text="播放")

                current_subtitle = self.subtitles[self.current_segment]
                reference_text = current_subtitle.get('en_text', '')

                self.follow_text.delete('1.0', 'end')
                self.follow_text.insert('end', "\n=== 原文 ===\n", 'title')
                self.follow_text.insert('end', f"{reference_text}\n", 'en')
                self.follow_text.see('end')

                if not self.no_record_var:
                    self.toggle_play_button(enable=False)
                    self.toggle_navigation_buttons(enable=False)

                wait_time = max(
                    5000,
                    min(10000, int((current_subtitle['end_time'] - current_subtitle['start_time']) * 1.5))
                )

            except Exception as e:
                self.logger.error(f"跟读暂停失败: {e}", exc_info=True)
                self.update_status(f"跟读暂停失败: {str(e)}", 'error')
                self.toggle_navigation_buttons(enable=True)
                self.toggle_play_button(enable=True)
                self.stop_follow_reading()

    def _continue_follow_reading(self):
        """继续跟读流程"""
        if self.is_following:
            try:
                self.next_segment()  # 自动跳转到下一段
            except Exception as e:
                self.logger.error(f"继续跟读失败: {e}")
                self.update_status(f"继续跟读失败: {str(e)}", 'error')
                self.stop_follow_reading()

    def on_tree_double_click(self, event):
        """处理树形视图的双击事件，优化跟读模式状态管理"""
        try:
            item = self.folder_tree.selection()[0]
            parent = self.folder_tree.parent(item)

            if not parent:  # 是文件夹节点
                if item in self.folders:
                    if not self.folders[item]['expanded']:
                        # 展开文件夹
                        self.expand_folder(item)
                    else:
                        # 收起文件夹
                        self.collapse_folder(item)
            else:  # 是音频文件
                # 在切换文件之前，停止跟读模式并清理状态
                if self.is_following:
                    self.stop_follow_reading()
                    self.logger.info("双击播放新文件，停止跟读模式并清理状态")
                self.play_audio_file(item)

        except Exception as e:
            self.logger.error(f"处理双击事件失败: {e}", exc_info=True)
            self.update_status(f"处理双击事件失败: {str(e)}", 'error')

    def on_tree_single_click(self, event):
        """处理树形视图的单击事件，优化文件路径规范化"""
        try:
            self.logger.debug("处理树形视图单击事件开始")

            # 获取当前选中项
            selection = self.folder_tree.selection()
            self.logger.debug(f"当前选中项: {selection}")

            if selection:
                item = selection[0]
                self.logger.debug(f"选中节点: {item}, 节点信息: {self.folder_tree.item(item)}")

                # 更新信息标签
                if item in self.folders:
                    # 文件夹节点
                    folder_name = self.folder_tree.item(item)['text']
                    file_count = len(self.folders[item]['files'])
                    self.info_label.config(text=f"文件夹: {folder_name} ({file_count}个文件)")
                    self.logger.info(f"用户选中文件夹: {folder_name}, 文件数量: {file_count}")
                else:
                    # 文件节点
                    file_name = self.folder_tree.item(item)['text']
                    values = self.folder_tree.item(item).get('values', [])
                    self.logger.debug(f"文件节点值: {values}")

                    if values and len(values) > 0:
                        file_path = values[0]
                        # 规范化文件路径
                        file_path = os.path.normpath(os.path.abspath(file_path))
                        self.logger.debug(f"规范化文件路径: {file_path}")

                        if os.path.exists(file_path):
                            self.selected_file = file_path  # 记录用户选中的文件路径
                            self.info_label.config(text=f"选中文件: {file_name}")
                            self.logger.info(f"用户选中文件: {file_path} (规范化路径: {file_path})")
                        else:
                            self.logger.warning(f"文件路径不存在: {file_path}")
                            self.info_label.config(text=f"选中文件: {file_name} (路径不可用)")
                            self.selected_file = None  # 清理无效的选中文件
                    else:
                        self.logger.warning(f"文件节点缺少路径信息: {item}, 文件名: {file_name}")
                        self.info_label.config(text=f"选中文件: {file_name} (路径不可用)")
                        self.selected_file = None  # 清理无效的选中文件
            else:
                self.logger.debug("未选中任何节点")
                self.info_label.config(text="未选中任何节点")
                self.selected_file = None  # 清理无效的选中文件

        except Exception as e:
            self.logger.error(f"处理单击事件失败: {e}", exc_info=True)
            self.info_label.config(text="处理单击事件失败")
            self.selected_file = None  # 清理无效的选中文件

    def remove_selected_folder(self):
        """改进的移除文件夹功能，增加强制移除选项"""
        try:
            selection = self.folder_tree.selection()
            if not selection:
                # 检查是否存在无效文件夹并提供清理选项
                invalid_folders = []
                for folder_id, folder_info in list(self.folders.items()):
                    if not os.path.exists(folder_info['path']):
                        invalid_folders.append((folder_id, folder_info['path']))

                if invalid_folders:
                    if messagebox.askyesno("清理无效文件夹",
                                           f"发现{len(invalid_folders)}个无效文件夹，是否清理？"):
                        for folder_id, _ in invalid_folders:
                            # 从树中删除
                            if self.folder_tree.exists(folder_id):
                                self.folder_tree.delete(folder_id)
                            # 从字典中删除
                            if folder_id in self.folders:
                                del self.folders[folder_id]

                        # 保存更新后的设置
                        self.save_settings()
                        self.update_status("已清理无效文件夹", 'success')
                    return
                else:
                    self.update_status("请先选择要删除的文件夹", 'warning')
                    return

            folder_id = selection[0]
            folder_info = self.folders.get(folder_id)

            if folder_info:
                folder_name = self.folder_tree.item(folder_id)['text']
                folder_path = folder_info['path']

                # 检查文件夹是否存在
                is_invalid = not os.path.exists(folder_path)
                message = f"{'无效' if is_invalid else ''}文件夹 '{folder_name}' {'已无法访问' if is_invalid else ''}\n是否移除？"

                if messagebox.askyesno("确认删除", message):
                    # 删除树节点
                    self.folder_tree.delete(folder_id)

                    # 从字典中删除
                    del self.folders[folder_id]

                    # 清理播放列表
                    if self.current_playlist and folder_info.get('files'):
                        folder_files = set(folder_info['files'])
                        if any(f in folder_files for f in self.current_playlist):
                            self.current_playlist = []
                            self.current_index = 0
                            self.stop()

                    # 保存设置
                    self.save_settings()
                    self.update_status(f"已删除文件夹: {folder_name}", 'success')

        except Exception as e:
            self.update_status(f"删除文件夹失败: {str(e)}", 'error')

    def clean_invalid_folders(self):
        """彻底清理无效文件夹"""
        try:
            # 清理前备份
            backup = dict(self.folders)

            # 清空当前所有节点
            for item in self.folder_tree.get_children():
                self.folder_tree.delete(item)

            # 清空字典
            self.folders.clear()

            # 保存空状态
            self.save_settings()

            self.update_status("所有文件夹引用已清理", 'success')
            return True

        except Exception as e:
            # 发生错误时恢复备份
            self.folders = backup
            self.update_status(f"清理失败: {str(e)}", 'error')
            return False

    def add_folder(self):
        """完全重写的添加文件夹功能"""
        try:
            invalid_refs = False
            for folder_id in list(self.folders.keys()):
                if not self.folder_tree.exists(folder_id):
                    invalid_refs = True
                    break

            if invalid_refs:
                if messagebox.askyesno("发现无效引用",
                                       "检测到文件夹引用错误，需要清理后继续，是否清理？"):
                    for item in self.folder_tree.get_children():
                        self.folder_tree.delete(item)
                    self.folders.clear()
                    self.save_settings()
                    self.update_status("已清理所有文件夹", 'success')
                return

            folder_path = filedialog.askdirectory()
            if not folder_path:
                return

            # 规范化文件夹路径
            folder_path = os.path.normpath(os.path.abspath(folder_path))
            self.logger.debug(f"添加文件夹路径: {folder_path}")

            for info in self.folders.values():
                if os.path.samefile(info['path'], folder_path):
                    self.update_status("该文件夹已添加", 'warning')
                    return

            folder_name = os.path.basename(folder_path)

            audio_files = []
            for root, dirs, files in os.walk(folder_path):
                dirs[:] = natsorted(dirs)
                for file in natsorted(files):
                    if file.lower().endswith(('.mp3', '.wav')):
                        full_path = os.path.join(root, file)
                        # 规范化文件路径
                        full_path = os.path.normpath(os.path.abspath(full_path))
                        if os.path.exists(full_path):
                            audio_files.append(full_path)
                            self.logger.debug(f"添加音频文件: {full_path}")

            if not audio_files:
                self.update_status("未找到音频文件", 'warning')
                return

            tree_id = self.folder_tree.insert("", "end",
                                              text=folder_name,
                                              values=(f"{len(audio_files)}个文件",))

            self.folders[tree_id] = {
                'path': folder_path,
                'files': audio_files,
                'expanded': False
            }

            # 更新树形视图中的文件节点
            for file_path in audio_files:
                file_name = os.path.basename(file_path)
                self.folder_tree.insert(tree_id, "end", text=file_name, values=(file_path,))

            self.save_settings()
            self.update_status(f"已添加文件夹: {folder_name}", 'success')

        except Exception as e:
            self.update_status(f"添加文件夹失败: {str(e)}", 'error')

    def play_selected_folder(self):
        """改进的播放选中文件夹功能"""
        try:
            selection = self.folder_tree.selection()
            if not selection:
                self.update_status("请先选择一个文件夹", 'warning')
                return

            folder_id = selection[0]

            # 检查是否需要清理
            if (folder_id not in self.folders) and messagebox.askyesno("无效文件夹", "检测到文件夹引用错误，需要清理后重新添加，是否现在清理？"):
                # 清理所有节点
                for item in self.folder_tree.get_children():
                    self.folder_tree.delete(item)
                self.folders.clear()
                self.save_settings()
                self.update_status("已清理所有文件夹，请重新添加", 'success')
                return

            folder_info = self.folders[folder_id]
            folder_path = folder_info['path']

            # 检查文件夹是否存在
            if not os.path.exists(folder_path):
                if messagebox.askyesno("无效文件夹",
                                       f"文件夹 '{folder_path}' 不存在或无法访问，是否移除？"):
                    self.folder_tree.delete(folder_id)
                    del self.folders[folder_id]
                    self.save_settings()
                    self.update_status("已移除无效文件夹", 'success')
                return

            # 验证音频文件
            valid_files = [f for f in folder_info['files'] if os.path.exists(f)]
            if not valid_files:
                if messagebox.askyesno("空文件夹",
                                       "该文件夹没有有效的音频文件，是否移除？"):
                    self.folder_tree.delete(folder_id)
                    del self.folders[folder_id]
                    self.save_settings()
                    self.update_status("已移除空文件夹", 'success')
                return

            # 更新有效文件列表
            self.folders[folder_id]['files'] = valid_files
            self.current_playlist = valid_files
            self.current_index = 0
            self.current_loop = 0
            self.current_position = 0  # 明确初始化进度条位置

            # 开始播放
            self.play_current_track()

            # 更新显示
            folder_name = self.folder_tree.item(folder_id)['text']
            # self.info_label.config(text=f"正在播放文件夹: {folder_name}")
            self.update_status(f"开始播放文件夹: {folder_name}", 'success')

        except Exception as e:
            self.update_status(f"播放文件夹失败: {str(e)}", 'error')

    @safe_call
    def play_pause(self):
        """播放/暂停功能，优化跟读模式和普通模式的逻辑隔离"""
        try:
            if self.is_playing or (self.is_following and getattr(self, 'is_following_active', False)):
                # 暂停播放或跟读流程
                pygame.mixer.music.pause()
                self.is_playing = False
                self.is_following_active = False  # 暂停跟读流程
                self.play_button.config(text="播放")
                self.update_status("已暂停", 'info')
                self.logger.info("暂停播放或跟读流程")

                # 记录暂停状态（普通模式和跟读模式）
                self.paused_file = self.current_playlist[self.current_index] if self.current_playlist else None
                self.paused_position = pygame.mixer.music.get_pos() / 1000.0 + self.current_position  # 精确记录暂停位置
                self.paused_segment = self.current_segment if self.is_following else None
                self.logger.info(f"暂停状态，文件: {self.paused_file}, 位置: {self.paused_position}秒, 段落: {self.paused_segment}")

                # 取消进度更新定时器
                if hasattr(self, 'update_timer') and self.update_timer:
                    self.root.after_cancel(self.update_timer)
                    self.update_timer = None

                # 取消跟读模式的暂停定时器
                if self.is_following and hasattr(self, '_follow_pause_timer') and self._follow_pause_timer:
                    self.root.after_cancel(self._follow_pause_timer)
                    self._follow_pause_timer = None

            else:
                # 恢复播放或开始新播放
                current_file = self.current_playlist[self.current_index] if self.current_playlist else None
                if not self.current_playlist:
                    self.update_status("没有可播放的文件", 'warning')
                    return

                # 清理字幕缓存，避免显示之前文件的字幕
                if hasattr(self, '_last_subtitle'):
                    self._last_subtitle = None
                    self.logger.debug("清理字幕缓存，避免显示之前文件的字幕")

                if self.is_following:
                    # 跟读模式：继续播放当前段落
                    if not self.subtitles or self.current_segment >= len(self.subtitles):
                        self.update_status("没有可播放的段落", 'warning')
                        return
                    subtitle = self.subtitles[self.current_segment]
                    start_time = float(subtitle['start_time']) / 1000.0
                    end_time = float(subtitle['end_time']) / 1000.0

                    # 如果有暂停位置，从暂停位置继续播放
                    if self.paused_position is not None and start_time <= self.paused_position <= end_time:
                        self.current_position = self.paused_position
                    else:
                        self.current_position = start_time

                    # 始终调用 play_segment 以恢复跟读模式
                    self.play_segment()
                    self.is_following_active = True  # 恢复跟读流程
                    self.play_button.config(text="暂停")
                    self.update_status("继续播放段落", 'info')
                    self.logger.info(f"跟读模式继续播放，段落: {self.current_segment + 1}, 位置: {self.current_position}秒")

                else:
                    # 普通模式：检查是否需要切换文件
                    self.logger.debug(f"当前选中文件: {self.selected_file}, 当前播放文件: {current_file}")
                    if hasattr(self, 'selected_file') and self.selected_file and self.selected_file != current_file:
                        # 用户选中了新文件，尝试切换到新文件
                        self.selected_file = os.path.normpath(os.path.abspath(self.selected_file))
                        self.logger.debug(f"规范化选中文件路径: {self.selected_file}")

                        if not os.path.exists(self.selected_file):
                            self.logger.warning(f"选中的文件路径不存在: {self.selected_file}")
                            self.update_status("选中的文件不存在", 'warning')
                            return

                        # 检查新文件是否在当前播放列表中
                        normalized_playlist = [os.path.normpath(os.path.abspath(f)) for f in self.current_playlist]
                        if self.selected_file in normalized_playlist:
                            # 新文件在当前播放列表中，直接切换
                            self.current_index = normalized_playlist.index(self.selected_file)
                            self.current_position = 0
                            self.paused_file = None  # 清理暂停状态
                            self.paused_position = None
                            self.logger.info(f"文件切换，播放新文件: {self.selected_file}")
                            self.play_current_track()
                        else:
                            # 新文件不在当前播放列表中，动态更新播放列表
                            parent = self._find_parent_folder(self.selected_file)
                            self.logger.debug(f"找到的父文件夹: {parent}")
                            if parent and parent in self.folders:
                                folder_files = self.folders[parent]['files']
                                # 规范化文件夹中的文件路径
                                normalized_folder_files = [os.path.normpath(os.path.abspath(f)) for f in folder_files]
                                if self.selected_file in normalized_folder_files:
                                    # 更新播放列表并切换到新文件
                                    self.current_playlist = normalized_folder_files
                                    self.current_index = normalized_playlist.index(self.selected_file)
                                    self.current_position = 0
                                    self.paused_file = None  # 清理暂停状态
                                    self.paused_position = None
                                    self.logger.info(f"更新播放列表并播放新文件: {self.selected_file}")
                                    self.play_current_track()
                                else:
                                    self.logger.warning(f"选中的文件不在文件夹中: {self.selected_file}")
                                    self.update_status("选中的文件不在文件夹中", 'warning')
                                    return
                            else:
                                self.logger.warning(f"无法找到选中的文件所属文件夹: {self.selected_file}")
                                self.update_status("无法找到选中的文件所属文件夹", 'warning')
                                return
                    else:
                        # 继续播放暂停的文件
                        if pygame.mixer.music.get_busy():
                            # 继续播放暂停的音频
                            pygame.mixer.music.unpause()
                            self.is_playing = True
                            self.play_button.config(text="暂停")
                            self.update_status("继续播放", 'info')
                        else:
                            # 从暂停位置重新播放
                            self.current_position = self.paused_position if self.paused_position is not None else 0
                            self.logger.info(f"继续播放暂停的文件: {current_file}, 位置: {self.current_position}秒")
                            self.play_current_track()

                    # 强制更新进度条
                    total_length = self.get_current_audio_length()
                    if total_length > 0:
                        self.current_position = min(self.current_position, total_length)
                        progress = (self.current_position / total_length) * 100
                        self.progress_scale.set(progress)
                    else:
                        self.progress_scale.set(0)
                    self.time_label.config(
                        text=f"{self.format_time(self.current_position)} / {self.format_time(total_length)}")

                # 启动进度更新
                if not self.is_seeking:
                    self.update_progress()

        except Exception as e:
            self.logger.error(f"播放/暂停失败: {e}", exc_info=True)
            self.update_status(f"播放/暂停失败: {str(e)}", 'error')
            self.is_playing = False
            self.is_following_active = False  # 异常时重置状态

    def _find_parent_folder(self, file_path):
        """查找文件所属的父文件夹"""
        try:
            self.logger.debug(f"查找文件所属文件夹: {file_path}")
            # 规范化文件路径
            file_path = os.path.normpath(os.path.abspath(file_path))
            self.logger.debug(f"规范化文件路径: {file_path}")

            for folder_id, folder_data in self.folders.items():
                folder_files = folder_data['files']
                # 规范化文件夹中的文件路径
                normalized_folder_files = [os.path.normpath(os.path.abspath(f)) for f in folder_files]
                self.logger.debug(f"文件夹 {folder_id} 的文件列表: {normalized_folder_files}")

                if file_path in normalized_folder_files:
                    self.logger.info(f"找到文件所属文件夹: {folder_id}")
                    return folder_id
            self.logger.warning(f"未找到文件所属文件夹: {file_path}")
            return None
        except Exception as e:
            self.logger.error(f"查找文件所属文件夹失败: {e}", exc_info=True)
            return None

    def _load_and_play_track(self, index):
        """统一的曲目加载和播放处理"""
        try:
            self.current_index = index
            self.current_position = 0  # 重置播放进度
            self._playback['last_position'] = 0  # 重置最后播放位置
            self.current_segment = 0
            self.current_loop = 0

            # 加载字幕
            current_file = self.current_playlist[index]
            self.load_subtitles(current_file)

            # 更新显示
            self._update_tree_selection()

            # 开始播放
            if self.is_following:
                # self.update_info_label()
                self.play_segment()
            else:
                self.play_current_track()

        except Exception as e:
            self.update_status(f"加载曲目失败: {str(e)}", 'error')

    def previous_track(self):
        """改进的上一曲功能"""
        if not self.current_playlist:
            return

        new_index = (self.current_index - 1) % len(self.current_playlist)
        self._load_and_play_track(new_index)

    def next_track(self):
        """改进的下一曲功能"""
        if not self.current_playlist:
            return

        new_index = (self.current_index + 1) % len(self.current_playlist)
        self._load_and_play_track(new_index)

    @safe_call
    def stop(self):
        """停止播放并重置状态"""
        try:
            pygame.mixer.music.stop()
            self.is_playing = False
            self.is_following_active = False  # 跟读流程需取消
            self.is_paused_for_delay = False
            self.is_playing_or_recording = False
            self.has_moved = False

            # 清理暂停状态
            self.paused_file = None
            self.paused_position = None
            self.paused_segment = None
            self.current_position = 0
            self.current_segment = 0
            self.logger.info("停止播放，清理所有状态")

            # 清理所有定时器
            for timer_attr in ['update_timer', '_playback_delay_timer', '_check_timer', '_follow_pause_timer']:
                if hasattr(self, timer_attr):
                    timer = getattr(self, timer_attr)
                    if timer:
                        self.root.after_cancel(timer)
                        setattr(self, timer_attr, None)

            # 重置界面状态
            self.play_button.config(text="播放")
            self.info_label.config(text="未播放")
            self.progress_scale.set(0)
            self.time_label.config(text="00:00 / 00:00")

            # 如果在跟读模式，停止跟读，不恢复普通播放
            if self.is_following:
                self.stop_follow_reading(resume_normal_playback=False)
                self.is_following = False
                self.logger.info("停止跟读模式，不恢复普通播放")

            self.update_status("停止播放", 'info')

        except Exception as e:
            self.update_status(f"停止播放失败: {str(e)}", 'error')
            self.logger.error(f"停止播放失败: {e}")

    @safe_call
    def change_volume(self, value):
        """音量控制回调函数"""
        try:
            # 将0-100的值转换为0-1
            volume = float(value) / 100.0
            pygame.mixer.music.set_volume(volume)
            self.update_status(f"音量: {int(float(value))}%", 'info')
        except Exception as e:
            self.update_status(f"调整音量失败: {str(e)}", 'error')

    def smooth_volume_change(self, target_volume, duration=500):
        """改进的音量平滑过渡功能"""
        try:
            if self._playback['volume_fade']:
                self.root.after_cancel(self._playback['volume_fade'])

            current_volume = pygame.mixer.music.get_volume()
            steps = 20
            step_time = duration / steps
            volume_step = (target_volume - current_volume) / steps

            def fade_step(step=0):
                if step < steps:
                    new_volume = current_volume + (volume_step * (step + 1))
                    pygame.mixer.music.set_volume(new_volume)
                    self._playback['volume_fade'] = self.root.after(
                        int(step_time),
                        lambda: fade_step(step + 1)
                    )
                else:
                    self._playback['volume_fade'] = None

            fade_step()

        except Exception as e:
            self.update_status(f"音量平滑调整失败: {str(e)}", 'error')

    def on_speed_change(self, value):
        """处理语速变化"""
        try:
            speed = float(value)
            self.set_playback_speed(speed)
            self.update_status(f"播放速度: {speed:.1f}x", 'info')
        except Exception as e:
            self.update_status(f"设置播放速度失败: {str(e)}", 'error')

    def _load_and_play_audio(self, file, start_pos):
        def load_and_play():
            try:
                if not os.path.exists(file):
                    self.update_status(f"音频文件不存在: {file}", 'error')
                    self.logger.error(f"音频文件不存在: {file}")
                    self.playback_queue.put(('error', f"音频文件不存在: {file}"))
                    return
                self.logger.info(f"开始异步加载音频文件: {file}")
                pygame.mixer.music.load(file)
                pygame.mixer.music.play(start=start_pos)
                self.playback_queue.put(('success', start_pos))
                self.logger.info(f"异步加载和播放完成，起始位置: {start_pos}秒")
            except Exception as e:
                self.logger.error(f"异步加载音频失败: {e}")
                self.update_status(f"音频加载失败: {str(e)}", 'error')
                self.playback_queue.put(('error', f"音频加载失败: {str(e)}"))
        thread = threading.Thread(target=load_and_play, daemon=True)
        thread.start()
        self.logger.info("已启动异步加载线程，主线程继续执行")
        self.root.after(100, self._check_playback_queue)

    def _check_playback_queue(self):
        try:
            while not self.playback_queue.empty():
                status, message = self.playback_queue.get_nowait()
                if status == 'success':
                    start_pos = message
                    self.is_playing = True
                    if self.is_following:
                        self.is_following_active = True
                    self.logger.info(f"音频播放成功，起始位置: {start_pos}秒")
                elif status == 'error':
                    self.logger.error(message)
                    self.update_status(message, 'error')
        except queue.Empty:
            pass
        finally:
            self.root.after(100, self._check_playback_queue)

    def update_follow_mode(self, enable):
        self.is_following = enable
        self.is_following_active = enable
        self.logger.info(f"跟读模式状态更新: {enable}")

    @safe_call
    def seek_absolute(self, value):
        """改进的绝对定位功能，优化跟读模式下的段落切换和字幕显示"""
        if not hasattr(self, 'current_playlist') or not self.current_playlist:
            self.logger.warning("播放列表为空，忽略定位")
            return

        try:
            # 设置 seeking 标志
            self.is_seeking = True

            # 取消现有的定时器
            for timer in ['update_timer', '_check_timer', '_playback_delay_timer']:
                if hasattr(self, timer) and getattr(self, timer):
                    self.root.after_cancel(getattr(self, timer))
                    setattr(self, timer, None)

            # 如果处于跟读模式，确保录音线程被正确停止并清理资源
            if self.is_following and hasattr(self.follow_reader, 'is_recording') and self.follow_reader.is_recording:
                self.logger.info("正在录音，停止录音以调整进度")
                self.follow_reader.stop_recording(callback=self.recording_callback)
                self.logger.info("录音已停止，清理临时文件")
                if hasattr(self.follow_reader, 'cleanup_temp_files'):
                    self.follow_reader.cleanup_temp_files()
                self.logger.info("录音资源已清理，准备调整进度")

            total_length = self.get_current_audio_length()
            seek_pos = (float(value) / 100.0) * total_length  # seek_pos 单位是秒

            if self.is_following:
                # 跟读模式：找到对应的段落
                seek_pos_ms = seek_pos * 1000  # 转换为毫秒
                subtitle = self._find_subtitle_optimized(seek_pos_ms, tolerance=200)
                if subtitle:
                    self.current_segment = self.subtitles.index(subtitle)
                    self.current_segment_repeat_count = 0  # 重置重复次数
                    self.is_manual_switch = True  # 标记为手动切换
                    seek_pos = float(subtitle['start_time']) / 1000.0  # 调整到段落的开始时间
                    self.follow_text.insert('end', f"\n手动切换到第 {self.current_segment + 1} 段\n", 'prompt')
                    self.logger.info(f"跟读模式下，定位到段落 {self.current_segment + 1}，开始时间: {seek_pos}秒")
                else:
                    # 未找到对应的字幕段落，尝试定位到最近的段落
                    closest_subtitle = None
                    min_distance = float('inf')
                    closest_segment = 0
                    for i, sub in enumerate(self.subtitles):
                        start_time_ms = float(sub['start_time'])
                        distance = abs(seek_pos_ms - start_time_ms)
                        if distance < min_distance:
                            min_distance = distance
                            closest_subtitle = sub
                            closest_segment = i

                    if closest_subtitle and min_distance < 5000:  # 距离小于 5 秒时，定位到最近段落
                        self.current_segment = closest_segment
                        self.current_segment_repeat_count = 0  # 重置重复次数
                        self.is_manual_switch = True  # 标记为手动切换
                        seek_pos = float(closest_subtitle['start_time']) / 1000.0  # 调整到最近段落的开始时间
                        self.follow_text.insert('end', f"\n定位到最近的第 {self.current_segment + 1} 段\n", 'prompt')
                        self.logger.info(f"跟读模式下，定位到最近段落 {self.current_segment + 1}，开始时间: {seek_pos}秒")
                    else:
                        self.logger.warning("未找到对应的字幕段落，且无最近段落可定位")
                        self.update_status("未找到对应的字幕段落，请拖动到有效位置", 'warning')
                        return

            current_file = self.current_playlist[self.current_index]

            # 异步加载和播放音频
            def load_and_play_audio():
                try:
                    pygame.mixer.music.load(current_file)
                    pygame.mixer.music.play(start=seek_pos)
                    self.logger.info(f"异步加载并播放音频，定位到: {seek_pos}秒")
                except Exception as e:
                    self.logger.error(f"异步加载音频失败: {e}", exc_info=True)
                    self.update_status(f"音频加载失败: {str(e)}", 'error')

            threading.Thread(target=load_and_play_audio, daemon=True).start()

            # 更新当前进度（秒）
            self.current_position = seek_pos
            self.last_seek_position = seek_pos  # 记录跳转后的起始位置
            self.last_update_time = time.time()  # 记录跳转时间，用于后续进度计算

            # 清理字幕缓存，避免显示之前文件的字幕
            if hasattr(self, '_last_subtitle'):
                self._last_subtitle = None
                self.logger.debug("清理字幕缓存，避免显示之前文件的字幕")

            # 立即更新字幕（将秒转换为毫秒）
            if self.subtitles:
                current_pos_ms = seek_pos * 1000  # 转换为毫秒
                subtitle = self._find_subtitle_optimized(current_pos_ms, tolerance=200)
                if subtitle:
                    self._update_subtitle_display(subtitle)
                else:
                    self.logger.warning("定位后未找到对应的字幕，字幕显示未更新")

            # 更新时间显示
            current_time = self.format_time(seek_pos)
            total_time = self.format_time(total_length)
            self.time_label.config(text=f"{current_time} / {total_time}")

            # 更新进度条
            self.progress_scale.set(value)

            # 更新状态
            self.update_status(f"跳转到: {current_time}", 'info')
            self.logger.info(f"拖动进度条到: {seek_pos} 秒，字幕时间: {current_pos_ms} 毫秒")

            # 确保播放状态正确
            self.is_playing = True
            self.is_paused_for_delay = False
            if self.is_following:
                self.update_follow_mode(True)  # 保持跟读模式
                self.play_segment()  # 在跟读模式下，重新播放当前段落
            else:
                self.update_follow_mode(False)

            # 更新界面
            self.play_button.config(text="暂停")
            self.toggle_navigation_buttons(False)
            self.toggle_play_button(enable=True)

        except Exception as e:
            self.update_status(f"定位失败: {str(e)}", 'error')
            self.logger.error(f"定位失败: {e}", exc_info=True)
        finally:
            # 清除 seeking 标志并延迟恢复进度更新
            self.is_seeking = False
            self.root.after(1000, self._resume_progress_update)  # 延迟恢复，避免立即干扰

    def seek_relative(self, seconds):
        """相对定位（快进/快退）"""
        self.notify_follow_mode()
        if not self.is_playing or not self.current_playlist:
            return

        # 检查操作频率
        current_time = time.time()
        if hasattr(self, '_last_seek_time') and current_time - self._last_seek_time < 0.5:  # 限制每 0.5 秒操作一次
            self.logger.info("操作过于频繁，已忽略")
            return
        self._last_seek_time = current_time

        try:
            # 设置 seeking 标志
            self.is_seeking = True

            # 取消现有的定时器
            for timer in ['update_timer', '_check_timer', '_playback_delay_timer']:
                if hasattr(self, timer) and getattr(self, timer):
                    self.root.after_cancel(getattr(self, timer))
                    setattr(self, timer, None)

            # 如果处于跟读模式，确保录音线程被正确停止并清理资源
            if self.is_following and hasattr(self.follow_reader, 'is_recording') and self.follow_reader.is_recording:
                self.logger.info("正在录音，停止录音以调整进度")
                self.follow_reader.stop_recording(callback=self.recording_callback)
                self.logger.info("录音已停止，清理临时文件")
                if hasattr(self.follow_reader, 'cleanup_temp_files'):
                    self.follow_reader.cleanup_temp_files()
                self.logger.info("录音资源已清理，准备调整进度")

            if self.is_following:
                if seconds > 0:  # 快进
                    if self.current_segment < len(self.subtitles) - 1:
                        self.current_segment += 1
                        self.current_segment_repeat_count = 0  # 重置重复次数
                        self.update_status(f"快进到第 {self.current_segment + 1} 句", 'info')
                    else:
                        self.logger.info("已经是最后一段")
                        self.update_status("已经是最后一段", 'info')
                        return
                else:  # 快退
                    if self.current_segment > 0:
                        self.current_segment -= 1
                        self.current_segment_repeat_count = 0  # 重置重复次数
                        self.update_status(f"快退到第 {self.current_segment + 1} 句", 'info')
                    else:
                        self.logger.info("已经是第一段")
                        self.update_status("已经是第一段", 'info')
                        return

                subtitle = self.subtitles[self.current_segment]
                new_pos = float(subtitle['start_time']) / 1000.0  # 转换为秒
            else:
                # 普通模式：按时间跳转
                new_pos = max(0, self.current_position + seconds)
                total_length = self.get_current_audio_length()
                new_pos = min(new_pos, total_length)  # 确保不超过总长度

            # 异步加载和播放音频
            current_file = self.current_playlist[self.current_index]
            threading.Thread(target=self._load_and_play_audio, args=(current_file, new_pos), daemon=True).start()

            # 更新当前进度（秒）
            self.current_position = new_pos
            self.last_seek_position = new_pos  # 记录跳转后的起始位置
            self.last_update_time = time.time()  # 记录跳转时间

            # 立即更新字幕（将秒转换为毫秒）
            if self.subtitles:
                current_pos_ms = new_pos * 1000  # 转换为毫秒
                subtitle = self._find_subtitle_optimized(current_pos_ms)
                if subtitle:
                    self._update_subtitle_display(subtitle)

            # 更新显示
            total_length = self.get_current_audio_length()
            if total_length > 0:
                progress = (new_pos / total_length) * 100
                self.progress_scale.set(progress)
            self.time_label.config(text=f"{self.format_time(new_pos)} / {self.format_time(total_length)}")

            # 更新状态
            self.update_status(f"快进/快退到: {self.format_time(new_pos)}", 'info')
            self.logger.info(f"快进/快退到: {new_pos} 秒，字幕时间: {current_pos_ms} 毫秒")

            # 确保播放状态正确
            self.is_playing = True
            self.is_paused_for_delay = False
            if self.is_following:
                self.update_follow_mode(True)  # 保持跟读模式
            else:
                self.update_follow_mode(False)

            # 更新界面
            self.play_button.config(text="暂停")
            self.toggle_navigation_buttons(False)
            self.toggle_play_button(enable=True)

        except Exception as e:
            self.update_status(f"快进快退失败: {str(e)}", 'error')
            self.logger.error(f"快进快退失败: {e}", exc_info=True)
        finally:
            self.is_seeking = False
            self.root.after(1000, self._resume_progress_update)  # 延迟恢复，避免立即干扰

    def _resume_progress_update(self):
        """恢复进度更新"""
        if self.is_playing and not self.is_seeking:
            # 清理所有定时器
            for timer in ['update_timer', '_check_timer', '_playback_delay_timer']:
                if hasattr(self, timer) and getattr(self, timer):
                    self.root.after_cancel(getattr(self, timer))
                    setattr(self, timer, None)

            # 仅在必要时启动定时器
            if not hasattr(self, 'update_timer') or not self.update_timer:
                self.update_timer = self.root.after(600, self.update_progress)
            if not hasattr(self, '_check_timer') or not self._check_timer:
                self._check_timer = self.root.after(2000, self._start_playback_check)

            self.logger.info("进度更新和播放状态检查已恢复")

    def _update_tree_selection(self):
        """改进的树形视图选中更新"""
        try:
            if not self.current_playlist or self.current_index >= len(self.current_playlist):
                return
            current_file = self.current_playlist[self.current_index]
            for folder_id in self.folders:
                for child in self.folder_tree.get_children(folder_id):
                    if os.path.basename(current_file) == self.folder_tree.item(child)['text']:
                        self.folder_tree.selection_set(child)
                        self.folder_tree.see(child)
                        break
        except Exception as e:
            self.logger.error(f"更新树形选择失败: {e}")

    def update_follow_mode(self, enable):
        self.is_following = enable
        self.is_following_active = enable
        self.logger.info(f"跟读模式状态更新: {enable}")

    def notify_follow_mode(self):
        if self.is_following:
            self.update_status("跟读模式下，快进快退将基于段落跳转", 'info')

    def play_current_track(self):
        """播放当前曲目，封装逻辑"""
        try:
            if not self.current_playlist or self.current_index >= len(self.current_playlist):
                self.update_status("无可播放曲目", 'warning')
                return False

            # 更新树形视图中的选择
            self._update_tree_selection()

            # 加载音频文件
            current_file = self.current_playlist[self.current_index]
            # 检查文件是否存在
            if not os.path.exists(current_file):
                self.clean_invalid_folders()
                self.update_status(f"文件不存在: {current_file}", 'error')
                return False

            # 加载字幕
            try:
                self.load_subtitles(current_file)
                self.logger.info(f"字幕加载成功: {current_file}")
            except Exception as e:
                self.logger.error(f"字幕加载失败: {e}")

            # 自动更新字幕预览窗口（如果已打开）
            self.update_subtitle_preview_if_open()

            # 初始化播放器
            pygame.mixer.music.load(current_file)
            # 如果有跳转记录（self.last_seek_position），从跳转位置开始播放
            start_pos = self.last_seek_position if hasattr(self,
                                                           'last_seek_position') and self.last_seek_position is not None else self.current_position
            pygame.mixer.music.play(start=start_pos)
            self.is_playing = True
            self.is_following_active = False  # 取消跟读流程
            self.logger.info(f"从 {self.format_time(start_pos)} 开始播放")
            self.play_button.config(text="暂停")

            # 更新界面状态
            self.toggle_navigation_buttons(False)
            self.toggle_play_button(enable=True)

            # 更新字幕显示
            if self.subtitles:
                current_pos_ms = start_pos * 1000
                subtitle = self._find_subtitle_optimized(current_pos_ms)
                if subtitle:
                    self._update_subtitle_display(subtitle)

            # 更新信息标签和树形视图
            self.update_info_label()
            self._update_tree_selection()
            self.logger.info("界面已更新")

            # 清理旧定时器
            for timer in ['update_timer', '_check_timer', '_playback_delay_timer']:
                if hasattr(self, timer) and getattr(self, timer):
                    self.root.after_cancel(getattr(self, timer))
                    setattr(self, timer, None)
            self.logger.info("旧定时器已清理")

            # 更新进度条和时间显示
            total_length = self.get_current_audio_length()
            if total_length > 0:
                self.current_position = min(start_pos, total_length)
                progress = (self.current_position / total_length) * 100
                self.progress_scale.set(progress)
            else:
                self.progress_scale.set(0)
            self.time_label.config(text=f"{self.format_time(self.current_position)} / {self.format_time(total_length)}")

            # 启动定时器
            if not self.is_seeking:
                self.update_timer = self.root.after(600, self.update_progress)
            self._check_timer = self.root.after(1000, lambda: self._start_playback_check())
            self.logger.info(f"play_current_track 里的位置: {self.current_position} 秒")
            print('play_current_track 里的位置：', self.current_position)

        except Exception as e:
            self.logger.error(f"播放失败: {e}")
            self.update_status(f"播放失败: {str(e)}", 'error')
            self.is_playing = False
            self.is_following_active = False  # 取消跟读流程

    def update_subtitle_preview_if_open(self):
        """如果字幕预览窗口已打开（非编辑状态），则自动更新字幕内容"""
        if not hasattr(self, 'subtitle_edit_window') or self.subtitle_edit_window is None:
            return

        try:
            if not self.subtitle_edit_window.winfo_exists():
                self.subtitle_edit_window = None
                self.subtitle_edit_text = None
                return

            if hasattr(self, 'is_subtitle_editing') and self.is_subtitle_editing:
                self.update_status("字幕编辑模式下不自动更新预览", 'info')
                return

            current_file = self.current_playlist[self.current_index]
            srt_path = os.path.splitext(current_file)[0] + '.srt'

            if os.path.exists(srt_path):
                # 检查文件修改时间
                current_mtime = os.path.getmtime(srt_path)
                if hasattr(self, '_last_srt_mtime') and current_mtime <= self._last_srt_mtime:
                    return  # 文件未修改，无需更新
                self._last_srt_mtime = current_mtime

                # 读取文件内容
                with open(srt_path, 'r', encoding='utf-8') as f:
                    content = f.read()

                # 更新预览窗口
                if hasattr(self, 'subtitle_edit_text') and self.subtitle_edit_text:
                    self.subtitle_edit_text.config(state='normal')
                    self.subtitle_edit_text.delete('1.0', tk.END)
                    self.subtitle_edit_text.insert('1.0', content)
                    self.subtitle_edit_text.config(state='disabled')

                self.subtitle_edit_window.title(f"字幕预览 - {os.path.basename(current_file)}")
                self.update_status("已自动更新字幕预览", 'info')

                # 重新加载字幕数据
                self.load_subtitles(current_file)
            else:
                if hasattr(self, 'subtitle_edit_text') and self.subtitle_edit_text:
                    self.subtitle_edit_text.config(state='normal')
                    self.subtitle_edit_text.delete('1.0', tk.END)
                    self.subtitle_edit_text.config(state='disabled')
                self.subtitle_edit_window.title(f"字幕预览 - {os.path.basename(current_file)} (无字幕)")
                self.update_status(f"字幕文件不存在: {srt_path}", 'warning')
        except Exception as e:
            self.logger.error(f"更新字幕预览失败: {e}")
            self.update_status(f"更新字幕预览失败: {str(e)}", 'error')
            self.subtitle_edit_window = None
            self.subtitle_edit_text = None

    def update_progress(self):
        """更新进度条和时间显示"""
        if not self.is_playing or self.is_seeking:
            return

        # 如果处于编辑状态，跳过更新
        if getattr(self, 'is_editing', False):
            return

        try:
            pos = pygame.mixer.music.get_pos()
            total_length = self.get_current_audio_length()
            if total_length <= 0:
                self.logger.warning("音频长度无效")
                self.progress_scale.set(0)
                self.time_label.config(text=f"{self.format_time(0)} / {self.format_time(0)}")
                return

            # 处理 get_pos() 返回 -1 的情况
            if pos == -1:
                self.logger.info("检测到 get_pos() 返回 -1")
                # 在跟读模式下，避免立即触发 handle_playback_ended
                if self.is_following:
                    self.logger.info("跟读模式下，延迟检查播放状态以避免误判")
                    # 延迟检查，确保不是短暂的缓冲问题
                    self.root.after(1000, self.check_playback_status)
                    return
                else:
                    self.current_position = 0
                    self.progress_scale.set(0)
                    self.time_label.config(text=f"{self.format_time(0)} / {self.format_time(total_length)}")
                    self.logger.info("普通模式下，播放结束或拖动后检测到 get_pos() 返回 -1，调用 handle_playback_ended")
                    self.handle_playback_ended()
                    return

            if pos > 0:
                relative_time = pos / 1000.0  # 将毫秒转换为秒

                # 如果存在 last_seek_position，说明刚进行过拖动，使用 last_seek_position 作为基准
                if hasattr(self, 'last_seek_position') and self.last_seek_position is not None:
                    self.current_position = self.last_seek_position + relative_time
                    # 仅在确认位置稳定后清除 last_seek_position
                    if relative_time > 0.5:  # 确保播放至少持续 0.5 秒，避免立即清除
                        self.last_seek_position = None
                    self.logger.info(f"使用 last_seek_position 更新位置: {self.current_position}秒")
                else:
                    # 使用时间差更新位置
                    if hasattr(self, 'last_update_time') and self.last_update_time:
                        time_diff = time.time() - self.last_update_time
                        if 0 <= time_diff <= 2.0:  # 验证时间差是否合理
                            self.current_position = self._playback.get('last_position', 0) + time_diff
                        else:
                            self.logger.warning(f"时间差异常: {time_diff}秒，重置 last_position 和 last_update_time")
                            self.current_position = relative_time
                    else:
                        self.current_position = relative_time
                    self.logger.info(f"基于时间差更新位置: {self.current_position}秒")

                # 更新 last_position 和 last_update_time
                self._playback['last_position'] = self.current_position
                self.last_update_time = time.time()

            # 跟读模式：限制位置在当前段落范围内
            if self.is_following and self.subtitles and self.current_segment < len(self.subtitles):
                subtitle = self.subtitles[self.current_segment]
                start_time = float(subtitle['start_time']) / 1000.0  # 转换为秒
                end_time = float(subtitle['end_time']) / 1000.0  # 转换为秒
                if self.current_position < start_time:
                    self.current_position = start_time
                elif self.current_position > end_time:
                    self.current_position = end_time
                    self.logger.info("跟读模式下，段落播放结束，延迟检查以避免误判")
                    # 延迟检查，确保不是短暂的缓冲问题
                    self.root.after(1000, self.check_playback_status)
                    return

            # 计算进度
            progress = 0
            if total_length > 0:
                progress = min(100, (self.current_position / total_length) * 100)

            # 更新进度条（仅当变化较大时更新）
            if abs(progress - self.progress_scale.get()) > 0.5:
                self.progress_scale.set(progress)

            # 更新时间显示
            self.time_label.config(text=f"{self.format_time(self.current_position)} / {self.format_time(total_length)}")

            # 更新字幕
            if self.subtitles:
                current_pos_ms = self.current_position * 1000
                subtitle = self._find_subtitle_optimized(current_pos_ms, tolerance=200)
                if subtitle:
                    self._update_subtitle_display(subtitle)

            # 继续定时更新
            if not self.is_seeking:
                self.update_timer = self.root.after(600, self.update_progress)

        except Exception as e:
            self.logger.error(f"更新进度失败: {e}", exc_info=True)

    def _start_playback_check(self):
        """延迟启动播放状态检查"""
        if self.is_playing:
            self._check_timer = self.root.after(2000, self.check_playback_status)

    def check_playback_status(self):
        """改进的播放状态检查，优化跟读模式下的逻辑，防止误判"""
        try:
            if not self.is_playing or self.is_paused_for_delay:
                return

            is_busy = pygame.mixer.music.get_busy()
            current_pos_ms = self.get_accurate_position()  # 获取精确的播放位置（毫秒）

            if not is_busy:
                # 增加额外的延迟检查以确保真正播放结束
                time.sleep(0.6)  # 延长延迟时间到 0.6 秒，避免短暂缓冲问题
                if not pygame.mixer.music.get_busy():
                    self.logger.info("检测到播放结束，准备进一步检查")

                    # 在跟读模式下，检查是否正在录音
                    if self.is_following and hasattr(self.follow_reader,
                                                     'is_recording') and self.follow_reader.is_recording:
                        self.logger.info("跟读模式下，正在录音，延迟结束处理")
                        self._check_timer = self.root.after(1000, self.check_playback_status)  # 延迟 1 秒后再次检查
                        return

                    # 在跟读模式下，结合段落结束时间进行检查
                    if self.is_following and self.subtitles and self.current_segment < len(self.subtitles):
                        subtitle = self.subtitles[self.current_segment]
                        end_time_ms = float(subtitle['end_time'])  # 段落结束时间（毫秒）
                        tolerance_ms = 500  # 容差时间（毫秒），允许一定的缓冲

                        if current_pos_ms >= end_time_ms - tolerance_ms or current_pos_ms == -1:
                            self.logger.info(f"跟读模式下，段落播放结束，当前时间: {current_pos_ms}ms, 结束时间: {end_time_ms}ms")
                            self.handle_playback_ended()
                        else:
                            self.logger.info(f"跟读模式下，播放未结束，当前时间: {current_pos_ms}ms, 结束时间: {end_time_ms}ms")
                            self._check_timer = self.root.after(2000, self.check_playback_status)  # 继续检查
                    else:
                        # 普通模式下，直接触发播放结束处理
                        self.logger.info("普通模式下，播放结束，触发 handle_playback_ended")
                        self.handle_playback_ended()
                else:
                    self.logger.info("播放短暂暂停后恢复，继续检查")
                    self._check_timer = self.root.after(2000, self.check_playback_status)  # 继续检查
            else:
                # 如果仍在播放，降低检查频率（2 秒）
                self._check_timer = self.root.after(2000, self.check_playback_status)

        except Exception as e:
            self.logger.error(f"检查播放状态失败: {e}", exc_info=True)
            # 如果发生异常，继续检查以避免中断
            self._check_timer = self.root.after(2000, self.check_playback_status)

    def on_progress_release(self, event):
        """进度条释放事件，优化跟读模式下的段落定位"""
        try:
            if not self.current_playlist or not self.is_playing:
                self.logger.warning("播放列表为空或未播放，忽略进度调整")
                return

            current_time = time.time()
            if hasattr(self, '_last_seek_time') and current_time - self._last_seek_time < 0.5:
                self.logger.info("拖动过于频繁，已忽略")
                return
            self._last_seek_time = current_time

            pos = self.progress_scale.get()

            # 延迟处理音频加载
            def delayed_seek():
                try:
                    if self.is_following:
                        total_length = self.get_current_audio_length()
                        seek_pos = (pos / 100.0) * total_length  # 转换为秒
                        current_pos_ms = seek_pos * 1000  # 转换为毫秒
                        subtitle = self._find_subtitle_optimized(current_pos_ms, tolerance=200)

                        if subtitle:
                            new_segment = self.subtitles.index(subtitle)
                            if new_segment != self.current_segment:
                                self.current_segment = new_segment
                                self.current_segment_repeat_count = 0  # 重置重复次数
                                self.is_manual_switch = True  # 标记为手动切换
                                self.follow_text.insert('end', f"\n手动切换到第 {self.current_segment + 1} 段\n", 'prompt')
                            start_time = float(subtitle['start_time']) / 1000.0  # 转换为秒
                            self.seek_absolute((start_time / total_length) * 100)
                            self.logger.info(f"跟读模式下，定位到段落 {self.current_segment + 1}，开始时间: {start_time}秒")
                            self.play_segment()  # 重新播放当前段落
                        else:
                            # 拖动位置不在任何段落范围内，尝试找到最接近的段落
                            closest_subtitle = None
                            min_distance = float('inf')
                            for i, sub in enumerate(self.subtitles):
                                start_time_ms = float(sub['start_time'])
                                distance = abs(current_pos_ms - start_time_ms)
                                if distance < min_distance:
                                    min_distance = distance
                                    closest_subtitle = sub
                                    closest_segment = i

                            if closest_subtitle and min_distance < 5000:  # 距离小于 5 秒时，定位到最近段落
                                self.current_segment = closest_segment
                                self.current_segment_repeat_count = 0  # 重置重复次数
                                self.is_manual_switch = True  # 标记为手动切换
                                start_time = float(closest_subtitle['start_time']) / 1000.0  # 转换为秒
                                self.seek_absolute((start_time / total_length) * 100)
                                self.follow_text.insert('end', f"\n定位到最近的第 {self.current_segment + 1} 段\n", 'prompt')
                                self.logger.info(f"跟读模式下，定位到最近段落 {self.current_segment + 1}，开始时间: {start_time}秒")
                                self.play_segment()  # 重新播放最近段落
                            else:
                                self.logger.warning("拖动位置不在任何段落范围内，保持当前进度")
                                self.update_status("未找到对应段落，请拖动到有效位置", 'warning')
                                self.seek_absolute(pos)  # 恢复到拖动位置
                                self.play_current_track()  # 继续播放当前曲目
                    else:
                        # 普通模式下，直接调整播放位置
                        self.seek_absolute(pos)
                        self.play_current_track()  # 继续播放当前曲目

                except Exception as e:
                    self.logger.error(f"延迟调整进度失败: {e}", exc_info=True)
                    self.update_status(f"调整进度失败: {str(e)}", 'error')

            # 减少延迟时间到 200 毫秒，确保响应更快
            self.root.after(200, delayed_seek)

        except Exception as e:
            self.update_status(f"进度调整失败: {str(e)}", 'error')
            self.logger.error(f"进度调整失败: {e}", exc_info=True)
        finally:
            self.is_seeking = False
            self.root.after(1000, self._resume_progress_update)

    def on_progress_press(self, event):
        """进度条按下事件，优化实时预览性能"""
        try:
            self.is_seeking = True
            if hasattr(self, 'update_timer') and self.update_timer:
                self.root.after_cancel(self.update_timer)
                self.update_timer = None

            # 暂停音频播放，避免干扰预览
            if self.is_playing:
                pygame.mixer.music.pause()
                self.is_playing = False

            # 实时更新时间显示和字幕
            def update_preview():
                if self.is_seeking:
                    try:
                        pos = self.progress_scale.get()
                        total_length = self.get_current_audio_length()
                        seek_pos = (pos / 100.0) * total_length  # 转换为秒
                        current_time = self.format_time(seek_pos)
                        total_time = self.format_time(total_length)
                        self.time_label.config(text=f"{current_time} / {total_time}")

                        # 在跟读模式下，优化字幕查找频率
                        if self.is_following and self.subtitles:
                            current_pos_ms = seek_pos * 1000  # 转换为毫秒
                            # 每 200 毫秒更新一次字幕，避免性能开销过大
                            if not hasattr(self,
                                           '_last_subtitle_update') or time.time() - self._last_subtitle_update > 0.2:
                                subtitle = self._find_subtitle_optimized(current_pos_ms, tolerance=200)
                                if subtitle:
                                    self._update_subtitle_display(subtitle)
                                self._last_subtitle_update = time.time()

                        # 每 100 毫秒更新一次时间显示
                        self.root.after(100, update_preview)
                    except Exception as e:
                        self.logger.error(f"实时预览失败: {e}", exc_info=True)
                else:
                    # 拖动结束时，恢复音频播放状态
                    if not self.is_playing:
                        pygame.mixer.music.unpause()
                        self.is_playing = True

            self._last_subtitle_update = 0  # 初始化字幕更新时间
            self.root.after(100, update_preview)

        except Exception as e:
            self.logger.error(f"进度条按下事件失败: {e}", exc_info=True)
            self.update_status(f"进度条操作失败: {str(e)}", 'error')

    def _time_to_ms(self, time_str):
        """将时间字符串（HH:MM:SS,mmm）转换为毫秒"""
        try:
            # 将逗号替换为冒号，以便拆分
            time_parts = time_str.replace(',', ':').split(':')
            if len(time_parts) != 4:
                raise ValueError("时间格式错误，期望格式为 HH:MM:SS,mmm")

            hours, minutes, seconds, milliseconds = map(int, time_parts)
            total_ms = (hours * 3600 + minutes * 60 + seconds) * 1000 + milliseconds
            return total_ms
        except ValueError as e:
            self.logger.error(f"时间格式转换失败: {time_str}, 错误: {e}")
            raise ValueError(f"时间格式错误: {time_str}")
        except Exception as e:
            self.logger.error(f"时间格式转换未知错误: {time_str}, 错误: {e}")
            raise ValueError(f"时间格式转换失败: {time_str}")

    def edit_current_subtitles(self):
        """改进的字幕编辑功能"""
        try:
            if not self.current_playlist or self.current_index >= len(self.current_playlist):
                self.update_status("无可编辑的字幕文件", 'warning')
                return

            current_file = self.current_playlist[self.current_index]
            srt_path = os.path.splitext(current_file)[0] + '.srt'

            if not os.path.exists(srt_path):
                self.update_status("未找到字幕文件", 'warning')
                return

            # 检查文件权限
            if not os.access(srt_path, os.W_OK):
                self.update_status("没有字幕文件的写入权限", 'error')
                return

            # 创建编辑窗口
            edit_window = tk.Toplevel(self.root)
            edit_window.title(f"字幕编辑 - {os.path.basename(current_file)}")
            edit_window.geometry("800x950")

            # 保存窗口引用，以便其他方法可以访问
            self.subtitle_edit_window = edit_window

            # 绑定焦点事件
            edit_window.bind('<FocusIn>', self._on_subtitle_window_focus)

            # 绑定关闭事件
            edit_window.protocol("WM_DELETE_WINDOW", self.close_subtitle_window)

            # 保存当前状态
            was_playing = self.is_playing
            was_following = self.is_following
            current_pos = self.current_position  # 保存当前播放位置
            current_segment = self.current_segment if was_following else None  # 保存当前段落位置

            # 创建主框架和工具栏
            main_frame = ttk.Frame(edit_window)
            main_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

            toolbar = ttk.Frame(main_frame)
            toolbar.pack(fill='x', pady=(0, 5))

            # 创建搜索框架
            search_frame = ttk.LabelFrame(toolbar, text="搜索和替换——需先点击'编辑'按钮进入编辑模式")
            search_frame.pack(side='left', padx=5)

            search_var = tk.StringVar()
            replace_var = tk.StringVar()
            search_entry = ttk.Entry(search_frame, textvariable=search_var, width=20)
            search_entry.pack(side='left', padx=2)
            replace_entry = ttk.Entry(search_frame, textvariable=replace_var, width=20)
            replace_entry.pack(side='left', padx=2)

            # 创建搜索结果标签
            search_result_label = ttk.Label(search_frame, text="")
            search_result_label.pack(side='left', padx=5)

            # 创建文本编辑区和滚动条
            text_frame = ttk.Frame(main_frame)
            text_frame.pack(fill=tk.BOTH, expand=True)

            y_scrollbar = ttk.Scrollbar(text_frame)
            y_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

            edit_text = tk.Text(text_frame, wrap=tk.WORD, undo=True, yscrollcommand=y_scrollbar.set)
            edit_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            y_scrollbar.config(command=edit_text.yview)

            # 保存文本编辑区引用，以便其他方法可以访问
            self.subtitle_edit_text = edit_text

            # 配置初始状态为只读
            edit_text.config(state='disabled')

            # 设置编辑状态标志为False（初始状态为预览模式）
            self.is_subtitle_editing = False

            # 搜索匹配项列表和当前匹配索引
            matches = []
            current_match_index = -1

            def check_edit_mode():
                # print('弹窗1')
                """检查是否处于编辑模式"""
                if edit_text['state'] == 'disabled':
                    self.logger.info("尝试在非编辑模式下操作，弹出提示窗口")
                    # print('弹窗2')
                    edit_window.grab_set()  # 确保编辑窗口获得焦点
                    edit_window.focus_force()  # 强制聚焦
                    messagebox.showinfo("提示", "请先点击'编辑'按钮进入编辑模式", parent=edit_window)
                    return False
                return True

            def find_text(direction='next'):
                """查找文本，支持查找下一个和上一个"""
                if not check_edit_mode():
                    return

                edit_text.tag_remove('search', '1.0', 'end')
                search_text = search_var.get()
                if not search_text:
                    search_result_label.config(text="请输入搜索内容")
                    return

                nonlocal matches, current_match_index
                matches = []
                pos = '1.0'
                while True:
                    pos = edit_text.search(search_text, pos, 'end')
                    if not pos:
                        break
                    end_pos = f"{pos}+{len(search_text)}c"
                    matches.append((pos, end_pos))
                    pos = end_pos

                edit_text.tag_config('search', background='yellow')
                if not matches:
                    search_result_label.config(text="未找到匹配项")
                    current_match_index = -1
                    return

                # 根据方向更新当前匹配索引
                if direction == 'next':
                    current_match_index = (current_match_index + 1) % len(matches)
                elif direction == 'prev':
                    current_match_index = (current_match_index - 1) % len(matches)

                current_pos, current_end_pos = matches[current_match_index]
                edit_text.tag_add('search', current_pos, current_end_pos)
                edit_text.see(current_pos)
                search_result_label.config(text=f"匹配项 {current_match_index + 1}/{len(matches)}")

            def find_next():
                """查找下一个匹配项"""
                find_text(direction='next')

            def find_prev():
                """查找上一个匹配项"""
                find_text(direction='prev')

            def replace_single():
                """替换当前匹配项"""
                if not check_edit_mode():
                    return

                search_text = search_var.get()
                replace_text = replace_var.get()
                if not search_text:
                    search_result_label.config(text="请输入搜索内容")
                    return

                nonlocal matches, current_match_index
                if not matches and current_match_index < 0:
                    search_result_label.config(text="请先查找内容")
                    return

                current_pos, current_end_pos = matches[current_match_index]
                edit_text.delete(current_pos, current_end_pos)
                edit_text.insert(current_pos, replace_text)
                edit_text.tag_remove('search', '1.0', 'end')
                find_text(direction='next')  # 重新查找并高亮
                search_result_label.config(text="已替换当前匹配项")

            def replace_all():
                """替换所有匹配项"""
                if not check_edit_mode():
                    return

                search_text = search_var.get()
                replace_text = replace_var.get()
                if not search_text:
                    search_result_label.config(text="请输入搜索内容")
                    return

                nonlocal matches, current_match_index
                if not matches:
                    search_result_label.config(text="请先查找内容")
                    return

                if messagebox.askyesno("确认替换", "是否替换所有匹配项？"):
                    content = edit_text.get('1.0', 'end')
                    new_content = content.replace(search_text, replace_text)
                    edit_text.delete('1.0', 'end')
                    edit_text.insert('1.0', new_content)
                    edit_text.tag_remove('search', '1.0', 'end')
                    matches = []
                    current_match_index = -1
                    find_text()  # 重新查找并高亮
                    search_result_label.config(text="已替换所有匹配项")

            def validate_subtitles():
                """验证字幕格式"""
                content = edit_text.get('1.0', 'end').strip()
                blocks = content.split('\n\n')
                is_valid = True
                error_msg = []

                for i, block in enumerate(blocks, 1):
                    lines = block.strip().split('\n')
                    if len(lines) < 3:
                        error_msg.append(f"段落 {i}: 格式不完整")
                        is_valid = False
                        continue

                    try:
                        index = int(lines[0])
                    except ValueError:
                        error_msg.append(f"段落 {i}: 序号无效")
                        is_valid = False

                    time_pattern = r'\d{2}:\d{2}:\d{2},\d{3}\s*-->\s*\d{2}:\d{2}:\d{2},\d{3}'
                    if not re.match(time_pattern, lines[1]):
                        error_msg.append(f"段落 {i}: 时间格式错误")
                        is_valid = False
                        continue

                    # 验证时间范围
                    start_time, end_time = lines[1].split(' --> ')
                    start_ms = self._time_to_ms(start_time)
                    end_ms = self._time_to_ms(end_time)
                    if start_ms >= end_ms:
                        error_msg.append(f"段落 {i}: 结束时间早于开始时间")
                        is_valid = False

                    # 验证字幕内容
                    text_content = ' '.join(lines[2:]).strip()
                    if not text_content:
                        error_msg.append(f"段落 {i}: 字幕内容为空")
                        is_valid = False

                return is_valid, '\n'.join(error_msg)

            def start_editing():
                """开始编辑字幕"""
                # 更改编辑状态标志
                self.is_subtitle_editing = True

                # 其他原有的编辑逻辑
                nonlocal current_pos, current_segment
                current_pos = self.current_position
                current_segment = self.current_segment if was_following else None

                # 设置编辑状态标志位
                self.is_editing = True

                # 验证跟读模式下的位置
                if was_following and self.subtitles and current_segment is not None:
                    subtitle = self.subtitles[current_segment]
                    start_time = float(subtitle['start_time']) / 1000.0
                    end_time = float(subtitle['end_time']) / 1000.0
                    current_pos = max(start_time, min(end_time, current_pos))

                # 确保所有播放模式都暂停
                if was_following:
                    self.pause_follow_reading()
                    self.logger.info("跟读模式已暂停")
                if was_playing or self.is_playing:  # 增加状态检查
                    pygame.mixer.music.pause()
                    self.is_playing = False
                    if hasattr(self, 'update_timer') and self.update_timer:
                        self.root.after_cancel(self.update_timer)
                        self.update_timer = None
                    self.logger.info("普通播放模式已暂停")

                edit_text.config(state='normal')
                edit_btn.config(state='disabled')
                save_btn.config(state='normal')
                cancel_btn.config(state='normal')
                format_btn.config(state='normal')
                find_next_btn.config(state='normal')
                find_prev_btn.config(state='normal')
                replace_single_btn.config(state='normal')
                replace_all_btn.config(state='normal')
                self.logger.info("开始编辑字幕")

            def format_subtitles():
                """格式化字幕"""
                if not check_edit_mode():
                    return

                if messagebox.askyesno("确认格式化", "格式化将调整时间格式和文本，是否继续？"):
                    content = edit_text.get('1.0', 'end').strip()
                    blocks = content.split('\n\n')
                    formatted_blocks = []

                    for i, block in enumerate(blocks, 1):
                        lines = block.strip().split('\n')
                        if len(lines) >= 3:
                            time_line = re.sub(r'\s+-->\s+', ' --> ', lines[1])
                            text_lines = [line.strip() for line in lines[2:] if line.strip()]
                            formatted_block = f"{i}\n{time_line}\n{' '.join(text_lines)}"
                            formatted_blocks.append(formatted_block)

                    formatted_content = '\n\n'.join(formatted_blocks)
                    edit_text.delete('1.0', 'end')
                    edit_text.insert('1.0', formatted_content)
                    self.logger.info("字幕已格式化")

            def save_changes():
                """保存更改"""
                if not check_edit_mode():
                    return

                try:
                    content = edit_text.get('1.0', 'end').strip()

                    # 验证字幕格式
                    is_valid, error_msg = validate_subtitles()
                    if not is_valid:
                        if not messagebox.askyesno("格式警告", f"检测到以下问题:\n{error_msg}\n\n是否仍要保存?"):
                            return
                        self.logger.warning("字幕格式验证失败，但用户选择继续保存")

                    # # 创建备份
                    # backup_path = f"{srt_path}.{int(time.time())}.bak"
                    # try:
                    #     shutil.copy2(srt_path, backup_path)
                    #     self.logger.info(f"字幕备份已创建: {backup_path}")
                    # except Exception as e:
                    #     self.logger.warning(f"创建备份失败: {e}")
                    #     if not messagebox.askyesno("备份警告", "备份失败，是否继续保存？"):
                    #         return

                    # 保存新内容
                    with open(srt_path, 'w', encoding='utf-8') as f:
                        f.write(content)
                    self.logger.info(f"字幕已保存到: {srt_path}")

                    # 重新加载字幕
                    self.load_subtitles(current_file)
                    self.logger.info("字幕已重新加载")

                    # 根据之前的状态恢复播放
                    if was_following:
                        self.is_following = True
                        self.current_segment = current_segment if current_segment is not None else 0
                        if self.subtitles and self.current_segment < len(self.subtitles):
                            subtitle = self.subtitles[self.current_segment]
                            start_time = float(subtitle['start_time']) / 1000.0
                            end_time = float(subtitle['end_time']) / 1000.0
                            self.current_position = max(start_time, min(end_time, current_pos))
                        self.play_segment()
                        self.logger.info(f"恢复跟读模式，当前段落: {self.current_segment}")
                    elif was_playing:
                        self.is_playing = True
                        self.current_position = max(0, current_pos)
                        total_length = self.get_current_audio_length()
                        if total_length > 0:
                            self.current_position = min(self.current_position, total_length)
                        self.current_loop = min(self.current_loop, self.loop_count.get() - 1)
                        self.logger.info(
                            f"恢复普通播放模式，当前位置: {self.current_position}秒，当前循环: {self.current_loop}/{self.loop_count.get()}")
                        pygame.mixer.music.stop()
                        self.is_editing_recovery = True
                        # 强制继续播放当前曲目，禁用自动下一曲逻辑
                        self.play_current_track()
                        self.is_editing_recovery = False

                    # 强制更新进度条和时间显示
                    self.update_progress()
                    edit_window.destroy()
                    self.is_editing = False  # 清除编辑状态
                    self.update_status("字幕保存成功", 'success')

                except UnicodeDecodeError as e:
                    self.update_status(f"字幕文件编码错误: {str(e)}", 'error')
                    self.logger.error(f"字幕文件编码错误: {e}")
                except IOError as e:
                    self.update_status(f"保存字幕文件失败: {str(e)}", 'error')
                    self.logger.error(f"保存字幕文件失败: {e}")
                except Exception as e:
                    self.update_status(f"保存失败: {str(e)}", 'error')
                    self.logger.error(f"保存字幕失败: {e}")

            def cancel_editing():
                """取消编辑，恢复播放"""
                # 更改编辑状态标志
                self.is_subtitle_editing = False

                # 其他原有的取消编辑逻辑
                try:
                    # 检查是否有未保存的更改
                    if edit_text.edit_modified():
                        if not messagebox.askyesno("确认", "有未保存的更改，确定要放弃吗？"):
                            return
                    edit_window.destroy()
                    self.is_editing = False  # 清除编辑状态
                    self.logger.info("取消字幕编辑")

                    # 恢复播放状态
                    if was_following:
                        self.is_following = True
                        self.current_segment = current_segment if current_segment is not None else 0
                        if self.subtitles and self.current_segment < len(self.subtitles):
                            subtitle = self.subtitles[self.current_segment]
                            start_time = float(subtitle['start_time']) / 1000.0
                            end_time = float(subtitle['end_time']) / 1000.0
                            self.current_position = max(start_time, min(end_time, current_pos))
                        self.play_segment()
                        self.logger.info(f"恢复跟读模式，当前段落: {self.current_segment}")
                    elif was_playing:
                        self.is_playing = True
                        self.current_position = max(0, current_pos)
                        total_length = self.get_current_audio_length()
                        if total_length > 0:
                            self.current_position = min(self.current_position, total_length)
                        self.current_loop = min(self.current_loop, self.loop_count.get() - 1)
                        self.logger.info(
                            f"恢复普通播放模式，当前位置: {self.current_position}秒，当前循环: {self.current_loop}/{self.loop_count.get()}")
                        pygame.mixer.music.stop()
                        self.is_editing_recovery = True
                        # 强制继续播放当前曲目，禁用自动下一曲逻辑
                        self.play_current_track()
                        self.is_editing_recovery = False

                    # 强制更新字幕显示
                    if self.subtitles:
                        current_pos_ms = self.current_position * 1000
                        subtitle = self._find_subtitle_optimized(current_pos_ms)
                        if subtitle:
                            self._update_subtitle_display(subtitle)

                    # 强制更新进度条和时间显示
                    self.update_progress()

                except Exception as e:
                    self.logger.error(f"取消编辑失败: {e}")
                    self.is_editing = False  # 确保即使发生错误，也清除编辑状态
                    self.update_status(f"取消编辑失败: {str(e)}", 'error')

            # 创建按钮框架
            btn_frame = ttk.Frame(main_frame)
            btn_frame.pack(fill='x', pady=5)

            # 创建按钮
            edit_btn = ttk.Button(btn_frame, text="编辑", command=start_editing)
            edit_btn.pack(side='left', padx=5)

            save_btn = ttk.Button(btn_frame, text="保存", command=save_changes, state='disabled')
            save_btn.pack(side='left', padx=5)

            cancel_btn = ttk.Button(btn_frame, text="取消", command=cancel_editing, state='disabled')
            cancel_btn.pack(side='left', padx=5)

            format_btn = ttk.Button(btn_frame, text="格式化", command=format_subtitles, state='disabled')
            format_btn.pack(side='left', padx=5)

            find_next_btn = ttk.Button(search_frame, text="查找下一个", command=find_next, state='disabled')
            find_next_btn.pack(side='left', padx=2)

            find_prev_btn = ttk.Button(search_frame, text="查找上一个", command=find_prev, state='disabled')
            find_prev_btn.pack(side='left', padx=2)

            replace_single_btn = ttk.Button(search_frame, text="替换", command=replace_single, state='disabled')
            replace_single_btn.pack(side='left', padx=2)

            replace_all_btn = ttk.Button(search_frame, text="全部替换", command=replace_all, state='disabled')
            replace_all_btn.pack(side='left', padx=2)

            # 加载字幕内容并高亮当前段落
            try:
                with open(srt_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                    edit_text.config(state='normal')
                    edit_text.insert('1.0', content)
                    edit_text.config(state='disabled')

                # 高亮当前段落或播放位置
                edit_text.tag_configure('current', background='lightblue')

                def find_text_range(start_ms, end_ms):
                    """根据时间范围找到对应的文本行号和字符位置"""
                    try:
                        lines = edit_text.get('1.0', 'end').strip().split('\n')
                        current_block = None
                        start_line = None
                        end_line = None

                        for i, line in enumerate(lines):
                            # 查找时间行
                            time_pattern = r'\d{2}:\d{2}:\d{2},\d{3}\s*-->\s*\d{2}:\d{2}:\d{2},\d{3}'
                            if re.match(time_pattern, line):
                                block_start_ms = self._time_to_ms(line.split(' --> ')[0])
                                block_end_ms = self._time_to_ms(line.split(' --> ')[1])
                                if block_start_ms <= start_ms <= block_end_ms or block_start_ms <= end_ms <= block_end_ms:
                                    current_block = i  # 记录时间行号
                                    start_line = i + 1  # 字幕内容从下一行开始
                                    # 查找字幕内容的结束行
                                    end_line = start_line
                                    while end_line < len(lines) and lines[end_line].strip() and not re.match(
                                            time_pattern, lines[end_line]):
                                        end_line += 1
                                    end_line -= 1  # 回退到最后一行字幕内容
                                    break

                        if start_line and end_line:
                            return f"{start_line}.0", f"{end_line}.end"
                        else:
                            self.logger.warning(f"未找到时间范围 {start_ms}ms - {end_ms}ms 对应的字幕内容")
                            return None, None
                    except Exception as e:
                        self.logger.error(f"查找时间范围失败: {e}")
                        return None, None

                if was_following and self.subtitles and current_segment is not None and current_segment < len(
                        self.subtitles):
                    subtitle = self.subtitles[current_segment]
                    start_time_ms = subtitle['start_time']
                    end_time_ms = subtitle['end_time']
                    start_index, end_index = find_text_range(start_time_ms, end_time_ms)
                    if start_index and end_index:
                        try:
                            edit_text.tag_add('current', start_index, end_index)
                            edit_text.see(start_index)
                            self.logger.info(f"高亮跟读模式的当前段落: {current_segment}")
                        except Exception as e:
                            self.logger.error(f"高亮跟读模式段落失败: {e}")
                    else:
                        self.logger.warning(f"无法高亮跟读模式的当前段落: {current_segment}")

                elif was_playing and self.subtitles:
                    current_pos_ms = current_pos * 1000  # 转换为毫秒
                    subtitle = self._find_subtitle_optimized(current_pos_ms)
                    if subtitle:
                        start_time_ms = subtitle['start_time']
                        end_time_ms = subtitle['end_time']
                        start_index, end_index = find_text_range(start_time_ms, end_time_ms)
                        if start_index and end_index:
                            try:
                                edit_text.tag_add('current', start_index, end_index)
                                edit_text.see(start_index)
                                self.logger.info(f"高亮普通模式的当前播放位置: {current_pos}秒")
                            except Exception as e:
                                self.logger.error(f"高亮普通模式播放位置失败: {e}")
                        else:
                            self.logger.warning(f"无法高亮普通模式的当前播放位置: {current_pos}秒")
            except UnicodeDecodeError as e:
                self.update_status(f"字幕文件编码错误: {str(e)}", 'error')
                self.logger.error(f"字幕文件编码错误: {e}")
                edit_window.destroy()
                return
            except IOError as e:
                self.update_status(f"读取字幕文件失败: {str(e)}", 'error')
                self.logger.error(f"读取字幕文件失败: {e}")
                edit_window.destroy()
                return
            except Exception as e:
                self.update_status(f"加载字幕时发生未知错误: {str(e)}", 'error')
                self.logger.error(f"加载字幕时发生未知错误: {e}")
                edit_window.destroy()
                return

            # 绑定窗口关闭事件
            def on_closing():
                cancel_editing()

            edit_window.protocol("WM_DELETE_WINDOW", on_closing)

            # 绑定快捷键
            edit_window.bind('<Control-f>',
                             lambda e: find_next() if find_next_btn['state'] == 'normal' else check_edit_mode())
            edit_window.bind('<Control-Shift-F>',
                             lambda e: find_prev() if find_prev_btn['state'] == 'normal' else check_edit_mode())
            edit_window.bind('<Control-h>', lambda e: replace_single() if replace_single_btn[
                                                                              'state'] == 'normal' else check_edit_mode())
            edit_window.bind('<Control-Shift-H>',
                             lambda e: replace_all() if replace_all_btn['state'] == 'normal' else check_edit_mode())
            edit_window.bind('<Control-s>',
                             lambda e: save_changes() if save_btn['state'] == 'normal' else check_edit_mode())
            edit_window.bind('<Escape>', lambda e: cancel_editing() if cancel_btn['state'] == 'normal' else None)
            edit_window.bind('<Control-z>', lambda e: edit_text.edit_undo() if edit_text['state'] == 'normal' else None)
            edit_window.bind('<Control-y>', lambda e: edit_text.edit_redo() if edit_text['state'] == 'normal' else None)

            self.logger.info("字幕编辑窗口已打开")

        except Exception as e:
            self.update_status(f"打开字幕编辑器失败: {str(e)}", 'error')
            self.logger.error(f"打开字幕编辑器失败: {e}")

    def _on_subtitle_window_focus(self, event):
        """字幕窗口获得焦点时，检查并更新字幕内容"""
        self.logger.debug(f"焦点事件触发，当前定时器: {self._focus_debounce_timer}")
        # 取消之前的防抖定时器（如果存在）
        if hasattr(self, '_focus_debounce_timer') and self._focus_debounce_timer is not None:
            try:
                self.root.after_cancel(self._focus_debounce_timer)
                self.logger.debug(f"已取消定时器: {self._focus_debounce_timer}")
            except ValueError:
                self.logger.warning("尝试取消无效的防抖定时器，忽略错误")

        # 设置新的防抖定时器，延迟执行实际的事件处理逻辑
        self._focus_debounce_timer = self.root.after(100, self._handle_focus_event)
        self.logger.debug(f"设置新定时器: {self._focus_debounce_timer}")

    def close_subtitle_window(self):
        """关闭字幕窗口并清理资源"""
        try:
            # 清理防抖定时器（如果存在）
            if hasattr(self, '_focus_debounce_timer') and self._focus_debounce_timer is not None:
                try:
                    self.root.after_cancel(self._focus_debounce_timer)
                    self.logger.debug(f"已取消防抖定时器: {self._focus_debounce_timer}")
                except ValueError:
                    self.logger.warning("尝试取消无效的防抖定时器，忽略错误")
                self._focus_debounce_timer = None

            # 销毁字幕窗口（如果存在）
            if hasattr(self, 'subtitle_edit_window') and self.subtitle_edit_window is not None:
                try:
                    self.subtitle_edit_window.destroy()
                except Exception as e:
                    self.logger.warning(f"销毁字幕窗口失败: {e}")
                self.subtitle_edit_window = None

            # 清理字幕编辑文本框
            if hasattr(self, 'subtitle_edit_text'):
                self.subtitle_edit_text = None

            # 退出编辑模式
            if hasattr(self, 'is_subtitle_editing'):
                self.is_subtitle_editing = False

            self.logger.info("字幕窗口已关闭")
        except Exception as e:
            self.logger.error(f"关闭字幕窗口失败: {e}")

    def _handle_focus_event(self):
        """实际处理焦点事件的逻辑"""
        # 清理防抖定时器
        self._focus_debounce_timer = None

        # 检查窗口是否存在
        if not hasattr(self, 'subtitle_edit_window') or self.subtitle_edit_window is None:
            return

        try:
            # 检查窗口是否仍然存在
            if not self.subtitle_edit_window.winfo_exists():
                self.subtitle_edit_window = None
                self.subtitle_edit_text = None
                return

            # 记录当前曲目信息（可选，用于调试）
            current_file = self.current_playlist[self.current_index] if self.current_playlist else "未知文件"
            self.logger.info(f"字幕窗口获得焦点，当前文件: {current_file}")

            # 根据编辑模式或预览模式处理焦点事件
            if hasattr(self, 'is_subtitle_editing') and self.is_subtitle_editing:
                self._handle_edit_mode_focus()
            else:
                self._handle_preview_mode_focus()
        except Exception as e:
            self.logger.error(f"处理焦点事件失败: {e}")
            self.subtitle_edit_window = None
            self.subtitle_edit_text = None

    def _handle_edit_mode_focus(self):
        """处理编辑模式的焦点事件"""
        # 编辑模式下不更新字幕，但可以记录焦点事件
        self.logger.info("字幕编辑窗口获得焦点（编辑模式）")

    def _handle_preview_mode_focus(self):
        """处理预览模式的焦点事件"""
        self.update_subtitle_preview_if_open()

    def save_subtitles_to_file(self, srt_path, subtitles):
        """保存字幕到文件，支持中英文字幕"""
        try:
            # 备份原始文件
            if os.path.exists(srt_path):
                backup_path = srt_path + '.bak'
                import shutil
                shutil.copy2(srt_path, backup_path)
                self.logger.info(f"已备份原始字幕文件: {backup_path}")

            # 检查文件权限
            if not os.access(os.path.dirname(srt_path), os.W_OK):
                messagebox.showerror("错误", "没有写入权限，请检查文件权限设置")
                self.update_status("没有写入权限，无法保存字幕文件", 'error')
                return False

            with open(srt_path, 'w', encoding='utf-8') as f:
                for i, subtitle in enumerate(subtitles, 1):
                    start_time = self._format_srt_time(subtitle['start_time'])
                    end_time = self._format_srt_time(subtitle['end_time'])
                    f.write(f"{i}\n")
                    f.write(f"{start_time} --> {end_time}\n")
                    if subtitle.get('en_text'):
                        f.write(f"{subtitle['en_text']}\n")
                    if subtitle.get('cn_text'):
                        f.write(f"{subtitle['cn_text']}\n")
                    f.write("\n")

            self.logger.info(f"字幕文件已保存: {srt_path}")
            return True
        except Exception as e:
            self.logger.error(f"保存字幕文件失败: {e}")
            messagebox.showerror("保存失败", f"保存字幕文件失败: {str(e)}")
            self.update_status(f"保存字幕文件失败: {str(e)}", 'error')
            return False

    def pause_follow_reading(self):
        """暂停跟读——手动点击按钮的暂停"""
        if self.is_following:
            self.follow_reader.stop_recording(callback=self.recording_callback)
            self.is_following = False
            self.is_playing = False
            self.is_following_active = False
            pygame.mixer.music.pause()
            self.follow_button.config(text="继续跟读")
            self.logger.info("跟读模式已暂停，所有播放状态已重置")

    def resume_follow_reading(self):
        """继续跟读"""
        if not self.is_following:
            self.is_following = True
            self.follow_button.config(text="停止跟读")
            self.follow_reader.start_recording(callback=self.recording_callback)

    def create_control_buttons(self):
        control_buttons = ttk.Frame(self.control_frame)
        control_buttons.pack(fill="x", pady=5)

        # 创建自定义按钮样式
        style = ttk.Style()
        style.configure('ControlButton.TButton',
                        background='#FFA500',  # 橙色
                        foreground='black',
                        borderwidth=1,
                        relief='raised')
        style.map('ControlButton.TButton',
                  background=[('disabled', '#E0E0E0')],
                  foreground=[('disabled', '#A0A0A0')])

        self.play_button = ttk.Button(control_buttons, text="播放",
                                      command=self.play_pause, style='ControlButton.TButton')
        self.play_button.pack(side="left", padx=5)

        ttk.Button(control_buttons, text="上一曲",
                   command=self.previous_track, style='ControlButton.TButton').pack(side="left", padx=5)
        ttk.Button(control_buttons, text="下一曲",
                   command=self.next_track, style='ControlButton.TButton').pack(side="left", padx=5)
        ttk.Button(control_buttons, text="停止",
                   command=self.stop, style='ControlButton.TButton').pack(side="left", padx=5)

    def toggle_play_button(self, enable=True):
        """启用或禁用播放/暂停按钮"""
        state = "normal" if enable else "disabled"
        self.play_button.config(state=state)
        self.root.update()  # 强制更新界面

    def create_follow_control_buttons(self):
        """创建跟读控制按钮"""
        follow_control_frame = ttk.Frame(self.follow_frame)
        follow_control_frame.pack(fill="x", pady=5)

        # 创建自定义按钮样式
        style = ttk.Style()
        # 正常状态为橙色
        style.configure('NavButton.TButton',
                        background='#FFA500',  # 橙色
                        foreground='black',
                        borderwidth=1,
                        relief='raised')
        # 禁用状态为灰色
        style.map('NavButton.TButton',
                  background=[('disabled', '#E0E0E0')],
                  foreground=[('disabled', '#A0A0A0')])


    def _cleanup_audio_resources(self):
        """改进的音频资源清理功能"""
        try:
            self.follow_reader._stop_recognition = True
            for timer_attr in ['_follow_pause_timer', '_check_timer', '_recognition_timer']:
                if hasattr(self, timer_attr):
                    timer = getattr(self, timer_attr)
                    if timer:
                        self.root.after_cancel(timer)
                        setattr(self, timer_attr, None)
            if pygame.mixer.music.get_busy():
                pygame.mixer.music.stop()
                pygame.mixer.music.unload()
            if hasattr(self, 'follow_reader'):
                if self.follow_reader.is_recording:
                    print('准备停止之前的录音')
                    self.follow_reader.stop_recording(callback=self.recording_callback)
                    time.sleep(0.2)
                if self._recognition_thread and self._recognition_thread.is_alive():
                    print('等待语音识别线程结束')
                    self._recognition_thread.join(timeout=1)
                    if self._recognition_thread.is_alive():
                        self.logger.warning("语音识别线程未能在超时时间内停止")
                self._recognition_thread = None
                for file_attr in ['playback_file', 'transcribe_file']:
                    if hasattr(self.follow_reader, file_attr):
                        file_path = getattr(self.follow_reader, file_attr)
                        if file_path and os.path.exists(file_path):
                            try:
                                with open(file_path, 'a'):
                                    pass
                                os.remove(file_path)
                                self.logger.info(f"已删除音频文件: {file_path}")
                            except (IOError, OSError) as e:
                                self.logger.error(f"删除音频文件失败，可能被占用: {e}")
            self.is_playing = False
            self.is_following_active = False
            self.is_playing_or_recording = False
            self.has_moved = False
            self._start_time = 0
            self._retry_count = 0
            if hasattr(self, '_segment_playing'):
                self._segment_playing = False
            time.sleep(0.1)
            self.logger.info("音频资源已清理")
        except Exception as e:
            self.logger.error(f"清理音频资源失败: {e}")
            self.update_status(f"清理音频资源失败: {str(e)}", 'error')

    def load_audio_with_check(self, audio_file):
        """加载音频并检查是否成功"""
        try:
            start_load = time.time()
            pygame.mixer.music.load(audio_file)
            time.sleep(0.5)  # 等待加载完成
            self.logger.info(f"音频加载耗时: {time.time() - start_load:.2f}秒")
            return True
        except Exception as e:
            self.logger.error(f"加载音频失败: {e}")
            return False

    def play_segment(self):
        """改进的段落播放功能，优化与进度条拖动的配合"""
        if not self.current_playlist:
            self.logger.error("播放列表为空")
            self.update_status("没有可播放的文件", 'error')
            self.stop_follow_reading()
            return

        if not self.subtitles:
            self.logger.warning("字幕数据为空，尝试重新加载")
            self._load_track_subtitles()
            if not self.subtitles:
                self.update_status("无法加载字幕", 'error')
                self.stop_follow_reading()
                return

        if self.current_segment >= len(self.subtitles):
            self.logger.error(f"段落索引越界: {self.current_segment} >= {len(self.subtitles)}")
            self.update_status("段落索引无效", 'error')
            self.stop_follow_reading()
            return

        try:
            self.logger.info(f"播放段落 {self.current_segment + 1}/{len(self.subtitles)}")
            start_cleanup = time.time()
            self._cleanup_audio_resources()  # 清理音频资源
            self.logger.info(f"资源清理耗时: {time.time() - start_cleanup:.2f}秒")

            # 取消所有现有定时器
            for timer in ['update_timer', '_check_timer', '_follow_pause_timer', '_playback_delay_timer']:
                if hasattr(self, timer) and getattr(self, timer):
                    self.root.after_cancel(getattr(self, timer))
                    setattr(self, timer, None)

            # 重置重复次数（仅在非手动切换时）
            if not self.is_manual_switch:
                self.current_segment_repeat_count = 0

            # 更新字幕显示
            subtitle = self.subtitles[self.current_segment]
            self._update_subtitle_display(subtitle)

            # 使用 after 方法延迟播放，避免阻塞主线程
            self.root.after(100, self._play_segment_after_cleanup)

        except Exception as e:
            self.logger.error(f"播放段落失败: {e}", exc_info=True)
            self.update_status(f"播放段落失败: {str(e)}", 'error')
            self._reset_playback_state()
            self.toggle_play_button(enable=False)
            self.toggle_navigation_buttons(enable=False)

    def _play_segment_after_cleanup(self):
        """清理资源后的播放逻辑"""
        try:
            current_file = self.current_playlist[self.current_index]
            subtitle = self.subtitles[self.current_segment]

            subtitle_text = subtitle.get('en_text', '')
            adjusted_max_repeats = self._get_adjusted_repeat_count(subtitle_text)

            self.logger.info(
                f"播放段落 - 文件: {os.path.basename(current_file)}, 段落: {self.current_segment + 1}/{len(self.subtitles)}, "
                f"重复次数: {self.current_segment_repeat_count + 1}/{adjusted_max_repeats}")

            self.show_current_subtitle(subtitle)
            self.root.update()

            start_time = float(subtitle['start_time']) / 1000.0
            end_time = float(subtitle['end_time']) / 1000.0
            duration = end_time - start_time
            # 确保段落时长足够长，避免录音时间不足
            if duration < 2.0:  # 增加最小时长到 2 秒
                duration = 2.0
                end_time = start_time + duration
                self.logger.warning(f"段落时长过短，已调整为 {duration} 秒")

            if self.paused_position is not None and start_time <= self.paused_position <= end_time:
                start_time = self.paused_position
                self.logger.info(f"从暂停位置继续播放: {self.format_time(start_time)}")
                self.paused_position = None
            else:
                self.logger.info(f"从段落起始位置播放: {self.format_time(start_time)}")

            self.logger.info(f"播放段落 - 起止时间: {start_time}s -> {end_time}s")

            self.current_position = start_time
            self.last_seek_position = start_time
            self.last_update_time = time.time()
            self._update_tree_selection()

            total_length = self.get_current_audio_length()
            self.logger.info(f"音频总长度: {self.format_time(total_length)}")
            progress = (start_time / total_length * 100) if total_length > 0 else 0
            self.progress_scale.set(progress)
            self.time_label.config(text=f"{self.format_time(start_time)} / {self.format_time(total_length)}")

            should_play_audio = True
            if should_play_audio:
                start_load = time.time()
                if not self.load_audio_with_check(current_file):
                    self.logger.error("音频加载失败")
                    self.update_status("加载音频失败", 'error')
                    self._reset_playback_state()
                    self.toggle_play_button(enable=False)
                    self.toggle_navigation_buttons(enable=False)
                    return

                self.logger.info(f"音频加载耗时: {time.time() - start_load:.2f}秒")
                self.play_button.config(text="暂停")
                self.update_info_label()

                pygame.mixer.music.set_volume(self._volume / 100.0)
                start_play = time.time()
                threading.Thread(target=self._load_and_play_audio, args=(current_file, start_time), daemon=True).start()
                self.is_playing = True
                self.is_playing_or_recording = True
                self.is_following_active = True
                self.has_moved = False
                self.logger.info(f"音频播放开始耗时: {time.time() - start_play:.2f}秒")

                self.toggle_play_button(enable=True)
                self.toggle_navigation_buttons(enable=True)

            if self.is_following:
                pause_time = int((end_time - start_time) * 1000)
                self.logger.info(f"设置音频播放时间: {pause_time}ms")
                if pause_time > 0:
                    self._follow_pause_timer = self.root.after(pause_time, self.pause_for_follow)
                else:
                    self.logger.warning("播放时间过短，跳过跟读模式")
                    self.pause_for_follow()  # 直接调用 pause_for_follow，避免定时器问题

            if self.is_playing and not self.is_seeking:
                self.update_timer = self.root.after(600, self.update_progress)

            self.logger.info(f"段落播放开始 - 时间: {self.format_time(start_time)} -> {self.format_time(end_time)}")
            self.update_status(f"正在播放第 {self.current_segment + 1} 句 "
                               f"(重复 {self.current_segment_repeat_count + 1}/{adjusted_max_repeats})", 'info')

        except Exception as e:
            self.logger.error(f"播放段落失败: {e}", exc_info=True)
            self.update_status(f"播放段落失败: {str(e)}", 'error')
            self._reset_playback_state()
            self.toggle_play_button(enable=False)
            self.toggle_navigation_buttons(enable=False)

    def _reset_playback_state(self):
        """重置播放状态"""
        self.is_playing = False
        self.is_following_active = False
        self.is_playing_or_recording = False


    def stop_playback(self):
        """停止播放并重置状态"""
        try:
            pygame.mixer.music.stop()
            self.is_playing = False
            self.is_following_active = False  # 跟读流程需取消
            self.is_playing_or_recording = False
            self.has_moved = False
            self.update_status("播放已停止", 'info')
        except Exception as e:
            self.logger.error(f"停止播放失败: {e}")
            self.update_status("停止播放失败", 'error')

    def toggle_follow_checking(self):
        self.check_follow_enabled = not getattr(self, 'check_follow_enabled', True)
        if not self.is_following and not self.follow_text.winfo_ismapped():
            self.logger.info("普通模式下确保字幕组件可见")
            self.follow_text.pack()  # 或其他显示方法
        self.update_status(
            f"跟读检测已{'启用' if self.check_follow_enabled else '禁用'}",
            'info'
        )

    def _load_track_subtitles(self):
        """加载当前曲目的字幕"""
        try:
            if self.current_playlist and 0 <= self.current_index < len(self.current_playlist):
                current_file = self.current_playlist[self.current_index]
                self.subtitles = []
                self.load_subtitles(current_file)
        except Exception as e:
            self.logger.error(f"加载字幕失败: {e}")

    def create_text_editor(self):
        """创建文本编辑区域"""
        # 创建文本编辑框架
        text_edit_frame = ttk.LabelFrame(self.control_frame, text="学习记录")
        text_edit_frame.pack(fill="x", pady=5)

        # 创建文本编辑区
        self.text_editor = tk.Text(text_edit_frame, height=3, width=40)
        self.text_editor.pack(pady=5, padx=5, fill="x")

        # 创建保存按钮
        save_btn = ttk.Button(text_edit_frame, text="保存", command=self.save_editor_text)
        save_btn.pack(side="right", padx=5, pady=2)

        # 加载已保存的文本
        self.load_editor_text()

        # 如果文本编辑器为空，添加默认提示文本
        if not self.text_editor.get("1.0", "end-1c"):
            default_text = "该记录仅供临时用，为防止你清理内存造成记录丢失，务必自行存储到可靠位置"
            self.text_editor.insert("1.0", default_text)

    def save_editor_text(self):
        """保存编辑器文本到临时文件"""
        try:
            text = self.text_editor.get("1.0", "end-1c")
            with open(self.temp_text_file, 'w', encoding='utf-8') as f:
                f.write(text)
            self.update_status("文本已保存", 'success')
            # 如果 TextEditorWindow 已打开，更新其内容
            if hasattr(self,
                       'text_editor_window') and self.text_editor_window is not None and self.text_editor_window.window.winfo_exists():
                self.text_editor_window.load_text()
        except Exception as e:
            self.update_status(f"保存文本失败: {str(e)}", 'error')

    def load_editor_text(self):
        """从临时文件加载文本到编辑器"""
        try:
            if os.path.exists(self.temp_text_file):
                with open(self.temp_text_file, 'r', encoding='utf-8') as f:
                    text = f.read()
                self.text_editor.delete("1.0", "end")
                self.text_editor.insert("1.0", text)
        except Exception as e:
            self.update_status(f"加载文本失败: {str(e)}", 'error')

    def play_editor_text(self):
        """播放编辑器中的文本"""
        text = self.text_editor.get("1.0", "end-1c")
        if len(text.strip()) >= 4:
            pygame.mixer.music.stop()
            self.is_playing = False
            self.is_following_active = False  # 跟读流程需取消
            time.sleep(0.5)  # 等待当前音频停止

            engine = pyttsx3.init()
            engine.setProperty('volume', 1.0)
            # 设置语速，数值越低语速越慢（例如 130 为比较平缓自然的语速）
            engine.setProperty('rate', 100)
            voices = engine.getProperty('voices')
            selected_voice = None
            # 遍历系统语音，寻找名称中包含"David"的男中音（如Microsoft David Desktop）
            for voice in voices:
                if "David" in voice.name:
                    selected_voice = voice.id
                    break
            if selected_voice:
                engine.setProperty('voice', selected_voice)
            else:
                self.logger.warning("未找到预设男中音, 使用默认语音")

            engine.say(text)
            engine.runAndWait()

            # 恢复原音频播放
            if self.current_playlist:
                self.play_current_track()

    # 添加到 AudioPlayer 类中的新方法
    def read_last_chinese_sentence(self):
        """
        从 self.subtitles 中提取所有字幕的中文内容，
        按时间顺序拼接后，采用中文标点分割，
        取最后一句（字符数大于4）进行TTS朗读。
        """
        try:
            if not self.subtitles:
                self.logger.info("没有字幕数据，不进行朗读")
                return

            # 假设每个字幕是字典，包含 'cn_text' 字段（中文内容）
            all_text = " ".join(
                sub.get('cn_text', '').strip() for sub in sorted(self.subtitles, key=lambda x: x['start_time']))
            if not all_text:
                self.logger.info("字幕中没有中文内容")
                return

            # 使用中文标点('.','。','？','！')分割句子
            sentences = re.split(r'[。？！\.]', all_text)
            sentences = [s.strip() for s in sentences if s.strip()]
            if not sentences:
                self.logger.info("分割后没有有效句子")
                return
            last_sentence = sentences[-1]
            if len(last_sentence) <= 0:
                self.logger.info("最后一句中文太短，不朗读")
                return

            engine = pyttsx3.init()
            engine.setProperty('rate', 110)
            engine.setProperty('volume', 1.0)
            voices = engine.getProperty('voices')
            selected_voice = None
            # 遍历系统语音，寻找名称中包含"David"的男中音（如Microsoft David Desktop）
            for voice in voices:
                if "David" in voice.name:
                    selected_voice = voice.id
                    break
            if selected_voice:
                engine.setProperty('voice', selected_voice)
            else:
                self.logger.warning("未找到预设男中音, 使用默认语音")

            engine.say(last_sentence)
            engine.runAndWait()
            self.logger.info(f"朗读最后一句中文: {last_sentence}")
        except Exception as e:
            self.logger.error(f"朗读最后一句中文失败: {e}")


class TextEditorWindow:
    def __init__(self, parent, player):
        # print("Initializing TextEditorWindow")
        # print(f"Parent exists: {parent.winfo_exists()}")
        self.window = tk.Toplevel(parent)
        self.window.title("学习记录")
        self.window.geometry("600x800")
        self.player = player
        self.is_modified = False  # 跟踪文本是否被修改

        # 确保窗口显示
        self.window.lift()  # 将窗口置于顶层
        self.window.focus_force()  # 强制聚焦
        # print(f"TextEditorWindow created: {self.window.winfo_exists()}")

        # 创建文本编辑区
        self.text_frame = ttk.Frame(self.window)
        self.text_frame.pack(fill="both", expand=True, padx=10, pady=5)

        # 文本编辑区，启用撤销功能
        self.text_editor = tk.Text(self.text_frame, wrap=tk.WORD, undo=True, maxundo=-1)
        self.text_editor.pack(fill="both", expand=True)

        # 绑定文本修改事件
        self.text_editor.bind("<<Modified>>", self.on_text_modified)

        # 绑定快捷键（增强默认行为）
        self.text_editor.bind("<Control-a>", self.select_all)
        self.text_editor.bind("<Control-z>", lambda e: self.text_editor.edit_undo() or "break")
        self.text_editor.bind("<Control-y>", lambda e: self.text_editor.edit_redo() or "break")
        self.text_editor.bind("<Control-c>", lambda e: self.text_editor.event_generate("<<Copy>>") or "break")
        self.text_editor.bind("<Control-x>", lambda e: self.text_editor.event_generate("<<Cut>>") or "break")
        self.text_editor.bind("<Control-v>", self.on_paste)  # 使用自定义粘贴处理函数

        # 加载已保存的文本
        self.load_text()

        # 按钮区域
        btn_frame = ttk.Frame(self.window)
        btn_frame.pack(fill="x", padx=10, pady=5)

        ttk.Button(btn_frame, text="保存", command=self.save_text).pack(side="left", padx=5)
        ttk.Button(btn_frame, text="清空", command=self.clear_text).pack(side="left", padx=5)

        # 绑定关闭事件
        self.window.protocol("WM_DELETE_WINDOW", self.on_closing)

    def on_paste(self, event=None):
        """自定义粘贴处理函数，防止重复粘贴"""
        # print("Paste event triggered")
        try:
            # 执行粘贴操作
            self.text_editor.event_generate("<<Paste>>")
            # print("Paste operation completed")
        except Exception as e:
            print(f"Paste error: {str(e)}")
        return "break"  # 阻止事件传播，防止重复触发

    def on_text_modified(self, event=None):
        """当文本被修改时，标记为已修改"""
        if self.text_editor.edit_modified():
            self.is_modified = True
            # print(f"Text modified, is_modified set to True")
        self.text_editor.edit_modified(False)  # 重置修改标志

    def save_text(self):
        """保存文本内容"""
        try:
            text = self.text_editor.get("1.0", "end-1c")
            with open(self.player.temp_text_file, 'w', encoding='utf-8') as f:
                f.write(text)
            self.is_modified = False
            print("Text saved, is_modified set to False")
            self.show_auto_close_message("成功", "文本已保存", duration=2000)  # 自动关闭，持续2秒
        except Exception as e:
            messagebox.showerror("错误", f"保存失败: {str(e)}")

    def show_auto_close_message(self, title, message, duration=2000):
        """显示自动关闭的通知窗口"""
        # 创建通知窗口
        notification = tk.Toplevel(self.window)
        notification.title(title)
        notification.geometry("300x100")
        notification.resizable(False, False)
        notification.transient(self.window)  # 设置为临时窗口，保持在主窗口之上
        notification.grab_set()  # 捕获焦点，防止用户操作主窗口

        # 居中显示
        self.center_window(notification)

        # 显示消息
        label = ttk.Label(notification, text=message, font=("Arial", 12))
        label.pack(pady=20, padx=20)

        # 在指定时间后自动关闭
        notification.after(duration, notification.destroy)

    def center_window(self, window):
        """将窗口居中显示"""
        window.update_idletasks()
        width = window.winfo_width()
        height = window.winfo_height()
        x = (window.winfo_screenwidth() // 2) - (width // 2)
        y = (window.winfo_screenheight() // 2) - (height // 2)
        window.geometry(f"{width}x{height}+{x}+{y}")

    def load_text(self):
        """加载已保存的文本"""
        try:
            if os.path.exists(self.player.temp_text_file):
                # 禁用修改事件，防止加载文本触发 <<Modified>>
                self.text_editor.bind("<<Modified>>", lambda e: "break")
                self.text_editor.delete("1.0", "end")
                with open(self.player.temp_text_file, 'r', encoding='utf-8') as f:
                    text = f.read()
                self.text_editor.insert("1.0", text)
                # 重新启用修改事件
                self.text_editor.bind("<<Modified>>", self.on_text_modified)
                # 重置撤销栈
                self.text_editor.edit_reset()
            self.is_modified = False
            print(f"Text loaded, is_modified set to False")
        except Exception as e:
            messagebox.showerror("错误", f"加载文本失败: {str(e)}")

    def clear_text(self):
        """清空文本"""
        if messagebox.askyesno("确认", "确定要清空文本吗?"):
            # 禁用修改事件，防止清空文本触发 <<Modified>>
            self.text_editor.bind("<<Modified>>", lambda e: "break")
            self.text_editor.delete("1.0", "end")
            # 重新启用修改事件
            self.text_editor.bind("<<Modified>>", self.on_text_modified)
            # 重置撤销栈
            self.text_editor.edit_reset()
            self.is_modified = True
            print(f"Text cleared, is_modified set to True")

    def select_all(self, event=None):
        """全选文本"""
        self.text_editor.tag_add("sel", "1.0", "end-1c")
        self.text_editor.mark_set("insert", "1.0")
        self.text_editor.see("insert")
        return "break"  # 阻止默认行为

    def on_closing(self):
        """关闭窗口前检查是否需要保存"""
        print("Closing TextEditorWindow")
        print(f"is_modified before closing: {self.is_modified}")
        if self.is_modified:
            # 如果文本被修改，提示是否保存
            response = messagebox.askyesnocancel("未保存的更改", "文本已修改，是否保存更改？")
            if response is True:  # 用户选择保存
                self.save_text()
                self.window.destroy()
            elif response is False:  # 用户选择不保存
                self.window.destroy()
            else:  # 用户取消关闭
                print("Closing canceled")
                return
        else:
            # 如果文本未修改，直接关闭
            self.window.destroy()
        # 清理引用，防止下次打开时引用已销毁的窗口
        self.player.text_editor_window = None
        print("TextEditorWindow closed and reference cleared")


# 配置文件目录
CONFIG_DIR = os.path.join(os.path.expanduser("~"), ".audio_player", "config")
CONFIG_FILE = os.path.join(CONFIG_DIR, "config.json")

# 默认配置文件内容
DEFAULT_CONFIG = {
    "agreed_to_terms": False,  # 是否同意协议
    "last_agreement_time": 0,  # 上次同意协议的时间戳（秒）
    "last_weekly_check": 0,  # 上次每周检查的时间戳（秒）
    "volume": 50,  # 示例：默认音量
    "theme": "light",  # 示例：默认主题
    "language": "zh-CN"  # 示例：默认语言
}


def ensure_config_dir():
    """确保配置文件目录存在"""
    try:
        if not os.path.exists(CONFIG_DIR):
            os.makedirs(CONFIG_DIR)
    except Exception as e:
        messagebox.showerror("错误", f"无法创建配置文件目录: {str(e)}")
        print(f"创建配置文件目录失败: {e}")


def load_config():
    """加载配置文件"""
    ensure_config_dir()
    print('开始加载配置')
    if os.path.exists(CONFIG_FILE):
        try:
            # 检查文件是否为空
            if os.path.getsize(CONFIG_FILE) == 0:
                print(f"配置文件 {CONFIG_FILE} 为空，生成默认配置文件")
                save_config(DEFAULT_CONFIG)  # 写入默认配置
                return DEFAULT_CONFIG
            with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except json.JSONDecodeError as e:
            # 如果 JSON 解析失败，返回默认配置
            messagebox.showerror("错误", f"配置文件格式错误，已重置为默认配置: {str(e)}")
            print(f"加载配置文件失败: {e}")
            save_config(DEFAULT_CONFIG)  # 重置为默认配置
            return DEFAULT_CONFIG
        except Exception as e:
            messagebox.showerror("错误", f"加载配置文件失败: {str(e)}")
            print(f"加载配置文件失败: {e}")
            return DEFAULT_CONFIG
    else:
        # 如果文件不存在，生成默认配置文件
        print(f"配置文件 {CONFIG_FILE} 不存在，生成默认配置文件")
        save_config(DEFAULT_CONFIG)
        return DEFAULT_CONFIG


def save_config(config):
    """保存配置文件"""
    ensure_config_dir()
    try:
        with open(CONFIG_FILE, 'w', encoding='utf-8') as f:
            json.dump(config, f, ensure_ascii=False, indent=4)
        print(f"配置文件已保存到 {CONFIG_FILE}")
    except Exception as e:
        messagebox.showerror("错误", f"保存配置文件失败: {str(e)}")
        print(f"保存配置文件失败: {e}")

def show_agreement_window(root, on_agree_callback):
    """显示使用协议弹窗 - 美化版"""
    print('显示协议')
    # 创建模态窗口
    agreement_window = tk.Toplevel(root)
    agreement_window.title("使用协议")
    agreement_window.resizable(False, False)
    agreement_window.transient(root)  # 设置为临时窗口，保持在主窗口之上
    agreement_window.grab_set()  # 捕获焦点，防止用户操作主窗口

    # 设置窗口初始尺寸
    window_width = 700
    window_height = 800
    agreement_window.geometry(f"{window_width}x{window_height}")

    # 创建标题栏 - 使用暖色调
    title_frame = ttk.Frame(agreement_window, style="Title.TFrame")
    title_frame.pack(fill="x", padx=0, pady=0)

    # 设置标题栏样式
    style = ttk.Style()
    style.configure("Title.TFrame", background="#E67E22")  # 暖橙色

    # 标题文本
    title_label = ttk.Label(title_frame, text="使用协议",
                            font=("Microsoft YaHei", 18, "bold"),
                            foreground="white", background="#E67E22")
    title_label.pack(pady=15)

    # 协议内容框架
    content_frame = ttk.Frame(agreement_window, padding=10)
    content_frame.pack(fill="both", expand=True, padx=15, pady=10)

    # 添加滚动条
    scrollbar = ttk.Scrollbar(content_frame)
    scrollbar.pack(side="right", fill="y")

    # 设置文本区域样式
    text_widget = tk.Text(content_frame, wrap=tk.WORD,
                          font=("Microsoft YaHei", 10),
                          yscrollcommand=scrollbar.set,
                          background="#FFFAF0",  # 暖色调背景
                          foreground="#333333",
                          padx=10, pady=10,
                          highlightthickness=0,
                          borderwidth=1,
                          relief="solid")

    # 在此添加协议文本内容 (保持原始文本不变)
    agreement_text = """
        【使用协议】

        欢迎使用外语口语练习助手！请阅读以下条款：

        1. 使用时请尊重知识产权，使用没有给人挖坑的正版学习资料，为了自己和在乎的人的劳动能被尊重，给在乎的人打造一个尊重真诚者的劳动成果的环境，可能比一味地省钱更有价值。实在困难的，可以真诚地向公益机构寻求帮助。
        2. 本软件仅供个人学习使用,为了支持大家世代智慧勇敢，支持学习研究本软件的代码，计划开源初级版供大家自行迭代升级以更好的学习编程，但禁止未经许可用于任何商业行为，禁止未经授权而修改、模仿用于发布。  
        3. 如果上传和本软件的使用、开发等相关的内容到互联网，或给他人，需自行确保合法性，本软件不对用户的行为及其后果负责。
        4. 未来版本可能收集必要使用数据改进体验，但会依法严格保护用户隐私，只会用于真正合法合理且必要的用途。
        5. 使用本软件的过程中请遵守相关法律法规，不得借助本软件做任何坑人害人或其它违法事情，若有一律后果自负。
        6. 欢迎参与开源改进，或邀请他人完善功能。老师们可以把该软件直接分发给学生或家长，但禁止机构或个人用本软件培训学生而收费，需要公开使用，必须是先公开，然后在课堂上使用.
        7. 为了支持更多人快速学好英语，允许在直播间使用本软件，但是，至少必须明确注明本软件的下载地址，否则一律视为恶意商业行为。
        8. 使用中，请务必将本软件分享给任何真诚帮过你，而且没有挖坑迹象和记录的亲友，可以通过朋友圈或群间接分享，但请务必帮他们进步，带他们进步，他们拒绝、不屑等待，那都是他们的问题。
        9. 由于能力有限，见识有限，本软件肯定不能让人完全满意，欢迎一起改进，但建议和那些随便挑刺儿的人保持距离，因为如果你的某个同事或熟人是那样的人，你帮他之后，他大概率也并不会在乎你，还会嫌你做得不好，那是一种深深的习惯。
        

        【其它推荐学习资源】
        先把赠送的学好，愿意的话，联系我，多交流。

        点击"同意"继续使用本软件。
        """

    text_widget.insert("1.0", agreement_text)
    text_widget.config(state="disabled")  # 禁用编辑
    text_widget.pack(fill="both", expand=True)

    scrollbar.config(command=text_widget.yview)

    # 按钮区域 - 使用暖色调背景
    btn_frame = ttk.Frame(agreement_window, style="Footer.TFrame")
    btn_frame.pack(fill="x", pady=0)

    # 设置按钮区域样式
    style.configure("Footer.TFrame", background="#FFF8E8")  # 浅暖橙色

    # 内部按钮容器
    inner_btn_frame = ttk.Frame(btn_frame, style="Footer.TFrame")
    inner_btn_frame.pack(fill="x", padx=15, pady=15)

    # 倒计时标签 - 暖色调样式
    countdown_label = ttk.Label(inner_btn_frame, text="请等待 5 秒...",
                                font=("Microsoft YaHei", 10),
                                foreground="#FF7B54",  # 更明亮的橙红色
                                background="#FFF8E8")
    countdown_label.pack(side="left", padx=5)

    # 使用传统 tk.Button 替代 ttk.Button
    # 使用tk.Button替代ttk.Button - 同意按钮
    agree_button = tk.Button(inner_btn_frame,
                             text="同意",
                             font=("Microsoft YaHei", 10, "bold"),
                             bg="#FF9F45",  # 背景色：明亮橙色
                             fg="white",  # 文字颜色：白色
                             activebackground="#E67E22",  # 鼠标悬停时的背景色
                             activeforeground="white",  # 鼠标悬停时的文字颜色
                             state="disabled",
                             width=8,  # 固定宽度
                             height=1,  # 固定高度
                             padx=10,
                             relief="raised",
                             command=lambda: on_agree(agreement_window, on_agree_callback))
    agree_button.pack(side="right", padx=5)

    # 使用tk.Button替代ttk.Button - 不同意按钮
    disagree_button = tk.Button(inner_btn_frame,
                                text="不同意",
                                font=("Microsoft YaHei", 10),
                                bg="#FFD384",  # 背景色：温暖的黄色
                                fg="black",  # 文字颜色：黑色
                                activebackground="#FFC266",  # 鼠标悬停时的背景色
                                activeforeground="black",  # 鼠标悬停时的文字颜色
                                width=8,  # 与同意按钮相同的宽度
                                height=1,  # 固定高度
                                padx=10,
                                relief="raised",
                                command=lambda: on_disagree(agreement_window))
    disagree_button.pack(side="right", padx=5)

    # 倒计时功能
    def update_countdown(seconds_left):
        if seconds_left > 0:
            countdown_label.config(text=f"请等待 {seconds_left} 秒...")
            agreement_window.after(1000, update_countdown, seconds_left - 1)
        else:
            countdown_label.config(text="开始选择")  # 倒计时结束，更新文本
            agree_button.config(state="normal")  # 启用"同意"按钮

    # 启动倒计时 - 减少到5秒
    update_countdown(5)

    # 防止窗口关闭
    agreement_window.protocol("WM_DELETE_WINDOW", lambda: on_disagree(agreement_window))

    # 居中显示窗口
    center_window(agreement_window, window_width, window_height)

    # 返回窗口对象，以便主程序可以等待它关闭
    return agreement_window


def center_window(window, width=None, height=None):
    """居中显示窗口"""
    # 如果提供了宽度和高度，直接使用
    if width is None or height is None:
        window.update_idletasks()  # 强制更新窗口布局
        width = window.winfo_width()
        height = window.winfo_height()
        # 如果宽度或高度仍然接近 0，使用默认值或 geometry 设置的值
        if width <= 1 or height <= 1:
            geom = window.geometry()  # 获取 geometry 设置的值，例如 "600x400+0+0"
            width = int(geom.split('x')[0])
            height = int(geom.split('x')[1].split('+')[0])

    # 计算居中位置
    screen_width = window.winfo_screenwidth()
    screen_height = window.winfo_screenheight()
    x = (screen_width - width) // 2
    y = (screen_height - height) // 2

    # 设置窗口位置和尺寸
    window.geometry(f"{width}x{height}+{x}+{y}")


def is_new_week(last_time):
    """检查是否是新的一周（以周一为一周的开始）"""
    if last_time == 0:
        return True
    last_date = datetime.datetime.fromtimestamp(last_time)
    current_date = datetime.datetime.now()

    # 获取周一的日期
    last_monday = last_date - datetime.timedelta(days=last_date.weekday())
    current_monday = current_date - datetime.timedelta(days=current_date.weekday())

    return current_monday > last_monday


def on_agree(agreement_window, callback):
    """用户同意协议后的处理"""
    config = load_config()
    current_time = int(time.time())
    config["agreed_to_terms"] = True
    config["last_agreement_time"] = current_time
    config["last_weekly_check"] = current_time
    save_config(config)
    agreement_window.destroy()

    # 显示问卷窗口
    root = agreement_window.master

def on_disagree(agreement_window):
    """用户不同意协议"""
    print("用户不同意协议")
    messagebox.showinfo("提示", "您必须同意使用协议才能继续使用本软件。", parent=agreement_window)
    config = load_config()
    config["agreed_to_terms"] = False
    save_config(config)
    agreement_window.destroy()


def start_player(root):
    """启动播放器主界面"""
    try:
        # print('启动窗口1')
        player = AudioPlayer(root)  # 假设 AudioPlayer 类已定义
        player.start()
        # print('启动窗口2')
        root.mainloop()  # 启动主循环
    except Exception as e:
        messagebox.showerror("错误", f"程序启动失败: {str(e)}", icon='error')
        root.destroy()


def setup_global_logging(log_dir=None, log_level=logging.INFO):
    """配置全局日志系统，仅设置日志级别"""
    if log_dir is None:
        log_dir = os.path.join(os.path.expanduser('~'), '.audio_player', 'logs')
    os.makedirs(log_dir, exist_ok=True)

    root_logger = logging.getLogger()
    root_logger.setLevel(log_level)
    root_logger.handlers = []  # 清空默认处理器

    return log_dir

# 示例：为特定模块获取日志记录器
def get_logger(name, log_dir=None, log_level=logging.INFO):
    """获取模块特定的日志记录器，按模块名生成日志文件"""
    logger = logging.getLogger(name)
    logger.setLevel(log_level)

    # 如果未指定日志目录，使用默认目录 ~/.audio_player/logs
    if log_dir is None:
        log_dir = os.path.join(os.path.expanduser('~'), '.audio_player', 'logs')
    os.makedirs(log_dir, exist_ok=True)

    # 日志文件名（按模块名和日期生成）
    log_filename = os.path.join(log_dir, f'{name}_{time.strftime("%Y%m%d")}.log')

    # 避免重复添加处理器
    if not logger.handlers:
        # 创建文件处理器
        file_handler = TimedRotatingFileHandler(
            log_filename,
            when="midnight",
            interval=1,
            backupCount=7,
            encoding='utf-8'
        )
        file_formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        file_handler.setFormatter(file_formatter)
        file_handler.setLevel(log_level)
        logger.addHandler(file_handler)

        # 创建控制台处理器
        console_handler = logging.StreamHandler()
        console_handler.setLevel(logging.INFO if os.getenv("DEBUG", "0") == "1" else logging.WARNING)
        console_formatter = logging.Formatter('%(name)s - %(levelname)s - %(message)s')
        console_handler.setFormatter(console_formatter)
        logger.addHandler(console_handler)

    return logger

# 用于跟踪是否已显示警告窗口
_warning_shown = False

def get_ffmpeg_path():
    """获取FFmpeg可执行文件路径，优先使用项目目录中的版本"""
    # 获取当前脚本的目录或PyInstaller打包后的目录
    ffmpeg_path = get_resource_path(os.path.join("ffmpeg", "ffmpeg"))

    if sys.platform == "win32":
        ffmpeg_path += ".exe"

    # 如果项目目录存在FFmpeg，直接返回
    if os.path.exists(ffmpeg_path):
        return ffmpeg_path

    # 如果项目目录不存在，尝试在系统PATH中查找
    try:
        # print('项目路径下没有，去系统文件找ffmpeg：', ffmpeg_path)
        if sys.platform == "win32":
            # Windows下使用where命令
            result = subprocess.run(
                ["where", "ffmpeg"],
                capture_output=True,
                text=True,
                check=True,
                creationflags=subprocess.CREATE_NO_WINDOW
            )
            return result.stdout.strip().split('\n')[0]
        else:
            # Linux/Mac下使用which命令
            result = subprocess.run(["which", "ffmpeg"], capture_output=True, text=True, check=True)
            return result.stdout.strip()
    except:
        # 如果系统PATH中也找不到，返回命令名称供环境变量查找
        return "ffmpeg"

def check_ffmpeg_availability(is_admin=False):
    """检查FFmpeg是否可用，返回FFmpeg可用状态和可能的错误信息"""
    try:
        # 获取FFmpeg路径
        ffmpeg_exe = get_ffmpeg_path()

        # 设置环境变量，帮助其他模块(如whisper)找到FFmpeg
        if os.path.isfile(ffmpeg_exe) and os.path.dirname(ffmpeg_exe):
            os.environ["PATH"] = os.path.dirname(ffmpeg_exe) + os.pathsep + os.environ.get("PATH", "")

        # 检查FFmpeg是否可用
        creation_flags = subprocess.CREATE_NO_WINDOW if sys.platform == "win32" else 0
        result = subprocess.run(
            [ffmpeg_exe, "-version"],
            capture_output=True,
            text=True,
            check=True,
            creationflags=creation_flags
        )

        # 提取版本信息
        version_info = result.stdout.split('\n')[0] if result.stdout else "FFmpeg可用但无法获取版本信息"
        print(f"FFmpeg可用: {version_info}")

        # 如果没有管理员权限且需要录制系统声音，显示警告
        if is_admin is False and sys.platform == "win32":
            print("警告: 程序未以管理员权限运行，录制系统声音等功能可能受限")

        return True, version_info

    except FileNotFoundError:
        error_msg = (
            "未找到FFmpeg。程序将尝试使用项目内置的FFmpeg，但即使成功某些功能可能受限。"
            "如需完整功能，请安装FFmpeg并添加到系统环境变量PATH中。\n"
            "下载地址: https://ffmpeg.org/download.html"
        )
        print(error_msg)
        return False, error_msg

    except subprocess.CalledProcessError as e:
        error_msg = f"FFmpeg命令执行失败: {e.stderr}"
        print(error_msg)
        return False, error_msg

    except Exception as e:
        error_msg = f"检测FFmpeg时出现错误: {str(e)}"
        print(error_msg)
        return False, error_msg

def main():
    # 配置全局日志系统
    log_dir = setup_global_logging()
    logger = get_logger('Main')  # 获取主程序的日志记录器

    # 添加管理员权限检测
    is_admin = False
    try:
        is_admin = ctypes.windll.shell32.IsUserAnAdmin() != 0
        logger.info(f"管理员权限状态: {'已获取' if is_admin else '未获取'}")
    except Exception as e:
        logger.error(f"检查管理员权限时出错: {e}")

    # 在程序启动时检查FFmpeg
    ffmpeg_available, ffmpeg_message = check_ffmpeg_availability()
    if not ffmpeg_available:
        # 如果FFmpeg不可用，显示错误信息
        messagebox.showwarning("FFmpeg警告", ffmpeg_message)
        # 程序可以继续运行，但某些功能可能不可用

    """主程序入口"""
    # 设置中文字体支持
    if os.name == 'nt':  # Windows系统
        ctypes.windll.shcore.SetProcessDpiAwareness(1)

    root = tk.Tk()
    root.title("外语口语练习助手")

    # 设置窗口图标
    try:
        icon_path = os.path.join(os.path.dirname(__file__), 'assets', 'icon.ico')
        if os.path.exists(icon_path):
            root.iconbitmap(icon_path)
    except Exception as e:
        logger.error(f"加载图标失败: {e}")

    # 设置主窗口大小和位置
    window_width = 1000
    window_height = 800
    root.geometry(f"{window_width}x{window_height}")
    center_window(root, window_width, window_height)

    # 设置窗口最小尺寸
    root.minsize(800, 600)

    # 确保主窗口可见
    root.update()
    root.deiconify()

    # 加载配置文件
    config = load_config()

    # 全局变量保存问卷窗口引用
    global questionnaire_window
    questionnaire_window = None

    # 重新定义启动流程函数
    def on_user_agreed():
        # 不再在这里调用mainloop，而是直接初始化播放器
        try:
            player = AudioPlayer(root)  # 假设 AudioPlayer 类已定义
            player.start()
        except Exception as e:
            messagebox.showerror("错误", f"程序启动失败: {str(e)}", icon='error')
            root.destroy()

    # 检查是否需要显示协议弹窗
    need_show_agreement = False
    current_time = int(time.time())

    if not config.get("agreed_to_terms", False):
        print('未同意协议')
        need_show_agreement = True
    elif is_new_week(config.get("last_weekly_check", 0)) and not config.get("shown_this_week", False):
        print('新的一周，需要重新同意协议')
        need_show_agreement = True
        # 标记本周已显示过
        config["shown_this_week"] = True
        config["last_weekly_check"] = current_time
        save_config(config)

    # 如果是新的一周但尚未设置标记，则重置标记
    if is_new_week(config.get("last_weekly_check", 0)) and not config.get("shown_this_week", False):
        config["shown_this_week"] = False
        save_config(config)

    def show_agreement_with_questionnaire():
        """显示协议窗口，然后是问卷窗口"""
        global questionnaire_window

        def on_questionnaire_complete():
            # 问卷完成后启动主程序
            on_user_agreed()

        # 显示协议窗口
        agreement_window = show_agreement_window(root, on_questionnaire_complete)
        # 等待协议窗口关闭
        root.wait_window(agreement_window)

        # 检查用户是否同意协议
        updated_config = load_config()
        if not updated_config.get("agreed_to_terms", False):
            print("用户未同意协议，程序退出")
            root.destroy()
            sys.exit(0)

    # 修改这部分代码，先启动定时器显示协议，而不是直接调用
    if need_show_agreement:
        # 使用after方法安排协议窗口的显示，不阻塞主循环
        root.after(100, show_agreement_with_questionnaire)
    else:
        print('无需显示协议窗口')
        # 使用after方法安排播放器的启动，不阻塞主循环
        root.after(100, on_user_agreed)

    # 启动主循环，确保所有窗口都能正常工作
    root.mainloop()


if __name__ == "__main__":
    main()
